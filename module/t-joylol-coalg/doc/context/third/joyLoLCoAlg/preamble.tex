% A ConTeXt document [master document: joylolCoAlg.tex]

\startchapter[title=Preamble]

\prependMkIVCode{default}
\startMkIVCode
%D \module
%D   [     file=t-joylol-coalg,
%D      version=2017.05.10,
%D        title=\CONTEXT\ User module,
%D     subtitle=The JoyLoL CoAlgebraic Extensions \ConTeXt\ module,
%D       author=Stephen Gaito,
%D         date=\currentdate,
%D    copyright=PerceptiSys Ltd (Stephen Gaito),
%D        email=stephen@perceptisys.co.uk,
%D      license=MIT License]

%C Copyright (C) 2017 PerceptiSys Ltd (Stephen Gaito)
%C
%C Permission is hereby granted, free of charge, to any person obtaining a
%C copy of this software and associated documentation files (the
%C "Software"), to deal in the Software without restriction, including
%C without limitation the rights to use, copy, modify, merge, publish,
%C distribute, sublicense, and/or sell copies of the Software, and to
%C permit persons to whom the Software is furnished to do so, subject to
%C the following conditions:
%C
%C The above copyright notice and this permission notice shall be included
%C in all copies or substantial portions of the Software.
%C
%C THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
%C OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
%C MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
%C IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
%C CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
%C TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
%C SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

% begin info
%
% title   : JoyLoL CoAlgebra definitions
% comment : Provides structured document and code generation
% status  : under development, mkiv only
%
% end info

\unprotect
\stopMkIVCode

\startMkIVCode
\protect \endinput
\stopMkIVCode

\prependLuaCode{default}
\startLuaCode
-- This is the lua code associated with t-joylol-coalg.mkiv

if not modules then modules = { } end modules ['t-joylol-coalg'] = {
    version   = 1.000,
    comment   = "joylol coalgegraic extensions - lua",
    author    = "PerceptiSys Ltd (Stephen Gaito)",
    copyright = "PerceptiSys Ltd (Stephen Gaito)",
    license   = "MIT License"
}

thirddata         = thirddata        or {}
thirddata.joylol  = thirddata.joylol or {}

local joylol      = thirddata.joylol

local coAlgs      = thirddata.joyLoLCoAlgs
coAlgs.theCoAlg   = {}
local theCoAlg    = coAlgs.theCoAlg

local litProgs    = thirddata.literateProgs or {}
local setDefs     = litProgs.setDefs
local shouldExist = litProgs.shouldExist
local build       = setDefs(litProgs, 'build')

local tInsert = table.insert
local tConcat = table.concat
local tRemove = table.remove
local tSort   = table.sort
local sFmt    = string.format
local sMatch  = string.match
local toStr   = tostring
local lpPP    = litProgs.prettyPrint

local pushData, pushProcess = joylol.pushData, joylol.pushProcess
local pushProcessQuoted = joylol.pushProcessQuoted
local popData, popProcess   = joylol.popData, joylol.popProcess
local newList, newDictionary = joylol.newList, joylol.newDictionary
local jEval = joylol.eval

if joylol.core then
  interfaces.writestatus(
    "joyLoL",
    joylol.core.context.gitVersion('commitDate')
  )
else
  interfaces.writestatus(
    "joyLoL",
    "partially loaded"
  )
end

-----------------------------------------------------------------------------
-- NOTE the following uses raw JoyLoL code to collect the coAlgebra's 
-- literate code description.

-- To understand this code.... **think categorically**

-- In JoyLoL a particular object in the category *is* the structure of the 
-- data stack, while a particular arrow in the category *is* the process 
-- stack.

-- To understand what these arrows are doing... you read the JoyLoL code 
-- in reverse order (from a 'jEval' up). 
-----------------------------------------------------------------------------

local function addNewDict(aCtx, dictName)
  pushProcess(aCtx, 'addToDict')
  newDictionary(aCtx)
  pushProcessQuoted(aCtx, dictName)
end

local function addNewList(aCtx, listName)
  pushProcess(aCtx, 'addToDict')
  newList(aCtx)
  pushProcess(aCtx, listName)
end

local function addStrToListNamed(aCtx, aStr, listName)
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'appendToEndList')
  pushProcessQuoted(aCtx, aStr) -- need to explicitly quote this string
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, listName)
end

local function writeCodeFile(aCtx, coAlgName, templateName, filePath, fileExt)
  local outFilePath = string.format('%s/%s.%s', filePath, coAlgName, fileExt)
  local outFile = io.open(outFilePath, 'w')
  outFile:write(pp.write(theCoAlg))
  pushProcess(aCtx, 'render')
  pushProcess(aCtx, 'getTemplate')
  pushProcessQuoted(aCtx, templateName)
  jEval(aCtx)
  local renderedBaseTemplate = popData(aCtx)
  texio.write_nl(renderedBaseTemplate)
  outFile:write('\n')
  outFile:write(renderedBaseTemplate)
  outFile:write('\n')
  outFile:close()
end

function coAlgs.createCoAlg()
  texio.write_nl("createCoAlg...")
  if not theCoAlg then return end
  local coAlgName = theCoAlg.name or 'unknown'
  texio.write_nl(string.format('creating JoyLoL CoAlgebra: [%s]', coAlgName))
  --
  local aCtx = theCoAlg.ctx
  coAlgs.loadTemplates(aCtx) -- contains a jEval
  --
  if theCoAlg.hasCHeader    then writeCodeFile(aCtx, coAlgName, 'cHeader',    'buildDir', 'h')   end
  if theCoAlg.hasCCode      then writeCodeFile(aCtx, coAlgName, 'cCode',      'buildDir', 'c')   end
  if theCoAlg.hasLuaCode    then writeCodeFile(aCtx, coAlgName, 'luaCode',    'buildDir', 'lua') end
  if theCoAlg.hasJoyLoLCode then writeCodeFile(aCtx, coAlgName, 'joyLoLCode', 'buildDir', 'joy') end
  --
  texio.write_nl(string.format(' created JoyLoL CoAlgebra: [%s]', coAlgName))
end

function coAlgs.newWord(wordName)
  texio.write_nl('newWord: ['..wordName..']')
  theCoAlg.curWord    = wordName
  local aCtx = theCoAlg.ctx
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'addToDict')
  addNewList(aCtx, 'preData')
  addNewList(aCtx, 'postData')
  addNewList(aCtx, 'preProcess')
  addNewList(aCtx, 'postProcess')
  addNewList(aCtx, 'joyLoLCode')
  addNewList(aCtx, 'cHeader')
  addNewList(aCtx, 'cCode')
  addNewList(aCtx, 'luaCode')
  newDictionary(aCtx)
  pushProcessQuoted(aCtx, wordName) -- need to explicitly quote this string
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, 'words')
  addStrToListNamed(aCtx, wordName, 'wordOrder')
  jEval(aCtx)
end

function coAlgs.endWord()
  theCoAlg.curWord = 'global'
end

function coAlgs.addPreDataStackDescription(name, condition)
  texio.write_nl('addPreDataStackDescription: ['..name..']['..condition..']')
  local aCtx = theCoAlg.ctx
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'appendToEndList')
  pushProcess(aCtx, 'addToDict')
  pushProcessQuoted(aCtx, condition)
  pushProcessQuoted(aCtx, 'condition')
  pushProcess(aCtx, 'addToDict')
  pushProcessQuoted(aCtx, name)
  pushProcessQuoted(aCtx, 'name')
  newDictionary(aCtx) -- new dictionary for this condition
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, 'preData')
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, theCoAlg.curWord)
  pushProcess(aCtx, 'lookupInDict')
  pushProcess(aCtx, 'words')
  jEval(aCtx)
end

function coAlgs.addPostDataStackDescription(condition)
  texio.write_nl('addPostDataStackDescription: ['..condition..']')
  local aCtx = theCoAlg.ctx
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'appendToEndList')
  pushProcess(aCtx, 'addToDict')
  pushProcessQuoted(aCtx, condition)
  pushProcessQuoted(aCtx, 'condition')
  newDictionary(aCtx) -- new dictionary for this condition
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, 'postData')
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, theCoAlg.curWord)
  pushProcess(aCtx, 'lookupInDict')
  pushProcess(aCtx, 'words')
  jEval(aCtx)
end

function coAlgs.addPreProcessStackDescription(name, condition)
  texio.write_nl('addPreProcessStackDescription: ['..name..']['..condition..']')
  local aCtx = theCoAlg.ctx
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'appendToEndList')
  pushProcess(aCtx, 'addToDict')
  pushProcessQuoted(aCtx, condition)
  pushProcessQuoted(aCtx, 'condition')
  pushProcess(aCtx, 'addToDict')
  pushProcessQuoted(aCtx, name)
  pushProcessQuoted(aCtx, 'name')
  newDictionary(aCtx) -- new dictionary for this condition
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, 'preProcess')
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, theCoAlg.curWord)
  pushProcess(aCtx, 'lookupInDict')
  pushProcess(aCtx, 'words')
  jEval(aCtx)
end

function coAlgs.addPostProcessStackDescription(condition)
  texio.write_nl('addPostProcessStackDescription: ['..condition..']')
  local aCtx = theCoAlg.ctx
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'appendToEndList')
  pushProcess(aCtx, 'addToDict')
  pushProcessQuoted(aCtx, condition)
  pushProcessQuoted(aCtx, 'condition')
  newDictionary(aCtx) -- new dictionary for this condition
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, 'postProcess')
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, theCoAlg.curWord)
  pushProcess(aCtx, 'lookupInDict')
  pushProcess(aCtx, 'words')
  jEval(aCtx)
end

function coAlgs.addJoyLoLCode(bufferName)
  texio.write_nl('addJoyLoLCode: ['..bufferName..']')
  theCoAlg.hasJoyLoLCode = true
  local aCtx = theCoAlg.ctx
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'appendToEndList')
  pushProcessQuoted(aCtx, buffers.getcontent(bufferName))
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, 'joyLoLCode')
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, theCoAlg.curWord)
  pushProcess(aCtx, 'lookupInDict')
  pushProcess(aCtx, 'words')
  jEval(aCtx)
end

function coAlgs.addCHeader(bufferName)
  texio.write_nl('addCHeader: ['..bufferName..']')
  theCoAlg.hasCHeader = true
  local aCtx = theCoAlg.ctx
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'appendToEndList')
  pushProcessQuoted(aCtx, buffers.getcontent(bufferName))
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, 'cHeader')
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, theCoAlg.curWord)
  pushProcess(aCtx, 'lookupInDict')
  pushProcess(aCtx, 'words')
  jEval(aCtx)
end

function coAlgs.addCCode(bufferName)
  texio.write_nl('addCCode: ['..bufferName..']')
  theCoAlg.hasCCode = true
  local aCtx = theCoAlg.ctx
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'appendToEndList')
  pushProcessQuoted(aCtx, buffers.getcontent(bufferName))
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, 'cCode')
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, theCoAlg.curWord)
  pushProcess(aCtx, 'lookupInDict')
  pushProcess(aCtx, 'words')
  jEval(aCtx)
end

function coAlgs.addLuaCode(bufferName)
  texio.write_nl('addLuaCode: ['..bufferName..']')
  theCoAlg.hasLuaCode = true
  local aCtx = theCoAlg.ctx
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'popData')
  pushProcess(aCtx, 'appendToEndList')
  pushProcessQuoted(aCtx, buffers.getcontent(bufferName))
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, 'luaCode')
  pushProcess(aCtx, 'lookupInDict')
  pushProcessQuoted(aCtx, theCoAlg.curWord)
  pushProcess(aCtx, 'lookupInDict')
  pushProcess(aCtx, 'words')
  jEval(aCtx)
end

coAlgs.joylol = joylol

interfaces.writestatus('joyLoLCoAlg', "loaded JoyLoL CoAlgs")
\stopLuaCode

\prependLuaTemplate{default}
\startLuaTemplate
if not modules then modules = { } end modules ['t-joylol-coalg-templates'] = {
    version   = 1.000,
    comment   = "JoyLoL CoAlgebraic extensions module - templates",
    author    = "PerceptiSys Ltd (Stephen Gaito)",
    copyright = "PerceptiSys Ltd (Stephen Gaito)",
    license   = "MIT License"
}

thirddata              = thirddata              or {}
thirddata.joyLoLCoAlgs = thirddata.joyLoLCoAlgs or {}

local coAlgs     = thirddata.joyLoLCoAlgs

local templates  = { }

templates.cHeader = [=[
This is the start of a cHeader template
{{ lookupInDict 'coAlgName }}
This is the end of a cHeader template
]=]

templates.cCode = [=[
This is the start of a cCode template
{{ lookupInDict 'coAlgName }}
This is the end of the cCode template
]=]

templates.joyLoLCode = [=[
This is the start of a joyLoLCode template
{{ lookupInDict 'coAlgName }}
This is the end of the joyLoLCode template
]=]

templates.luaCode = [=[
-- A Lua file (automatically generated)
{{ lookupInDict 'coAlgName }}
This is the end of the luaCode template
]=]

local joyLoL = coAlgs.joyLoL
local pushData, pushProcess = joyLoL.pushData, joyLoL.pushProcess
local pushProcessQuoted = joyLoL.pushProcessQuoted
local popData, popProcess   = joyLoL.popData, joyLoL.popProcess
local newList, newDictionary = joyLoL.newList, joyLoL.newDictionary
local jEval = joyLoL.eval

-----------------------------------------------------------------------------
-- NOTE the following uses raw JoyLoL code to load the templates into the 
-- context provided. 

-- To understand this code.... **think categorically**

-- In JoyLoL a particular object in the category *is* the structure of the 
-- data stack, while a particular arrow in the category *is* the process 
-- stack.

-- To understand what these arrows are doing... you read the JoyLoL code 
-- in reverse order (from a 'jEval' up). 
-----------------------------------------------------------------------------

function coAlgs.loadTemplates(aCtx)
  pushProcess(aCtx, 'addToDict')
  for aKey, aValue in pairs(templates) do
    pushProcess(aCtx, 'addToDict')
    pushProcessQuoted(aCtx, aValue)
    pushProcessQuoted(aCtx, aKey)
  end
  newDictionary(aCtx)
  pushProcessQuoted(aCtx, 'templates')
  jEval(aCtx)
end

interfaces.writestatus('joyLoLCoAlg', 'loaded JoyLoL CoAlg templates')
\stopLuaTemplate

\stopchapter
