% LaTeX source for the trans-finite Turing document
%

%\documentclass[a4paper,openany]{amsbook}
\documentclass[a4paper,openany]{amsart}
\usepackage{disitt}
\usepackage{disitt-symbols}
\usepackage{mdframed}
\newmdenv[linecolor=white,backgroundcolor=gray!10]{infobox}
\newenvironment{myQuote}{\begin{quotation}}{\end{quotation}}
\surroundwithmdframed[linecolor=white,backgroundcolor=gray!10]{myQuote}

\begin{document}
%\frontmatter
\sloppy

\title[Computation: Classical version]{Trans-finite Computation: The classical version}
\input{frontMatter}
\subjclass[2010]{Primary unknown; Secondary unknown} %
\keywords{Keyword one, keyword two etc.}%

\begin{abstract}
We investigate what it means for a finite being to verify trans-finite computational
algorithms.
\end{abstract} 
\maketitle 
\tableofcontents 
%\mainmatter


\section{Introduction}

What is a computation? Turing, \cite{turing1936computableNumbersMachines}, is cited by
G\"odel, \cite{godel}, as providing the first convincing \emph{mechanistic} mathematical
definition of a computational process as performed by a human. Turing's student, Gandy,
\cite{gandy1980churchsThesisMechanisms}, provided a similar \emph{mechanistic}
mathematical definition of a computational process as performed by a \emph{finite
machine}. Both Turing and Gandy focused upon providing arguments justifying why particular
mathematical structures provided reasonable definitions of computation. In order to
understand potentially trans-finite computation, we will take an essentially dual
approach. We will look at mathematical structures which represent \emph{traces} of a
(trans-finite) computation, and then work back to mathematical structures which could have
produced these traces. Rather surprisingly, to capture \emph{trans-finite} computational
traces, we are forced investigate the \emph{categorical} structures of labelled graphs.

What is a computation? Any \emph{description} of a computational process made by a finite
being, will inevitably consist of a collection of ``marks in the sand'', ink-marks on
paper, or bit-patterns in the memory of a computer. Theoretical Computer Science has three
ways of verifying properties of the computational processes represented by these
collections of symbols. 
%
\begin{itemize}
%
\item \define{Operational Semantics}{},
\cite{plotkin1981structuralOperationalSemantics}, provides a description of a transition 
system which models a program.
%
\item \define{Denotational
Semantics}{}, \cite{scott1970theoryComputation, stoy1981scottStracheyTheory}, provides
mathematical structures which represent the underlying \emph{state} of a compuation.
%
\item \define{Axiomatic Semantics}{}, \cite{floyd1967programSemantics, 
hoare1969axiomaticSemantics} provides an axiomatic system of natural deduction rules with 
which to \emph{prove} that a program meets a specific \emph{logical} specification.
%
\end{itemize}
%
Winskel, \cite{winskel1993formalSemanticsProgrammingLanguages}, provides a good
introduction to these three types of computational semantics\footnote{Not surprisingly the
ideas contained in this article were originally inspired by Winskel's study of
computational traces using event structures and bisimulation, see, for example,
\cite{winskel2007eventStructures}, and \cite{joyalNielsenWinskel1996bisimulation}}. Gries,
\cite{gries1981scienceProgramming}, provides a particularly detailed account of building
programs via their axiomatic semantical proofs of correctness.

What is a computation? A \define{computation}{} is the transformation of one mathematical
structure representing an un-transformed \define{state}{} into a correspondingly modified
mathematical structure representing the transformed state. Essentially the genius of
Turing and Gandy was to define those transformations which a finite human, or machine
could perform. What happens if we place no such restrictions? If there are no
restrictions, how do we know what a computation computes?

\TODO{merge these different introductions}

This paper is a prequel to our cycle of papers aiming to provide a rigorous mathematical
theory of what limited, ``Modi-potent'', beings can understand of Reality. One of the
central tenets of this ``Theory of Reality'' is that the correct foundations of
Mathematics is not first order logic but rather computation. However to recover all of
classical mathematics inside these computational foundations, we need a theory of
computation which is more powerful than classical (non oracle) Turing machines allow. This
paper provides definitions of these more powerful, trans-finite Turing machines in a
classical Set Theory setting. Subsequent papers will redo these definitions in the context
of computational foundations.

There have been numerous previous attempts to define ``more powerful'' Turing machines,
some of which, for example, oracle or ``o-machines'', date back to Turing's original work.
More recently the area of ``hypercomputation'' has attracted some interest, some of which
is rather controversial. Ord, \cite{ord2006hyperComputation}, provides a good review of
much of this work\footnote{For a high-level overview with some additional citations, see
the Wikipedia articles, \cite{wikipedia2015hyperComputation} and
\cite{wikipedia2015superRecursiveAlgorithm}, as well as the nLab article,
\cite{nLab2015hyperComputation}}. Some authors claim that there (may) exist physical
implementations of hypercomputational devices, \emph{we make \emph{no} such claims}.
Davis, \cite{davis2004hyperComputation}, provides a summary of some of the arguments
against these claims. Instead, our interest comes from our desire to capture
non-constructive classical mathematics in a computational setting.

\TODO{\cite{hamkinsLewis1998inifiniteTimeTuringMachines}}

Our aim in this paper is to explicitly explore a more uniform definition of Turing machine
which will differ simply in the power of the maximal ordinal used by the Turing machine.
We do this using ``classical'' socially checked proofs using ``classical'' set theory. You
are welcome to choose your favourite axiomization using first order predicate logic. In
subsequent papers we will found mathematics using a form of trans-finite computation which
is equivalent to our current definition of trans-finite Turing Machine. 

Classically, the interest and hence the definitions of both computation and set theory,
have been focused upon computations which \emph{halt} and sets which are
\emph{well-founded}. Our computational foundations will admit that there are some
interesting computations and structures which do not halt or, alternatively, are
non-well-founded. In categorical terms the halting computations and well-founded sets are
\emph{algebraic}, while the non-halting processes and non-well-founded structures are
\emph{co-algebraic}. While we will not make any use of co-algebraic structures in this
paper, our subsequent papers will make essential use of these co-algebraic structures.

Of particular importance for either the classical or computational definitions of
trans-finite computation, is the power of the Axiom of Choice(s) used. For our purposes
there are three versions of the Axiom of Choice, in increasing power:
%
\begin{enumerate}
\item Prime Ideal Theorem (PIT)
\item Axiom of Choice (AoC)
\item Global Axiom of Choice (GAoC)
\end{enumerate}

The Prime Ideal Theorem (PIT) is used to define the ``result'' of computation at
limit ordinals, which corresponds to creation of limit points or alternatively
the closure, via ``ideal points'' of any computation.

The Axiom of Choice (AoC) itself, is used to define sequential computation, or
equivalently, to ensure the existence of lists of any required ordinal size.

While we will not use the Global Axiom of Choice (GAoC) in any essential way in
our work, we will see that the GAoC is required to ensure the existence of
co-algebraic lists, when we work, in subsequent papers, with Co-Algebraic
structures.

\section{Graphs, refinements, and paths}

In anticipation of our future work, we take a slightly non-standard route towards defining
(trans-finite) computation. We leave it to the reader to understand both why we take
this route, and that we have, in fact, provided the same structures.

One of the central themes of this cycle of papers is the importance of graphs, paths and
(co-)algebraic refinements. We start by defining (trans-finite) graphs.

There are essentially two distinct ways to define a mathematical structure: logically, by
explicitly assuming the existence of a set with specific (logically expressed) properties,
or computationally, in categorical language, as the fixed point of an endofunctor. From a
non-categorical inductive point of view, an early expression of this dichotomy can be
found in \cite[page 1]{moschovakis1974induction}. In this paper we follow the logical
approach. In subsequent papers in this cycle, we will use the computational approach.

There are relatively few discussions of non-finite graphs from which we mention Reinhard
Diestel's work, \cite{diestel2006graphTheory, diestel1990infiniteGraphTheory}.
Unfortunately, for trans-finite graphs, we must go, more or less, ``on beyond
zebra''\footnote{Growing up, one of my favourite books was Dr Seuss' ``On beyond Zebra'',
\cite{seuss1955onBeyondZebra}. \emph{Be warned}: One of my greatest faults is that I seem
congenitally incapable of staying within ``obvious'' bounds...}\footnote{Another of my
greatest faults is that my mind is a web of snippets of ideas. Linearizing this web into
single narrative, is \emph{very} hard for me to do, and may be hard to fully follow until 
you have heard ``the whole shaggy-dog story''.}.

Our definition of graph is inspired by the definition of metagraph in
\cite{macLane1971categoriesWorkingMathematician} section I.1. Note that our definition is
a generalisation of most typical definitions, for example \cite[section
1.1]{diestel2006graphTheory}. Categorically, a graph is simply a presheaf on the category
$ \cdot \substack{\mathbf{\longrightarrow} \\[-0.7ex] \mathbf{\longrightarrow}} \cdot $

\begin{definition}

A \define{(directed) graph}{}, $G(E, V, \pi_0, \pi_1)$, is a set, $E$, of
\define{edges}{}, and a set, $V$, of \define{verticies}{}, together with two maps, 
\map{\pi_0}{E}{V} and \map{\pi_1}{E}{V}, called the source and target maps.

A \define{labeled graph}{}, $lG(E, V, L_E, L_V, \pi_0, \pi_1, l_E, l_V)$, is a graph $G(E, 
V, \pi_0, \pi_1)$ together with a set, $L_E$, of \define{edge labels}{}, and a set, $L_V$, 
of \define{vertex labels}{}, and maps, \map{l_E}{E}{L_E}, and \map{l_V}{V}{L_V}. Often the 
set of vertex labels, $L_V$, and vertex label map, $l_V$, are omitted (or 
alternatively the the set of vertex labels is assumed to be the trivial one point set).

\end{definition}



Our next goal is to provide a definition of ``path''. Intuitively a (directed) ``path''
\emph{in} a graph is an embedding of a ``linearly'' directed graph.

\begin{definition}

A \define{(directed) 1-path}{}, $P(E, V, \pi_0, \pi_1)$, is a graph for which for any
\emph{distinct} pair of vertices, $x$ and $y$, then \emph{exactly one} of the following is
true:

\begin{enumerate}
\item $(x,y) \in E$, 
\item $(y,x) \in E$.
\end{enumerate}

\end{definition}

For at most countable graphs, defining ``linearity'' is relatively easily done by
``following'' single edges corresponding to the ``successor'' or ``next'' operation. For
trans-finite graphs we must add something more to be able to deal with ``limit points''.
Rather surprisingly, to deal with these ``limit points'' it is convenient to define
1-Categories, since a Category which is, sequentially complete as well as sequentially
cocomplete, is a graph which explicitly includes all of its ``paths''. Categorically, a
category is a presheaf on the category
$ \bullet \substack{\mathbf{\longrightarrow} \\[-0.7ex] \mathbf{\longleftarrow} 
\\[-0.7ex] \mathbf{\longrightarrow} } \bullet $
equipped with a consistent collection of 2-simplicies which are declared
``thin''\footnote{This way of looking at 1-categories is inspired by the work of Dominic
Verity, see, for example, \cite{verity2005complicialSets},
\cite{verity2006complicialSimplicialHomotopy} and
\cite{verity2006simplicialComplicialCategories}.}.

\begin{definition}

A \define{1-category}{}, $C(E, V, \pi_0, \pi_1, i)$, is a graph with the addition of an 
\define{identity map}{} \map{i}{V}{E} for which $\pi_0 \compose i$ and $\pi_1 
\compose i$ are both the identity of the set $V$, and for which 

\begin{itemize}

\item If $f, g \in E$ and $\pi_1(f) = \pi_0(g)$ then there exists $f \compose g \in E$ for 
which $ \pi_0(f) = \pi_0(f \compose g)$ and $ \pi_1(f \compose g) = \pi_1(g)$

\item If $f \in E$ then $ f \compose i(\pi_0(f)) = f$ and $i(\pi_1(f)) \compose f = f$

\item If \map{f}{w}{x}, \map{g}{x}{y} and \map{h}{y}{z} then the graph, $hgf(\set{f,
g, h}, \set{w, x, y, z}, \pi_0, \pi_1)$ can be extended to a 1-path embedded in $C$ in only 
one way

\end{itemize}

\end{definition}

\begin{lemma}

Consider a 1-path, $P(E, V, \pi_0, \pi_1)$, and three \emph{distinct} vertices, $x$, $y$, 
$z$. Without loss of generality, assume that $(x, y)$ is a directed edge in $P$, that is 
$(x,y) \in E$.

\begin{cTikzPictureWorking}

\coordinate (X) at (-1,0);
\coordinate (Y) at (1,0);
\coordinate (Z) at (0,1);

\fill (X) circle[radius=1pt];
\fill (Y) circle[radius=1pt];
\fill (Z) circle[radius=1pt];

\begin{scope}[shorten >=4pt, shorten <=4pt]
\path (X) edge[->]     node (XY) {} (Y);
\path (Y) edge[dashed] node (YZ) {} (Z);
\path (X) edge[dashed] node (XZ) {} (Z);
\end{scope}

\node[below left]  at (X) {x};
\node[below right] at (Y) {y};
\node[above]       at (Z) {z};

\end{cTikzPictureWorking}

Then \emph{exactly one} of the following is true.

\begin{enumerate}

\item If $(z,x) \in E$, then $(z,y) \in E$
\item If $(y,z) \in E$, then $(x,z) \in E$
\item $(x,z) \in E$ and $(z,y) \in E$,

\end{enumerate}

\end{lemma}

\begin{proof} \par \par

\textbf{Case 1:} If $(z,x) \in E$ then $\pi_1(z,x) = x = \pi_0(x, y)$ we have
$(z,x)\compose(x,y) \in E$. Since $\pi_0((z,x)\compose(x,y)) = z$ and
$\pi_1((z,x)\compose(x,y)) = y$ we know that $(z,x)\compose(x,y)$ is an edge in $P$ but
$P$ has only one edge between $z$ and $y$, hence $(z,x)\compose(x,y) = (z,y)$.

\textbf{Case 2:} If $(y,z) \in E$ then by an argument similar to case 1, we have $(x,z) \in E$.

\textbf{Case 3:} Since neither of the above two cases apply, we know that $(z,x) \notin E$ and $(y,z) \notin E$. Since $P$ is a 1-path, this means that $(x,z) \in E$ and $(z,y) \in E$.

\end{proof}

\begin{definition}
A \define{refinement}{} is 
\end{definition}

\section{State machines}

\begin{definition}

A state machine... A finite state machine is a state machine ...

\end{definition}

\subsection{$\aleph_0$-non-deterministic Turing Machine}

\subsection{o-machines}

\section{Trans-finite defintions}

\section{Relationship with o-machines}

\begin{theorem}

Given a set, $\gamma$, there exists a trans-finite Turing machine, $T$, corresponding to
the $\gamma$-o-machine, $O$.

\end{theorem}


\begin{theorem}

Given a trans-finite Turing machine, $T$, there exists a set, $\gamma$, and a
$\gamma$-o-machine, $O$, that simulates $T$.

\end{theorem}

\begin{proof}
something proving the previous theorem.
\end{proof}

\section{Trans-finite computability theory}


\bibliographystyle{amsalpha}
\bibliography{transFiniteComputation}

\end{document}

