% A ConTeXt document [master document: coreTextadept.tex]

\section[title=Lua interface]

\component gitVersion-c

\startCCode
static int lua_core_textadept_getGitVersion (lua_State *lstate) {
  const char* aKey   = lua_tostring(lstate, 1);
  if (aKey) {
    getGitVersionInto(gitVersionKeyValues, aKey, aValue);
    lua_pushstring(lstate, aValue);
  } else {
    lua_pushstring(lstate, "no valid key provided");
  }
  return 1;
}

static int lua_core_textadept_setVerbose(lua_State *lstate) {
  Boolean verbose = 
    (lua_toboolean(lstate, 1) ? TRUE : FALSE);
  getJoyLoLInterpInto(lstate, jInterp);
  assert(jInterp);
  assert(jInterp->rootCtx);
  jInterp->verbose = verbose;
  jInterp->rootCtx->verbose = verbose;
  lua_pop(lstate, 1);
  return 0;
}

static int lua_core_textadept_setDebugging(lua_State *lstate) {
  Boolean debugFlag = 
    (lua_toboolean(lstate, 1) ? TRUE : FALSE);
  getJoyLoLInterpInto(lstate, jInterp);
  assert(jInterp);
  jInterp->debug = debugFlag;
  lua_pop(lstate, 1);
  return 0;
}

static int lua_core_textadept_pushLoadPath(lua_State *lstate) {
  Symbol *aPath = lua_tostring(lstate, 1);
  getJoyLoLInterpInto(lstate, jInterp);
  pushLoadPath(jInterp->loader, aPath);
  lua_pop(lstate, 1);
  return 0;
}

static int lua_core_textadept_loadFile(lua_State *lstate) {
  Symbol *aFile = lua_tostring(lstate, 1);
  getJoyLoLInterpInto(lstate, jInterp);
  loadAFile(jInterp->rootCtx, aFile);
  lua_pop(lstate, 1);
  return 0;
}

static int lua_core_textadept_evalString(lua_State *lstate) {
  Symbol *aString = lua_tostring(lstate, 1);
  getJoyLoLInterpInto(lstate, jInterp);
  evalStringInContext(jInterp->rootCtx, aString);
  lua_pop(lstate, 1);
  return 0;
}


static const struct luaL_Reg lua_core_textadept [] = {
  { "gitVersion",   lua_core_textadept_getGitVersion },
  { "setVerbose",   lua_core_textadept_setVerbose    },
  { "setDebugging", lua_core_textadept_setDebugging  },
  { "pushLoadPath", lua_core_textadept_pushLoadPath  },
  { "loadFile",     lua_core_textadept_loadFile      },
  { "evalString",   lua_core_textadept_evalString    },
  {NULL, NULL}
};

static void coreTextadeptWriteStdOut(
  JoyLoLInterp *jInterp,
  Symbol       *aMessage
) {
  assert(jInterp);
  lua_State *lstate = jInterp->lstate;
  assert(lstate);

  lua_getglobal(lstate, "buffer");
  lua_getfield(lstate, -1, "append_text");
  lua_getglobal(lstate, "buffer");
  lua_pushstring(lstate, aMessage);
  if (lua_pcall(lstate, 2, 1, 0)) {
    /*return*/ luaL_error(lstate,
      "Failed to append message [%s] to current buffer\nERROR:\n%s\n",
      aMessage,
      lua_tostring(lstate, -1)
    );
  }
  lua_pop(lstate, 1);
}

static void coreTextadeptWriteStdErr(
  JoyLoLInterp *jInterp,
  Symbol       *aMessage
) {
  assert(jInterp);
  lua_State *lstate = jInterp->lstate;
  assert(lstate);

  lua_getglobal(lstate, "ui");
  lua_getfield(lstate, -1, "print");
  lua_pushstring(lstate, aMessage);
  if (lua_pcall(lstate, 1, 1, 0)) {
    /*return*/ luaL_error(lstate,
      "Failed to append message [%s] to Message Buffer\nERROR:\n%s\n",
      aMessage,
      lua_tostring(lstate, -1)
    );
  }
  lua_pop(lstate, 1);
}

static Boolean beVerbose(lua_State *lstate) {
  lua_getglobal(lstate, "joylol");
  lua_getfield(lstate, -1, "options");
  lua_getfield(lstate, -1, "verbose");
  Boolean isVerbose = (Boolean)lua_toboolean(lstate, -1);
  lua_pop(lstate, 3);
  return isVerbose;
}


static void *coreTextadeptCallback(
  lua_State *lstate,
  size_t resourceId
) {
  if (resourceId == JoyLoLCallback_StdOutMethod) {
    StdOutputMethod *coreWriteStdOut =
      coreTextadeptWriteStdOut;
    return (void*)coreWriteStdOut;
  } else if (resourceId == JoyLoLCallback_StdErrMethod) {
    StdOutputMethod *coreWriteStdErr =
      coreTextadeptWriteStdErr;
    return (void*)coreWriteStdErr;
  } else if (resourceId == JoyLoLCallback_Verbose) {
    Boolean isVerbose = beVerbose(lstate);
    return (void*)isVerbose;
  }
  return NULL;
} 

int luaopen_joylol_core_textadept (lua_State *lstate) {
  setJoyLoLCallbackFrom(lstate, coreTextadeptCallback);
  lua_getglobal(lstate, "require");
  lua_pushstring(lstate, "joylol.jInterps");
  if (lua_pcall(lstate, 1, 1, 0)) {
    return luaL_error(lstate,
      "Failed to load [joylol.jInterps]\nERROR:\n%s\n",
      lua_tostring(lstate, -1)
    );
  }
  getJoyLoLInterpInto(lstate, jInterp);
  lua_pushstring(lstate, "core");
  lua_createtable(lstate,0, 1); // joylol.core 
  lua_pushstring(lstate, "textadept");
  luaL_newlib(lstate, lua_core_textadept);
  lua_settable(lstate, -3);
  lua_settable(lstate, -3);
  return 1;
}
\stopCCode