% A ConTeXt document [master document: cTests.tex]

\section[title=Code]
\setCHeaderStream{private}

\startCHeader
typedef struct ctest_io_struct {
  FILE*  memFile;
  char*  buffer;
  size_t bufSize;
} CTestIO;

Boolean initCTestIO(void);
\stopCHeader

\startCCode
static CTestIO userStdout = { NULL, NULL, 0 };
static CTestIO userStderr = { NULL, NULL, 0 };

Boolean initCTestIO(void) {
  userStdout.memFile = NULL;
  userStdout.buffer  = NULL;
  userStdout.bufSize = 0;
  openUserOutput();
  
  userStderr.memFile = NULL;
  userStderr.buffer  = NULL;
  userStderr.bufSize = 0;
  openUserError();
  
  return userStdout.memFile && userStderr.memFile;
}
\stopCCode

\startTestSuite[user output]

\startCHeader
extern Boolean openUserOutput(void);
\stopCHeader

\startCCode
Boolean openUserOutput(void) {
  if (userStdout.memFile &&
    userStdout.buffer &&
    (0 < userStdout.bufSize)) closeUserOutput();

  userStdout.memFile = NULL;
  userStdout.buffer  = NULL;
  userStdout.bufSize = 0;
  userStdout.memFile =
    open_memstream(&userStdout.buffer, &userStdout.bufSize);
  if (!userStdout.memFile) closeUserOutput();
  
  return (userStdout.memFile ? TRUE : FALSE);
}
\stopCCode

\startCHeader
extern void closeUserOutput(void);
\stopCHeader

\startCCode
void closeUserOutput(void) {
  if (userStdout.memFile &&
    userStdout.buffer &&
    (0 < userStdout.bufSize)) {
    fclose(userStdout.memFile);
    free(userStdout.buffer);
  }
  userStdout.memFile = NULL;
  userStdout.buffer  = NULL;
  userStdout.bufSize = 0;
}
\stopCCode

\setCHeaderStream{public}
\startCHeader
void clearUserOutput(void);
\stopCHeader

\startCCode
void clearUserOutput(void) {
  closeUserOutput();
  openUserOutput();
}
\stopCCode

\startCHeader
extern char* getUserOutput(void);
\stopCHeader
\setCHeaderStream{private}

\startCCode
char* getUserOutput(void) {
  fflush(userStdout.memFile);
  return userStdout.buffer;
}
\stopCCode

\startCHeader
extern Boolean writeToUser(
  CoAlgObj* aLoL,
  CoAlgObj* separators
);
\stopCHeader

\startCCode
Boolean writeToUser(
  CoAlgObj* aLoL,
  CoAlgObj* separators
) {
  return TRUE;
}
\stopCCode

\startCHeader
extern Boolean printfToUser(
  const char* format, 
  ...
);
\stopCHeader

\startCCode
Boolean printfToUser(
  const char* format,
  ...
) {
  va_list printfArgs;
  va_start(printfArgs, format);
  int numChars = vfprintf(userStdout.memFile, format, printfArgs);
  va_end(printfArgs);
  return (0 <= numChars);
}
\stopCCode

\startTestCase[should return output to the user]
\startCTest
  clearUserOutput();
  printfToUser("this is a test [%s]", "another test");
  AssertStrEquals(getUserOutput(), "this is a test [another test]");
\stopCTest
\stopTestCase
\stopTestSuite

\startCHeader
extern Boolean openUserError(void);
\stopCHeader

\startCCode
Boolean openUserError(void) {
  if (userStderr.memFile &&
    userStderr.buffer &&
    (0 < userStderr.bufSize)) closeUserError();

  userStderr.memFile = NULL;
  userStderr.buffer  = NULL;
  userStderr.bufSize = 0;
  userStderr.memFile =
    open_memstream(&userStderr.buffer, &userStderr.bufSize);
  
  if (!userStderr.memFile ||
    !userStderr.buffer) closeUserError();
  
  return (userStderr.memFile ? TRUE : FALSE);
}
\stopCCode

\startCHeader
extern void closeUserError(void);
\stopCHeader

\startCCode
void closeUserError(void) {
  if (userStderr.memFile &&
    userStderr.buffer &&
    (0 < userStderr.bufSize)) {
    fclose(userStderr.memFile);
    free(userStderr.buffer);
  }
  userStderr.memFile = NULL;
  userStderr.buffer  = NULL;
  userStderr.bufSize = 0;
}
\stopCCode

\setCHeaderStream{public}
\startCHeader
void clearUserError(void);
\stopCHeader

\startCCode
void clearUserError(void) {
  closeUserError();
  openUserError();
}
\stopCCode

\startCHeader
extern char* getUserError(void);
\stopCHeader
\setCHeaderStream{private}

\startCCode
char* getUserError(void) {
  return userStderr.buffer;
}
\stopCCode

\startTestSuite[do something]

\startTestCase[should do something]
\startCTest
  AssertPtrNotNull(jInterp);
\stopCTest
\stopTestCase
\stopTestSuite
