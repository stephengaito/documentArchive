% A ConTeXt document [master document: ../jInterp.tex ]

\subsection[title=Primitives]

\TODO{At the moment we do NOT deal correctly with UTF-8 characters.... 
which we can and should.} 

We need to implement the following \joylol\ words:

\startitemize[1]

\item \bold{\type{Fail}} successively takes items off the process stack 
until it reaches a choice symbol. It then places the last list back on the 
process stack. 

\item \bold{\type{Commit}} takes no arguments, and ensures that the first 
subsequent failure is ignored.

\item \bold{\type{Choice}} takes a list of patterns and applies each in 
turn until one succeeds. It does this by taking the top item off the list 
and then placing, itself, the reduced list, and then prepends the top item 
onto the process stack. 

\item \bold{\type{Any}} takes one argument which is the number of 
characters to match. All characters will match. 

\item \bold{\type{Pattern}} takes one argument which is the explicit 
sequence of characters which should be matched. 

\item \bold{\type{CharSet}} Takes two arguments. The first argument should 
be a list of symbols which together make up the set of characters which 
can be matched once. The second argument is the number of characters which 
\emph{must} match characters in the character set. 

\item \bold{\type{coCharSet}} Takes two arguments. The first argument 
which like a \bold{\type{CharSet}}, should be a list of symbols which 
together make up the set of characters which \emph{should not} be matched, 
all characters which are \emph{not} in the character set \emph{will} be 
matched. The second argument is the number of characters which \emph{must} 
\emph{not} match characters in the character set.

\item \bold{\type{Span}} Takes two arguments. The top argument is the list 
of symbols from which to form the character set. The second argument is 
the minimum number of times that should be matched by this character set. 
A \bold{\type{span}} matches as many consecutive characters that are in 
the character set as possible. \bold{\type{Span}} will only fail if it can 
not match at least the specified minimum number of characters. 

\item \bold{\type{coSpan}} Like \bold{\type{Span}}, \bold{\type{coSpan}}, 
takes two arguments. The top argument is a list of symbols from which to 
form the character set. The second argument is the minimum number of times 
that should be matched by characters which are \emph{not} in this 
character set. A \bold{\type{coSpan}} matches as many consecutive 
characters that are \emph{not} in the character set as possible. 
\bold{\type{coSpan}} will only fail if it can not match at least the 
specified minimum number of characters. 

\item \bold{\type{RepeatAtLeast}} repeats the top pattern at least second 
argument times. 

\item \bold{\type{RepeatAtMost}} repeats the top pattern at most second 
argument times. 

\stopitemize 

\TODO{We have not covered \quote{\bold{\type{not}}}, 
\quote{\bold{\type{and}}}, CharSet difference, captures, or actions on 
captures.} 

As suggested in \cite{ierusalimschy2008lpegArticle} we might implement 
captures using a \type{Capture} call with three distinct arguments: 

\startitemize[n] 

\item \type{begin n} where the actual capture begins $n$ characters before 
the current character. This capture method should be called \emph{as soon 
as} it is known that the current path will succeed. 

\item \type{end} this marks the end of a capture 

\item \type{full n} this is the same as a \type{begin n} immediately 
followed by an \type{end}. 

\stopitemize 

For all of the above \joylol\ words, the data stack must include both the 
current text structure (which must include a indication of the current 
character) as well as the current collection of captures. 

A compiler is a pipeline of co-routines. The parser might itself be a 
pipeline of co-routines, one for the lexer, one for the ultimate parser, 
but there could be numerous intermediary co-routines parsing more complex 
syntactic structures. 

\startCCode
static void parseSymbolWord(ContextObj *aCtx) {
  popCtxDataInto(aCtx, top);
  if (!isSymbolObj(top)) {
    raiseExceptionMsg(aCtx,
      "parse symbol expected a symbol as top");
    return;
  }
  parseString(aCtx, asSymbol(top));
}

static void parseFileWord(ContextObj *aCtx) {
  popCtxDataInto(aCtx, top);
  if (!isSymbolObj(top)) {
    raiseExceptionMsg(aCtx,
      "parse file expected a symbol as top");
    return;
  }
  parseFile(aCtx, asSymbol(top));
}

static void jPegChoiceContinueWord(ContextObj *aCtx) {
  popCtxDataInto(aCtx, top);
  
  // if top is the empty list we are done...
  if (!top) return;

  // if we have failed...
  // but are instructed to ignore the next failure... 
  // we FAIL the whole choise... BUT... we are done...
  if (asParserFailed(aCtx) && asParserIgnoreNextFailure(aCtx)) {
    asParserIgnoreNextFailure(aCtx) = false;
  }
  
  // if we have not failed... we are also done...
  if (!asParserFailed(aCtx)) {
    asParserFailed(aCtx) = false;
    return;
  }
  
  if (!isPairObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg choice parser expected a list as top");
    return;
  }
  popListInto(aCtx, top, firstChoice);
  pushSymbolCtxProcess(aCtx, "parseChoiceCont");
  pushCtxProcess(aCtx, top);
  prependListCtxProcess(aCtx, firstChoice);
  
  if (aCtx->process) {
    asParserFailed(aCtx) = false;
  }

}

static void jPegChoiceWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  asParserFailed(aCtx) = true;
  jPegChoiceContinueWord(aCtx);
}

static void jPegCommitWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  asParserIgnoreNextFailure(aCtx) = true;
}

static void jPegFailWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  asParserFailed(aCtx) = true;
  
  JObj *lastCommand = NULL;
  while(aCtx->process) {
    popCtxProcessInto(aCtx, aCommand);
    if (symbolIs(aCommand, "parseChoiceCont")) {
      pushSymbolCtxProcess(aCtx, "parseChoiceCont");
      pushCtxProcess(aCtx, lastCommand);
      return;
    }
    lastCommand = aCommand;
  }
}
\stopCCode

\startCHeader
void jPegAnyWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegAnyWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg any parser expected a UInteger as top");
    return;
  }
  
  size_t charsToMatch     = asUInteger(top);
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while (
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (0 < charsToMatch)
  ) {
    asParserTextPosition(aCtx)++;
    charsToMatch--;
  }
    
  if (0 < charsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }

}
\stopCCode

\startCHeader
void jPegPatternWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegPatternWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, top);
  if (!isSymbolObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg pattern parser expected a symbol as top");
    return;
  }
  
  Symbol *pattern         = asSymbol(top);
  size_t patternSize      = strlen(pattern);
  size_t charsMatched     = 0;
  size_t origTextPosition = asParserTextPosition(aCtx);
  Symbol *parserText      = asParserText(aCtx) + origTextPosition;

  // TODO: need to deal with UTF-8 multi-byte characters

  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (charsMatched < patternSize) &&
    (parserText[charsMatched] == pattern[charsMatched])
  ) {
    asParserTextPosition(aCtx)++;
    charsMatched++;
  }
  
  if (charsMatched != patternSize)  {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startCHeader
typedef struct parser_char_span {
  char firstChar;
  char lastChar;
} ParserCharSpan;

typedef struct parser_charSet_spans {
  Symbol         *charSet;
  size_t          charSetSize;
  ParserCharSpan *spans;
  size_t          numSpans;
  size_t          maxSpans;
} ParserCharSpans;

ParserCharSpans *collectJPegSpans(ContextObj *aCtx);
\stopCHeader

\startCCode
ParserCharSpans *collectJPegSpans(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *collectedSpans = 
    (ParserCharSpans*)calloc(1, sizeof(ParserCharSpans));
  collectedSpans->charSet     = NULL;
  collectedSpans->charSetSize = 0;
  collectedSpans->spans       = NULL;
  collectedSpans->numSpans    = 0;
  collectedSpans->maxSpans    = 0;
  
  popCtxDataInto(aCtx, someSpans);
  while (isPairObj(someSpans)) {
    JObj *firstSpan = asCar(someSpans);
    someSpans       = asCdr(someSpans);
    if (!isSymbolObj(firstSpan)) {
      raiseExceptionMsg(aCtx,
        "jPeg list of spans expected a symbol as next span");
      return collectedSpans; 
    }
    Symbol *spanSymbol     = asSymbol(firstSpan);
    size_t  spanSymbolSize = strlen(spanSymbol);
    switch(spanSymbolSize) {
      case 0 :
        // ignore this span
        break;
      case 2 :
        // create a new span item
        //
        if (collectedSpans->maxSpans <= collectedSpans->numSpans) {
          // need to increase the number of spans...
          ParserCharSpan *oldSpans = collectedSpans->spans;
          size_t newMaxSpans       = collectedSpans->maxSpans + 10;
          ParserCharSpan *newSpans =
            (ParserCharSpan*)calloc(newMaxSpans, sizeof(ParserCharSpan));
          assert(newSpans);
          if (oldSpans) {
            memcpy(
              newSpans,
              oldSpans,
              ((collectedSpans->maxSpans) * sizeof(ParserCharSpan))
            );
            free(oldSpans);
            oldSpans = NULL;
          }
          collectedSpans->spans    = newSpans;
          collectedSpans->maxSpans = newMaxSpans;
        }
        ParserCharSpan *newSpan =
          collectedSpans->spans + collectedSpans->numSpans;
        if (spanSymbol[0] <= spanSymbol[1]) {
          newSpan->firstChar = spanSymbol[0];
          newSpan->lastChar  = spanSymbol[1];
        } else {
          newSpan->firstChar = spanSymbol[1];
          newSpan->lastChar  = spanSymbol[0];
        }
        collectedSpans->numSpans++;
        break;
      default: {
        // append this span to the charSet
        //
        Symbol *oldCharSet = collectedSpans->charSet;
        collectedSpans->charSet =
          appendSymbols(oldCharSet, spanSymbol);
        free((char*)oldCharSet);
        collectedSpans->charSetSize = strlen(collectedSpans->charSet);
      }
    }
  }
  return collectedSpans;
}
\stopCCode

\startCHeader
Boolean matchCharSetSpans(ContextObj *aCtx, ParserCharSpans *spans);
\stopCHeader

\startCCode
Boolean matchCharSetSpans(ContextObj *aCtx, ParserCharSpans *spans) {
  assert(isContextObj(aCtx));
  
  if (!spans) return true;
  
  size_t numCurSpan  = spans->numSpans;
  Symbol *curCharPtr = asParserText(aCtx) + asParserTextPosition(aCtx);
  char curChar       = *curCharPtr;
  
  while (0 < numCurSpan) {
    ParserCharSpan *aSpan = spans->spans + numCurSpan - 1;
    if ((aSpan->firstChar <= curChar) && (curChar <= aSpan->lastChar)) {
      return true;
    } 
    numCurSpan--;
  }
  
  size_t curCharSetChar = spans->charSetSize;
  Symbol *charSet       = spans->charSet;
  
  while (0 < curCharSetChar) {
    if (curChar == charSet[curCharSetChar]) {
      return true;
    }
    curCharSetChar--;
  }
  
  return false;
}

static void deleteJPegSpans(ParserCharSpans *someSpans) {
  if (!someSpans) return;
  if (someSpans->charSet) free((char*)someSpans->charSet);
  if (someSpans->spans)   free(someSpans->spans);
  free(someSpans);
}
\stopCCode

\startCHeader
void jPegCharSetWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCharSetWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t charsToMatch     = asUInteger(top);
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (0 < charsToMatch) &&
    matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsToMatch--;
  }
  
  deleteJPegSpans(spans);

  if (0 < charsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startCHeader
void jPegCoCharSetWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCoCharSetWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t charsToMatch     = asUInteger(top);
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (0 < charsToMatch) &&
    !matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsToMatch--;
  }
  
  deleteJPegSpans(spans);

  if (0 < charsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startCHeader
void jPegSpanWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegSpanWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t minCharsToMatch  = asUInteger(top);
  size_t charsMatched     = 0;
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsMatched++;
  }
  
  deleteJPegSpans(spans);
 
  if (charsMatched < minCharsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startCHeader
void jPegCoSpanWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCoSpanWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t minCharsToMatch  = asUInteger(top);
  size_t charsMatched     = 0;
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    !matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsMatched++;
  }

  deleteJPegSpans(spans);

  if (charsMatched < minCharsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}

static void jPegRepeatWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  asParserIgnoreNextFailure(aCtx) = true;
  
  popCtxDataInto(aCtx, parser);
  
  pushSymbolCtxProcess(aCtx, "parseRepeat");
  pushCtxProcess(aCtx, parser);
  prependListCtxProcess(aCtx, copyLoL(parser));
}

static void jPegRepeatAtLeastWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  asParserIgnoreNextFailure(aCtx) = false;
  
  popCtxDataInto(aCtx, parser);
  popCtxDataInto(aCtx, atLeast);
  if (!isUIntegerObj(atLeast)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    return;
  }
  size_t atLeastRepeats = asUInteger(atLeast);
  if (0 < atLeastRepeats) {
    pushSymbolCtxProcess(aCtx, "parseRepeatAtLeast");
    pushUIntegerCtxProcess(aCtx, atLeastRepeats - 1);
  } else {
    pushSymbolCtxProcess(aCtx, "parseRepeat");
  }
  pushCtxProcess(aCtx, parser);
  prependListCtxProcess(aCtx, copyLoL(parser));
}

static void jPegRepeatAtMostWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  asParserIgnoreNextFailure(aCtx) = false;
  
  popCtxDataInto(aCtx, parser);
  popCtxDataInto(aCtx, atMost);
  if (!isUIntegerObj(atMost)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    return;
  }
  size_t atMostRepeats = asUInteger(atMost);
  if (0 < atMostRepeats) {
    asParserIgnoreNextFailure(aCtx) = true;
    pushSymbolCtxProcess(aCtx, "parseRepeatAtMost");
    pushUIntegerCtxProcess(aCtx, atMostRepeats - 1);
    pushCtxProcess(aCtx, parser);
  } else {
    pushSymbolCtxProcess(aCtx, "parseFail");
  }
  prependListCtxProcess(aCtx, copyLoL(parser));
}
\stopCCode

\startCHeader
void registerJPegWords(ContextObj *aCtx);
\stopCHeader

\startCCode
void registerJPegWords(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  SymbolTableObj *symTab = asCtxSymbols(aCtx);
  assert(isSymbolTableObj(symTab));
  
  registerCFunction(symTab, "parseSymbol",        parseSymbolWord);
  registerCFunction(symTab, "parseFile",          parseFileWord);
  registerCFunction(symTab, "parseChoice",        jPegChoiceWord);
  registerCFunction(symTab, "parseChoiceCont",    jPegChoiceContinueWord);
  registerCFunction(symTab, "parseCommit",        jPegCommitWord);
  registerCFunction(symTab, "parseFail",          jPegFailWord);
  registerCFunction(symTab, "parseAny",           jPegAnyWord);
  registerCFunction(symTab, "parsePattern",       jPegPatternWord);
  registerCFunction(symTab, "parseCharSet",       jPegCharSetWord);
  registerCFunction(symTab, "parseCoCharSet",     jPegCoCharSetWord);
  registerCFunction(symTab, "parseSpan",          jPegSpanWord);
  registerCFunction(symTab, "parseCoSpan",        jPegCoSpanWord);
  registerCFunction(symTab, "parseRepeat",        jPegRepeatWord);
  registerCFunction(symTab, "parseRepeatAtLeast", jPegRepeatAtLeastWord);
  registerCFunction(symTab, "parseRepeatAtMost",  jPegRepeatAtMostWord);
}
\stopCCode


\startTestSuite[parser]

\startTestCase[simple any and pattern parser tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);

  parseString(aCtx, "aaabbb");
  AssertIntZero(asParserTextPosition(aCtx));
  pushUIntegerCtxData(aCtx, 5);
  jPegAnyWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 5);
  asParserTextPosition(aCtx) = 0;
  pushSymbolCtxData(aCtx, "aaab");
  AssertIntZero(asParserTextPosition(aCtx));
  jPegPatternWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 4);
\stopCTest
\stopTestCase

\startTestCase[simple jPeg span tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushSymbolCtxData(aCtx, "AZ");
  pushSymbolCtxData(aCtx, "az");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "-test");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "space");
  prependWord(aCtx);
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  AssertPtrNotNull(spans);
  AssertStrEquals(spans->charSet, "space-test");
  AssertIntEquals(spans->charSetSize, 10);
  AssertPtrNotNull(spans->spans);
  AssertIntEquals(spans->numSpans, 2);
  AssertIntEquals(spans->maxSpans, 10);
  AssertIntEquals(spans->spans[0].firstChar, 'a');
  AssertIntEquals(spans->spans[0].lastChar,  'z');
  AssertIntEquals(spans->spans[1].firstChar, 'A');
  AssertIntEquals(spans->spans[1].lastChar,  'Z');
  
  parseString(aCtx, "WoRd 10-");
  AssertIntEquals(getParserCurChar(aCtx), 'W');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), 'o');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), 'R');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), 'd');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), ' ');
  AssertIntFalse(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), '1');
  AssertIntFalse(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), '0');
  AssertIntFalse(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), '-');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
\stopCTest
\stopTestCase

\startTestCase[charSet and span tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushSymbolCtxData(aCtx, "AZ");
  pushSymbolCtxData(aCtx, "az");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "-test");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "space");
  prependWord(aCtx);

  parseString(aCtx, "aaa-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 4);
  swap12DWord(aCtx);
  jPegCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 4);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 5);
  swap12DWord(aCtx);
  jPegCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  parseString(aCtx, "$%^-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 3);
  swap12DWord(aCtx);
  jPegCoCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 3);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));

  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 4);
  swap12DWord(aCtx);
  jPegCoCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));

  parseString(aCtx, "aaa-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 2);
  swap12DWord(aCtx);
  jPegSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 4);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 5);
  swap12DWord(aCtx);
  jPegSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  parseString(aCtx, "$%^-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 2);
  swap12DWord(aCtx);
  jPegCoSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 3);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));

  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 4);
  swap12DWord(aCtx);
  jPegCoSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
\stopCTest
\stopTestCase

\startTestCase[choice/fail/commit tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);

  // (
  //   ( fail 1 any 1 any)
  //   ( 1 any commit fail 1 any 1 any)
  //   ( 1 any)
  // ) choice

  pushSymbolCtxData(aCtx, "parseChoice");
  
  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  wrapWord(aCtx);
  
  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseFail");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseCommit");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  wrapWord(aCtx);
  
  prependWord(aCtx);
  
  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseFail");
  prependWord(aCtx);
  wrapWord(aCtx);
  
  prependWord(aCtx);
  wrapWord(aCtx);
  prependWord(aCtx);
//  showCtxData(aCtx);
\stopCTest
\stopTestCase

\startTestCase[repeating parsers]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
\stopCTest
\stopTestCase

\startTestCase[should ??]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  parseString(aCtx, "this is a test");

  // build the following parser on the data stack...
  // ( 
  //   (
  //     ((" " "\t" "\n") 0 parseSpan)
  //     (("az" "AZ") 0 parseSpan)
  //   ) parseChoice
  // ) parseRepeat

  aCtx->tracingOn = true;

  pushSymbolCtxData(aCtx, "parseRepeat");
  pushSymbolCtxData(aCtx, "parseChoice");
  pushSymbolCtxData(aCtx, "parseSpan");
  pushUIntegerCtxData(aCtx, 0);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "AZ");
  pushSymbolCtxData(aCtx, "az");
  prependWord(aCtx);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseSpan");
  pushUIntegerCtxData(aCtx, 0);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "\n");
  pushSymbolCtxData(aCtx, "\t");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, " ");
  prependWord(aCtx);
  prependWord(aCtx);
  prependWord(aCtx);
  wrapWord(aCtx);
  prependWord(aCtx);
  wrapWord(aCtx);
  prependWord(aCtx);
  
  // now evaluate it
//  evalCommandInContext(aCtx, asJObj(newSymbol("interpret", NULL, 0)));
  AssertIntFalse(asParserFailed(aCtx));
\stopCTest
\skipTestCase
\stopTestSuite