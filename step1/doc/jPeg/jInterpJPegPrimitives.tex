% A ConTeXt document [master document: ../jInterp.tex ]

\subsection[title=Primitives]

\TODO{At the moment we do NOT deal correctly with UTF-8 characters.... 
which we can and should.} 

We need to implement the following \joylol\ words:

\startitemize[1]

\item \bold{\type{Fail}} successively takes items off the process stack 
until it reaches a choice symbol. It then places the last list back on the 
process stack. 

\item \bold{\type{Commit}} takes no arguments, and ensures that the first 
subsequent failure is ignored.

\item \bold{\type{Choice}} takes a list of patterns and applies each in 
turn until one succeeds. It does this by taking the top item off the list 
and then placing, itself, the reduced list, and then prepends the top item 
onto the process stack. 

\item \bold{\type{Any}} takes one argument which is the number of 
characters to match. All characters will match. 

\item \bold{\type{Pattern}} takes one argument which is the explicit 
sequence of characters which should be matched. 

\item \bold{\type{CharSet}} Takes two arguments. The first argument should 
be a list of symbols which together make up the set of characters which 
can be matched once. The second argument is the number of characters which 
\emph{must} match characters in the character set. 

\item \bold{\type{coCharSet}} Takes two arguments. The first argument 
which like a \bold{\type{CharSet}}, should be a list of symbols which 
together make up the set of characters which \emph{should not} be matched, 
all characters which are \emph{not} in the character set \emph{will} be 
matched. The second argument is the number of characters which \emph{must} 
\emph{not} match characters in the character set.

\item \bold{\type{Span}} Takes two arguments. The top argument is the list 
of symbols from which to form the character set. The second argument is 
the minimum number of times that should be matched by this character set. 
A \bold{\type{span}} matches as many consecutive characters that are in 
the character set as possible. \bold{\type{Span}} will only fail if it can 
not match at least the specified minimum number of characters. 

\item \bold{\type{coSpan}} Like \bold{\type{Span}}, \bold{\type{coSpan}}, 
takes two arguments. The top argument is a list of symbols from which to 
form the character set. The second argument is the minimum number of times 
that should be matched by characters which are \emph{not} in this 
character set. A \bold{\type{coSpan}} matches as many consecutive 
characters that are \emph{not} in the character set as possible. 
\bold{\type{coSpan}} will only fail if it can not match at least the 
specified minimum number of characters. 

\item \bold{\type{RepeatAtLeast}} repeats the top pattern at least second 
argument times. 

\item \bold{\type{RepeatAtMost}} repeats the top pattern at most second 
argument times. 

\stopitemize 

\TODO{We have not covered \quote{\bold{\type{not}}}, 
\quote{\bold{\type{and}}}, CharSet difference, captures, or actions on 
captures.} 

As suggested in \cite{ierusalimschy2008lpegArticle} we might implement 
captures using a \type{Capture} call with three distinct arguments: 

\startitemize[n] 

\item \type{begin n} where the actual capture begins $n$ characters before 
the current character. This capture method should be called \emph{as soon 
as} it is known that the current path will succeed. 

\item \type{end} this marks the end of a capture 

\item \type{full n} this is the same as a \type{begin n} immediately 
followed by an \type{end}. 

\stopitemize 

For all of the above \joylol\ words, the data stack must include both the 
current text structure (which must include a indication of the current 
character) as well as the current collection of captures. 

A compiler is a pipeline of co-routines. The parser might itself be a 
pipeline of co-routines, one for the lexer, one for the ultimate parser, 
but there could be numerous intermediary co-routines parsing more complex 
syntactic structures. 

\startCCode
static void parseSymbolWord(ContextObj *aCtx) {
  popCtxDataInto(aCtx, top);
  if (!isSymbolObj(top)) {
    raiseExceptionMsg(aCtx,
      "parse symbol expected a symbol as top");
    return;
  }
  parseString(aCtx, asSymbol(top));
}

static void parseFileWord(ContextObj *aCtx) {
  popCtxDataInto(aCtx, top);
  if (!isSymbolObj(top)) {
    raiseExceptionMsg(aCtx,
      "parse file expected a symbol as top");
    return;
  }
  parseFile(aCtx, asSymbol(top));
}
\stopCCode

\subsection[title=Choice-point (and repetition) primitives]

One of the fundamental concepts in any Peg is \quote{localized} 
\quote{back-tracking} at \quote{choice} points. We implement this concept 
using the three primitive words: choice, commit, and fail. Equally 
important is the concept of repetition. While, as noted in 
\cite{ierusalimschy2008lpegArticle}, repetition can be implemented as a 
choice between a self-right-recursive parser and the empty string parser, 
we provide the three primitive words: repeat (indefinitely), 
repeatAtLeast, and repeatAtMost, in order to provide optimized versions of 
these heavily used constructs. 

As also noted in \cite{ierusalimschy2008lpegArticle}, choice back-tracking 
can be implemented as a form of try/raise/catch found in many modern 
imperative programming languages. In \joylol, we implement raise/catch as 
a pair of words which manipulate the process stack. A raise walks down the 
process stack removing any words which are not a catch word. We implement 
jPeg parser fail/catch in a similar way.

Since the parser fail word back-tracks to a choice word, our 
implementation of parser fail, must look for all of the words, choice, 
repeat, repeatAtLeast and repeatAtMost. The problem that this introduces 
is that each of these \quote{choice} words must keep \emph{different} 
\quote{choice point structures}. In each case these choice point 
structures should be kept on the process stack as they represent 
information required when the computation \quote{continues} to the 
\quote{rest} of the computation. 

We can keep these choice point structures on the process stack either 
\emph{above} or \emph{below} the choice words themselves. If we keep the 
choice structures above the choice words, then the fail word must know 
enough about these choice structures to be able to replace them so that 
the choice word can make use of the required choice structure. In order to 
keep the parser fail word as simple as possible, we keep the choice 
structures \emph{below} the choice words themselves. This in turn implies 
that for each choice-point word we actually require a \emph{pair} of 
words, one used by parser writers to specify a particular type of 
choice-point, and the other \quote{continuation} choice-point word to 
actually implement the continuation behaviour at a given choice-point. It 
is the continuation choice-point words that the parser fail word looks for 
on the process stack. It is also the continuation choice-point words which 
access and manipulate the choice structures each time the over all parser 
back-tracks to a choice-point in order to try a different choice. 

\startTestSuite[jPegCommitWord]

\startCHeader
void jPegCommitWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCommitWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  asParserCommitted(aCtx) = true;
}
\stopCCode

\startTestCase[should mark the parser are committed]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  //
  // commit changes the commit flag
  //
  AssertPtrNull(asCtxData(aCtx));
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegCommitWord(aCtx);
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNull(asCtxData(aCtx));
  AssertPtrNull(asCtxProcess(aCtx));
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegChoiceContinueWord]

\startCHeader
void jPegChoiceContinueWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegChoiceContinueWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxProcessInto(aCtx, parserChoices);
  popCtxProcessInto(aCtx, textBackTrackPointObj);
  
  // if we have not failed... we are done...
  if (!asParserFailed(aCtx)) {
    asParserCommitted(aCtx) = false;
    asParserFailed(aCtx)    = false;
    return;
  }

  if (!isUIntegerObj(textBackTrackPointObj)) {
    raiseExceptionMsg(aCtx,
      "jPeg choice parser expected a UInteger as text back-track point");
    return;
  }
  size_t textBackTrackPoint = asUInteger(textBackTrackPointObj);

  // if we have failed... but are committed... 
  // we FAIL the whole choice... BUT... we are done...
  if (asParserFailed(aCtx) && asParserCommitted(aCtx)) {
    asParserCommitted(aCtx)    = false;
    asParserTextPosition(aCtx) = textBackTrackPoint;
    pushSymbolCtxProcess(aCtx, "parseFail");
    return;
  }

  // if we have no choices left... we are done...
  // BUT we have actually failed...
  if (!parserChoices) {    // (i.e. the empty list)
    asParserCommitted(aCtx)    = false;
    asParserTextPosition(aCtx) = textBackTrackPoint;
    pushSymbolCtxProcess(aCtx, "parseFail");
    return;
  }

  if (!isPairObj(parserChoices)) {
    raiseExceptionMsg(aCtx,
      "jPeg choice parser expected a list as parser choices");
    return;
  }
  popListInto(aCtx, parserChoices, firstChoice);
  pushCtxProcess(aCtx, textBackTrackPointObj);
  pushCtxProcess(aCtx, parserChoices);
  pushSymbolCtxProcess(aCtx, "parseChoiceCont");
  prependListCtxProcess(aCtx, firstChoice);
  
  asParserFailed(aCtx) = false;
}
\stopCCode

We start by setting up the initial context for all of the subsequent test 
cases. 

\CTestsSuiteSetup\
\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  //
  // setup a "parser" for later use
  //
  pushUIntegerCtxData(aCtx, 44);
  pushUIntegerCtxData(aCtx, 43);
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 42);
  prependWord(aCtx);
\stopCTest

\startTestCase[should make no changes to either data or process stacks 
when not failed] 

\startCTest
  // not failed
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  
  jPegChoiceContinueWord(aCtx);
  
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));
\stopCTest
\stopTestCase

\startTestCase[should continue with parseFail when there are no more 
choices] 

\startCTest
  // build an empty parser
  //
  pushUIntegerCtxProcess(aCtx, 42);
  pushNullCtxProcess(aCtx);

  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 2);
  AssertIntFalse(asParserCommitted(aCtx));
  asParserFailed(aCtx) = true;
  AssertIntTrue(asParserFailed(aCtx));
  asParserTextPosition(aCtx) = 0;
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  
  jPegChoiceContinueWord(aCtx);
  
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntEquals(asParserTextPosition(aCtx), 42);
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 1);
  AssertIntTrue(isSymbolObj(asCar(asCtxProcess(aCtx))));
  AssertStrEquals(asSymbol(asCar(asCtxProcess(aCtx))), "parseFail");  
\stopCTest
\stopTestCase

\startTestCase[should continue with parseFail when failed but committed] 

\startCTest
  asCtxProcess(aCtx) = NULL;
  
  pushUIntegerCtxProcess(aCtx, 24);
  dup1DWord(aCtx);
  popCtxDataInto(aCtx, parser);
  pushCtxProcess(aCtx, parser);
  
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  asParserFailed(aCtx)       = true;
  asParserCommitted(aCtx)    = true;
  asParserTextPosition(aCtx) = 0;
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  
  jPegChoiceContinueWord(aCtx);
  
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 1);
  AssertIntTrue(isSymbolObj(asCar(asCtxProcess(aCtx))));
  AssertStrEquals(asSymbol(asCar(asCtxProcess(aCtx))), "parseFail");
  AssertIntEquals(asParserTextPosition(aCtx), 24);
\stopCTest
\stopTestCase

\startTestCase[should try the next choice when failed, not committed and 
there are more choices]

\startCTest
  asCtxProcess(aCtx) = NULL;
  
  pushUIntegerCtxProcess(aCtx, 24);
  dup1DWord(aCtx);
  popCtxDataInto(aCtx, parser);
  pushCtxProcess(aCtx, parser);
  
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  asParserFailed(aCtx)       = true ;
  asParserCommitted(aCtx)    = false;
  asParserTextPosition(aCtx) = 0;
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 2);
  
  jPegChoiceContinueWord(aCtx); 
  
  AssertIntFalse(asParserCommitted(aCtx)); 
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx)); 
  AssertIntEquals(listLength(asCtxData(aCtx)), 1); 
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 4);
  
  popCtxProcessInto(aCtx, top);
  popCtxProcessInto(aCtx, second);
  popCtxProcessInto(aCtx, third);
  popCtxProcessInto(aCtx, fourth);
  
  AssertIntTrue(isUIntegerObj(top));
  AssertIntEquals(asUInteger(top), 42);    

  AssertIntTrue(isSymbolObj(second));
  AssertStrEquals(asSymbol(second), "parseChoiceCont");
  
  AssertIntTrue(isPairObj(third));
  AssertIntTrue(isUIntegerObj(asCar(third)));
  AssertIntEquals(asUInteger(asCar(third)), 43);
  
  AssertIntTrue(isPairObj(asCdr(third)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(third))));
  AssertIntEquals(asUInteger(asCar(asCdr(third))), 44);
  
  AssertPtrNull(asCdr(asCdr(third)));
  
  AssertIntTrue(isUIntegerObj(fourth));
  AssertIntEquals(asUInteger(fourth), 24);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegChoiceWord]

\startCHeader
void jPegChoiceWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegChoiceWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  popCtxDataInto(aCtx, parserChoices);
  if (!isPairObj(parserChoices)) {
    raiseExceptionMsg(aCtx,
      "jPeg choice parser expected a list as parser choices");
    return;
  }
  
  asParserFailed(aCtx) = true;
  
  pushUIntegerCtxProcess(aCtx, asParserTextPosition(aCtx));
  pushCtxProcess(aCtx, parserChoices);
  jPegChoiceContinueWord(aCtx);
}
\stopCCode

\startTestCase[should setup jPegChoiceCont]
\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  //
  // setup a "parser" for later use
  //
  pushUIntegerCtxData(aCtx, 44);
  pushUIntegerCtxData(aCtx, 43);
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 42);
  prependWord(aCtx);
  
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  asParserCommitted(aCtx) = false;
  asParserFailed(aCtx)    = false;
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNull(asCtxProcess(aCtx));
  
  jPegChoiceWord(aCtx);
  
  AssertPtrNull(asCtxData(aCtx));
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 4);
  
  popCtxProcessInto(aCtx, top);
  popCtxProcessInto(aCtx, second);
  popCtxProcessInto(aCtx, third);
  popCtxProcessInto(aCtx, fourth);
  
  AssertIntTrue(isUIntegerObj(top));
  AssertIntEquals(asUInteger(top), 42);    

  AssertIntTrue(isSymbolObj(second));
  AssertStrEquals(asSymbol(second), "parseChoiceCont");
  
  AssertIntTrue(isPairObj(third));
  AssertIntTrue(isUIntegerObj(asCar(third)));
  AssertIntEquals(asUInteger(asCar(third)), 43);
  
  AssertIntTrue(isPairObj(asCdr(third)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(third))));
  AssertIntEquals(asUInteger(asCar(asCdr(third))), 44);
  
  AssertPtrNull(asCdr(asCdr(third)));
  
  AssertIntTrue(isUIntegerObj(fourth));
  AssertIntEquals(asUInteger(fourth), 0);
\stopCTest
\stopTestCase
\stopTestSuite

The \bold{\type{parseRepeat}*} words are each optimized variants of 
choice. As such they each need to deal with parsers being commited and or 
failed. 

\startTestSuite[jPegRepeatContinueWord]

\startCHeader
void jPegRepeatContinueWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegRepeatContinueWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, textBackTrackPointObj);
  
  // we always ignore and reset committed-ness
  asParserCommitted(aCtx) = false;

  // if we have failed...
  // we roll back the last repeat and then...
  // we SUCCEED and are done...
  if (asParserFailed(aCtx)) {
  
    if (!isUIntegerObj(textBackTrackPointObj)) {
      raiseExceptionMsg(aCtx,
        "jPeg repeat parser expected a UInteger as text back-track point");
      return;
    }
    size_t textBackTrackPoint = asUInteger(textBackTrackPointObj);
    asParserTextPosition(aCtx) = textBackTrackPoint;
    
    asParserFailed(aCtx) = false;
    
    return;
  }
  
  // we have not failed... so we try another repeat...
  
  // if the parser is empty... there is nothing to do...
  if (!parser) return;

  pushUIntegerCtxProcess(aCtx, asParserTextPosition(aCtx));
  pushCtxProcess(aCtx, parser);
  pushSymbolCtxProcess(aCtx, "parseRepeatCont");
  prependListCtxProcess(aCtx, copyLoL(parser));
}
\stopCCode

\CTestsSuiteSetup\
\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushUIntegerCtxData(aCtx, 43);
  pushUIntegerCtxData(aCtx, 42);
  prependWord(aCtx);
\stopCTest

\startTestCase[should restore last back-track point and succeed when last 
repeat failed] 

\startCTest
  pushUIntegerCtxProcess(aCtx, 24);
  dup1DWord(aCtx);
  popCtxDataInto(aCtx, parser);
  pushCtxProcess(aCtx, parser);
  
  asParserTextPosition(aCtx) = 0;
  asParserCommitted(aCtx)    = true;
  asParserFailed(aCtx)       = true;
  
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 2);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  
  jPegRepeatContinueWord(aCtx);
  
  AssertIntEquals(asParserTextPosition(aCtx), 24);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));
\stopCTest
\stopTestCase

\startTestCase[should setup repetition on process stack when last repeat 
succeeded] 

\startCTest
  pushUIntegerCtxProcess(aCtx, 0);
  dup1DWord(aCtx);
  popCtxDataInto(aCtx, parser);
  pushCtxProcess(aCtx, parser);
  
  asParserTextPosition(aCtx) = 24;
  asParserCommitted(aCtx)    = true;
  asParserFailed(aCtx)       = false;
  
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 2);
  
  AssertIntEquals(asParserTextPosition(aCtx), 24);
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  
  jPegRepeatContinueWord(aCtx);
  
  AssertIntEquals(asParserTextPosition(aCtx), 24);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 5);
    
  popCtxProcessInto(aCtx, top42);
  popCtxProcessInto(aCtx, top43);
  popCtxProcessInto(aCtx, repeatWord);
  popCtxProcessInto(aCtx, repeatParser);
  popCtxProcessInto(aCtx, backTrackPoint);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseRepeatCont");
  
  AssertIntTrue(isPairObj(repeatParser));
  AssertIntTrue(isUIntegerObj(asCar(repeatParser)));
  AssertIntEquals(asUInteger(asCar(repeatParser)), 42);
  
  AssertIntTrue(isPairObj(asCdr(repeatParser)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(repeatParser))));
  AssertIntEquals(asUInteger(asCar(asCdr(repeatParser))), 43);
  
  AssertPtrNull(asCdr(asCdr(repeatParser)));
  
  AssertIntTrue(isUIntegerObj(top42));
  AssertIntEquals(asUInteger(top42), 42);  

  AssertIntTrue(isUIntegerObj(top43));
  AssertIntEquals(asUInteger(top43), 43);
  
  AssertIntTrue(isUIntegerObj(backTrackPoint));
  AssertIntEquals(asUInteger(backTrackPoint), 24);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegRepeatWord]

\startCHeader
void jPegRepeatWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegRepeatWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, parser);
  if (!parser) return; 
  
  asParserCommitted(aCtx) = false;
  asParserFailed(aCtx)    = false;
  pushUIntegerCtxProcess(aCtx, asParserTextPosition(aCtx));
  pushCtxProcess(aCtx, parser);
  jPegRepeatContinueWord(aCtx);
}
\stopCCode

\startTestCase[should setup repetition on process stack when last repeat 
succeeded] 

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushUIntegerCtxData(aCtx, 43);
  pushUIntegerCtxData(aCtx, 42);
  prependWord(aCtx);
  dup1DWord(aCtx);
  
  asParserTextPosition(aCtx) = 24;
  asParserCommitted(aCtx)    = true;
  asParserFailed(aCtx)       = false;
  
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 2);
  AssertPtrNull(asCtxProcess(aCtx));
  
  AssertIntEquals(asParserTextPosition(aCtx), 24);
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  
  jPegRepeatWord(aCtx);
  
  AssertIntEquals(asParserTextPosition(aCtx), 24);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 5);
    
  popCtxProcessInto(aCtx, top42);
  popCtxProcessInto(aCtx, top43);
  popCtxProcessInto(aCtx, repeatWord);
  popCtxProcessInto(aCtx, repeatParser);
  popCtxProcessInto(aCtx, backTrackPoint);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseRepeatCont");
  
  AssertIntTrue(isPairObj(repeatParser));
  AssertIntTrue(isUIntegerObj(asCar(repeatParser)));
  AssertIntEquals(asUInteger(asCar(repeatParser)), 42);
  
  AssertIntTrue(isPairObj(asCdr(repeatParser)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(repeatParser))));
  AssertIntEquals(asUInteger(asCar(asCdr(repeatParser))), 43);
  
  AssertPtrNull(asCdr(asCdr(repeatParser)));
  
  AssertIntTrue(isUIntegerObj(top42));
  AssertIntEquals(asUInteger(top42), 42);  

  AssertIntTrue(isUIntegerObj(top43));
  AssertIntEquals(asUInteger(top43), 43);
  
  AssertIntTrue(isUIntegerObj(backTrackPoint));
  AssertIntEquals(asUInteger(backTrackPoint), 24);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegRepeatAtLeastWord]

\startCHeader
void jPegRepeatAtLeastWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegRepeatAtLeastWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, parser);

  popCtxDataInto(aCtx, atLeast);
  if (!isUIntegerObj(atLeast)) {
    raiseExceptionMsg(aCtx,
      "jPeg repeatAtLeast parser expected a UInteger as top");
    return;
  }
  size_t atLeastRepeats = asUInteger(atLeast);
  
  // we always ignore and reset committed-ness
  asParserCommitted(aCtx) = false;

  // if the parser is empty... there is nothing to do
  if (!parser) return;
  
  // if we have failed...
  if (asParserFailed(aCtx)) {
    //
    // we roll back the last repeat...
    // the last checkpoint SHOULD have been
    // stored on the process stack
    
    // now we check to see if we have repeated enough times...
    if (0 < atLeastRepeats) {
      pushSymbolCtxProcess(aCtx, "parseFail");
    } else {
      asParserFailed(aCtx) = false;
    }
    
    // now we return without starting another repeat
    return;
  }
  
  // we have succeeded.... so we setup the next repeat...
  if (0 < atLeastRepeats) {
    pushSymbolCtxProcess(aCtx, "parseRepeatAtLeast");
    pushUIntegerCtxProcess(aCtx, atLeastRepeats - 1);
  } else {
    pushSymbolCtxProcess(aCtx, "parseRepeat");
  }
  pushCtxProcess(aCtx, parser);
  prependListCtxProcess(aCtx, copyLoL(parser));
}
\stopCCode

\startTestCase[test repeat at least parsers]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushUIntegerCtxData(aCtx, 43);
  pushUIntegerCtxData(aCtx, 42);
  prependWord(aCtx);

  // failed and 0 == atLeast
  //
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 0);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = true;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  jPegRepeatAtLeastWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));

  // failed and 0 < atLeast
  //
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 10);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = true;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  jPegRepeatAtLeastWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 1);
  AssertIntTrue(isSymbolObj(asCar(asCtxProcess(aCtx))));
  AssertStrEquals(asSymbol(asCar(asCtxProcess(aCtx))), "parseFail");

  // succeeded and 0 == atLeast
  //
  {
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 0);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = false;
  asCtxProcess(aCtx) = NULL;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegRepeatAtLeastWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 4);
    
  popCtxProcessInto(aCtx, top42);
  popCtxProcessInto(aCtx, top43);
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, repeatWord);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseRepeat");
  
  AssertIntTrue(isPairObj(parser));
  AssertIntTrue(isUIntegerObj(asCar(parser)));
  AssertIntEquals(asUInteger(asCar(parser)), 42);
  
  AssertIntTrue(isPairObj(asCdr(parser)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(parser))));
  AssertIntEquals(asUInteger(asCar(asCdr(parser))), 43);
  
  AssertPtrNull(asCdr(asCdr(parser)));
  
  AssertIntTrue(isUIntegerObj(top42));
  AssertIntEquals(asUInteger(top42), 42);  

  AssertIntTrue(isUIntegerObj(top43));
  AssertIntEquals(asUInteger(top43), 43);  
  }
  
  // succeeded and 0 < atLeast
  //
  {
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 10);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = false;
  asCtxProcess(aCtx) = NULL;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegRepeatAtLeastWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 5);
  
  popCtxProcessInto(aCtx, top42);
  popCtxProcessInto(aCtx, top43);
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, atLeast);
  popCtxProcessInto(aCtx, repeatWord);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseRepeatAtLeast");
  
  AssertIntTrue(isUIntegerObj(atLeast));
  AssertIntEquals(asUInteger(atLeast), 9);
  
  AssertIntTrue(isPairObj(parser));
  AssertIntTrue(isUIntegerObj(asCar(parser)));
  AssertIntEquals(asUInteger(asCar(parser)), 42);
  
  AssertIntTrue(isPairObj(asCdr(parser)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(parser))));
  AssertIntEquals(asUInteger(asCar(asCdr(parser))), 43);
  
  AssertPtrNull(asCdr(asCdr(parser)));
  
  AssertIntTrue(isUIntegerObj(top42));
  AssertIntEquals(asUInteger(top42), 42);  

  AssertIntTrue(isUIntegerObj(top43));
  AssertIntEquals(asUInteger(top43), 43);  
  }
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegRepeatAtMostWord]

\startCHeader
void jPegRepeatAtMostWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegRepeatAtMostWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  popCtxDataInto(aCtx, parser);

  popCtxDataInto(aCtx, atMost);
  if (!isUIntegerObj(atMost)) {
    raiseExceptionMsg(aCtx,
      "jPeg repeatAtMost parser expected a UInteger as top");
    return;
  }
  size_t atMostRepeats = asUInteger(atMost);

  // we always ignore and reset committed-ness
  asParserCommitted(aCtx) = false;

  // if the parser is empty... then we are done...
  if (!parser) return;

  // if we have failed...
  if (asParserFailed(aCtx)) {
    //
    // we roll back the last repeat...
    // the last checkpoint SHOULD have been
    // stored on the process stack
    
    // now we check to see if we have repeated enough times...
     if (0 == atMostRepeats) {
       pushSymbolCtxProcess(aCtx, "parseFail");
     } else {
      asParserFailed(aCtx) = false;
     }
    
    // now we return without starting another repeat
    return;
  }
  
  // we have succeeded.... so we setup the next repeat...
  if (0 < atMostRepeats) {
    pushSymbolCtxProcess(aCtx, "parseRepeatAtMost");
    pushUIntegerCtxProcess(aCtx, atMostRepeats - 1);
    pushCtxProcess(aCtx, parser);
    prependListCtxProcess(aCtx, copyLoL(parser));
  } else {
    pushSymbolCtxProcess(aCtx, "parseFail");
  }
}
\stopCCode
\startTestCase[test repeat at most parsers]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushUIntegerCtxData(aCtx, 43);
  pushUIntegerCtxData(aCtx, 42);
  prependWord(aCtx);

  // failed and 0 < atMost
  //
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 10);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = true;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  jPegRepeatAtMostWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));

  // failed and 0 == atMost
  //
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 0);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = true;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  jPegRepeatAtMostWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 1);
  AssertIntTrue(isSymbolObj(asCar(asCtxProcess(aCtx))));
  AssertStrEquals(asSymbol(asCar(asCtxProcess(aCtx))), "parseFail");

  // succeeded and 0 < atMost 
  //
  {
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 10);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = false;
  asCtxProcess(aCtx) = NULL;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegRepeatAtMostWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 5);
    
  popCtxProcessInto(aCtx, top42);
  popCtxProcessInto(aCtx, top43);
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, atMost);
  popCtxProcessInto(aCtx, repeatWord);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseRepeatAtMost");
  
  AssertIntTrue(isUIntegerObj(atMost));
  AssertIntEquals(asUInteger(atMost), 9);
  
  AssertIntTrue(isPairObj(parser));
  AssertIntTrue(isUIntegerObj(asCar(parser)));
  AssertIntEquals(asUInteger(asCar(parser)), 42);
  
  AssertIntTrue(isPairObj(asCdr(parser)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(parser))));
  AssertIntEquals(asUInteger(asCar(asCdr(parser))), 43);
  
  AssertPtrNull(asCdr(asCdr(parser)));
  
  AssertIntTrue(isUIntegerObj(top42));
  AssertIntEquals(asUInteger(top42), 42);  

  AssertIntTrue(isUIntegerObj(top43));
  AssertIntEquals(asUInteger(top43), 43);
  }

  // succeeded and 0 == atMost 
  //
  {
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 0);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = false;
  asCtxProcess(aCtx) = NULL;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegRepeatAtMostWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 1);
    
  popCtxProcessInto(aCtx, repeatWord);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseFail");
  }
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegFailWord]

\startCHeader
void jPegFailWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegFailWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  asParserFailed(aCtx) = true;
  
  JObj *lastCommand = NULL;
  while(aCtx->process) {
    popCtxProcessInto(aCtx, aCommand);
    if (
      symbolIs(aCommand, "parseChoiceCont") ||
      symbolStartsWith(aCommand, "parseRepeat")
    ) {
      pushCtxProcess(aCtx, aCommand);
      pushCtxProcess(aCtx, lastCommand);
      return;
    }
    lastCommand = aCommand;
  }
}
\stopCCode

\startTestCase[a simple fail with choice/repeat words]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);  

  // no choice or repeat words
  //
  {
  dup1DWord(aCtx);
  popCtxDataInto(aCtx, noWordTest);
  pushSymbolCtxProcess(aCtx, "someWord");
  pushCtxProcess(aCtx, noWordTest);
  prependListCtxProcess(aCtx, copyLoL(noWordTest));
  asParserCommitted(aCtx) = false;
  asParserFailed(aCtx) = false;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 6);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegFailWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));
  }
  
  // choice 
  //
  {
  dup1DWord(aCtx);
  popCtxDataInto(aCtx, choiceTest);
  pushSymbolCtxProcess(aCtx, "parseChoiceCont");
  pushCtxProcess(aCtx, choiceTest);
  prependListCtxProcess(aCtx, copyLoL(choiceTest));
  asParserCommitted(aCtx) = false;
  asParserFailed(aCtx) = false;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 6);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegFailWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 2);
  
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, parserWord);
  
  AssertIntTrue(isSymbolObj(parserWord));
  AssertStrEquals(asSymbol(parserWord), "parseChoiceCont");
  
  AssertIntTrue(isPairObj(parser));
  AssertIntEquals(listLength(parser), 4);
  AssertIntTrue(isSymbolObj(asCar(asCdr(parser))));
  AssertStrEquals(asSymbol(asCar(asCdr(parser))), "parseAny");
  }

  // repeat words
  //
  {
  dup1DWord(aCtx);
  popCtxDataInto(aCtx, repeatTest);
  pushSymbolCtxProcess(aCtx, "parseRepeatAtLeast");
  pushCtxProcess(aCtx, repeatTest);
  prependListCtxProcess(aCtx, copyLoL(repeatTest));
  asParserCommitted(aCtx) = false;
  asParserFailed(aCtx) = false;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 6);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegFailWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 2);
  
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, parserWord);
  
  AssertIntTrue(isSymbolObj(parserWord));
  AssertStrEquals(asSymbol(parserWord), "parseRepeatAtLeast");
  
  AssertIntTrue(isPairObj(parser));
  AssertIntEquals(listLength(parser), 4);
  AssertIntTrue(isSymbolObj(asCar(asCdr(parser))));
  AssertStrEquals(asSymbol(asCar(asCdr(parser))), "parseAny");
  }

//  showCtxData(aCtx);
//  showCtxProcess(aCtx);

\stopCTest
\stopTestCase

\startTestCase[a complex choice/fail/commit tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);

  // (
  //   ( fail 1 any 1 any)
  //   ( 1 any commit fail 1 any 1 any)
  //   ( 1 any)
  // ) choice

  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  wrapWord(aCtx);
  
  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseFail");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseCommit");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  wrapWord(aCtx);
  
  prependWord(aCtx);
  
  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseFail");
  prependWord(aCtx);
  wrapWord(aCtx);
  
  prependWord(aCtx);
  wrapWord(aCtx);
  dup1DWord(aCtx);
  
  pushSymbolCtxData(aCtx, "parseChoice");
  swap12DWord(aCtx);
  prependWord(aCtx);
  
//  showCtxData(aCtx);
\stopCTest
\stopTestCase
\stopTestSuite

\subsection[title=Simple pattern primitives]

\startTestSuite[jPegAnyWord and jPegPatternWord]

\startCHeader
void jPegAnyWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegAnyWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg any parser expected a UInteger as top");
    return;
  }
  
  size_t charsToMatch     = asUInteger(top);
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while (
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (0 < charsToMatch)
  ) {
    asParserTextPosition(aCtx)++;
    charsToMatch--;
  }
    
  if (0 < charsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }

}
\stopCCode

\startCHeader
void jPegPatternWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegPatternWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, top);
  if (!isSymbolObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg pattern parser expected a symbol as top");
    return;
  }
  
  Symbol *pattern         = asSymbol(top);
  size_t patternSize      = strlen(pattern);
  size_t charsMatched     = 0;
  size_t origTextPosition = asParserTextPosition(aCtx);
  Symbol *parserText      = asParserText(aCtx) + origTextPosition;

  // TODO: need to deal with UTF-8 multi-byte characters

  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (charsMatched < patternSize) &&
    (parserText[charsMatched] == pattern[charsMatched])
  ) {
    asParserTextPosition(aCtx)++;
    charsMatched++;
  }
  
  if (charsMatched != patternSize)  {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startTestCase[simple any and pattern parser tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);

  parseString(aCtx, "aaabbb");
  AssertIntZero(asParserTextPosition(aCtx));
  pushUIntegerCtxData(aCtx, 5);
  jPegAnyWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 5);
  asParserTextPosition(aCtx) = 0;
  pushSymbolCtxData(aCtx, "aaab");
  AssertIntZero(asParserTextPosition(aCtx));
  jPegPatternWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 4);
\stopCTest
\stopTestCase
\stopTestSuite


\startTestSuite[collectJPegSpans and matchCharSetSpans]

\startCHeader
typedef struct parser_char_span {
  char firstChar;
  char lastChar;
} ParserCharSpan;

typedef struct parser_charSet_spans {
  Symbol         *charSet;
  size_t          charSetSize;
  ParserCharSpan *spans;
  size_t          numSpans;
  size_t          maxSpans;
} ParserCharSpans;

ParserCharSpans *collectJPegSpans(ContextObj *aCtx);
\stopCHeader

\startCCode
ParserCharSpans *collectJPegSpans(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *collectedSpans = 
    (ParserCharSpans*)calloc(1, sizeof(ParserCharSpans));
  collectedSpans->charSet     = NULL;
  collectedSpans->charSetSize = 0;
  collectedSpans->spans       = NULL;
  collectedSpans->numSpans    = 0;
  collectedSpans->maxSpans    = 0;
  
  popCtxDataInto(aCtx, someSpans);
  while (isPairObj(someSpans)) {
    JObj *firstSpan = asCar(someSpans);
    someSpans       = asCdr(someSpans);
    if (!isSymbolObj(firstSpan)) {
      raiseExceptionMsg(aCtx,
        "jPeg list of spans expected a symbol as next span");
      return collectedSpans; 
    }
    Symbol *spanSymbol     = asSymbol(firstSpan);
    size_t  spanSymbolSize = strlen(spanSymbol);
    switch(spanSymbolSize) {
      case 0 :
        // ignore this span
        break;
      case 2 :
        // create a new span item
        //
        if (collectedSpans->maxSpans <= collectedSpans->numSpans) {
          // need to increase the number of spans...
          ParserCharSpan *oldSpans = collectedSpans->spans;
          size_t newMaxSpans       = collectedSpans->maxSpans + 10;
          ParserCharSpan *newSpans =
            (ParserCharSpan*)calloc(newMaxSpans, sizeof(ParserCharSpan));
          assert(newSpans);
          if (oldSpans) {
            memcpy(
              newSpans,
              oldSpans,
              ((collectedSpans->maxSpans) * sizeof(ParserCharSpan))
            );
            free(oldSpans);
            oldSpans = NULL;
          }
          collectedSpans->spans    = newSpans;
          collectedSpans->maxSpans = newMaxSpans;
        }
        ParserCharSpan *newSpan =
          collectedSpans->spans + collectedSpans->numSpans;
        if (spanSymbol[0] <= spanSymbol[1]) {
          newSpan->firstChar = spanSymbol[0];
          newSpan->lastChar  = spanSymbol[1];
        } else {
          newSpan->firstChar = spanSymbol[1];
          newSpan->lastChar  = spanSymbol[0];
        }
        collectedSpans->numSpans++;
        break;
      default: {
        // append this span to the charSet
        //
        Symbol *oldCharSet = collectedSpans->charSet;
        collectedSpans->charSet =
          appendSymbols(oldCharSet, spanSymbol);
        free((char*)oldCharSet);
        collectedSpans->charSetSize = strlen(collectedSpans->charSet);
      }
    }
  }
  return collectedSpans;
}
\stopCCode

\startCHeader
Boolean matchCharSetSpans(ContextObj *aCtx, ParserCharSpans *spans);
\stopCHeader

\startCCode
Boolean matchCharSetSpans(ContextObj *aCtx, ParserCharSpans *spans) {
  assert(isContextObj(aCtx));
  
  if (!spans) return true;
  
  size_t numCurSpan  = spans->numSpans;
  Symbol *curCharPtr = asParserText(aCtx) + asParserTextPosition(aCtx);
  char curChar       = *curCharPtr;
  
  while (0 < numCurSpan) {
    ParserCharSpan *aSpan = spans->spans + numCurSpan - 1;
    if ((aSpan->firstChar <= curChar) && (curChar <= aSpan->lastChar)) {
      return true;
    } 
    numCurSpan--;
  }
  
  size_t curCharSetChar = spans->charSetSize;
  Symbol *charSet       = spans->charSet;
  
  while (0 < curCharSetChar) {
    if (curChar == charSet[curCharSetChar]) {
      return true;
    }
    curCharSetChar--;
  }
  
  return false;
}

static void deleteJPegSpans(ParserCharSpans *someSpans) {
  if (!someSpans) return;
  if (someSpans->charSet) free((char*)someSpans->charSet);
  if (someSpans->spans)   free(someSpans->spans);
  free(someSpans);
}
\stopCCode

\startTestCase[simple jPeg span tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushSymbolCtxData(aCtx, "AZ");
  pushSymbolCtxData(aCtx, "az");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "-test");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "space");
  prependWord(aCtx);
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  AssertPtrNotNull(spans);
  AssertStrEquals(spans->charSet, "space-test");
  AssertIntEquals(spans->charSetSize, 10);
  AssertPtrNotNull(spans->spans);
  AssertIntEquals(spans->numSpans, 2);
  AssertIntEquals(spans->maxSpans, 10);
  AssertIntEquals(spans->spans[0].firstChar, 'a');
  AssertIntEquals(spans->spans[0].lastChar,  'z');
  AssertIntEquals(spans->spans[1].firstChar, 'A');
  AssertIntEquals(spans->spans[1].lastChar,  'Z');
  
  parseString(aCtx, "WoRd 10-");
  AssertIntEquals(getParserCurChar(aCtx), 'W');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), 'o');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), 'R');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), 'd');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), ' ');
  AssertIntFalse(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), '1');
  AssertIntFalse(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), '0');
  AssertIntFalse(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), '-');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegCharSetWords and jPegSpanWords]

\startCHeader
void jPegCharSetWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCharSetWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t charsToMatch     = asUInteger(top);
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (0 < charsToMatch) &&
    matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsToMatch--;
  }
  
  deleteJPegSpans(spans);

  if (0 < charsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startCHeader
void jPegCoCharSetWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCoCharSetWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t charsToMatch     = asUInteger(top);
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (0 < charsToMatch) &&
    !matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsToMatch--;
  }
  
  deleteJPegSpans(spans);

  if (0 < charsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startCHeader
void jPegSpanWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegSpanWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t minCharsToMatch  = asUInteger(top);
  size_t charsMatched     = 0;
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsMatched++;
  }
  
  deleteJPegSpans(spans);
 
  if (charsMatched < minCharsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startCHeader
void jPegCoSpanWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCoSpanWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t minCharsToMatch  = asUInteger(top);
  size_t charsMatched     = 0;
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    !matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsMatched++;
  }

  deleteJPegSpans(spans);

  if (charsMatched < minCharsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startTestCase[charSet and span tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushSymbolCtxData(aCtx, "AZ");
  pushSymbolCtxData(aCtx, "az");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "-test");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "space");
  prependWord(aCtx);

  parseString(aCtx, "aaa-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 4);
  swap12DWord(aCtx);
  jPegCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 4);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 5);
  swap12DWord(aCtx);
  jPegCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  parseString(aCtx, "$%^-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 3);
  swap12DWord(aCtx);
  jPegCoCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 3);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));

  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 4);
  swap12DWord(aCtx);
  jPegCoCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));

  parseString(aCtx, "aaa-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 2);
  swap12DWord(aCtx);
  jPegSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 4);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 5);
  swap12DWord(aCtx);
  jPegSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  parseString(aCtx, "$%^-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 2);
  swap12DWord(aCtx);
  jPegCoSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 3);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));

  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 4);
  swap12DWord(aCtx);
  jPegCoSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
\stopCTest
\stopTestCase
\stopTestSuite

\startCHeader
void registerJPegWords(ContextObj *aCtx);
\stopCHeader

\startCCode
void registerJPegWords(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  SymbolTableObj *symTab = asCtxSymbols(aCtx);
  assert(isSymbolTableObj(symTab));
  
  registerCFunction(symTab, "parseSymbol",        parseSymbolWord);
  registerCFunction(symTab, "parseFile",          parseFileWord);
  registerCFunction(symTab, "parseChoice",        jPegChoiceWord);
  registerCFunction(symTab, "parseChoiceCont",    jPegChoiceContinueWord);
  registerCFunction(symTab, "parseCommit",        jPegCommitWord);
  registerCFunction(symTab, "parseFail",          jPegFailWord);
  registerCFunction(symTab, "parseAny",           jPegAnyWord);
  registerCFunction(symTab, "parsePattern",       jPegPatternWord);
  registerCFunction(symTab, "parseCharSet",       jPegCharSetWord);
  registerCFunction(symTab, "parseCoCharSet",     jPegCoCharSetWord);
  registerCFunction(symTab, "parseSpan",          jPegSpanWord);
  registerCFunction(symTab, "parseCoSpan",        jPegCoSpanWord);
  registerCFunction(symTab, "parseRepeat",        jPegRepeatWord);
  registerCFunction(symTab, "parseRepeatAtLeast", jPegRepeatAtLeastWord);
  registerCFunction(symTab, "parseRepeatAtMost",  jPegRepeatAtMostWord);
}
\stopCCode

\subsection[title=jPeg parsing examples]

\startTestSuite[general parser tests]

\startTestCase[tests a simple repeating word/whitespace parser]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  parseString(aCtx, "this is a test");

  // build the following parser on the data stack...
  // ( 
  //   (
  //     ((" " "\t" "\n") 0 parseSpan)
  //     (("az" "AZ") 0 parseSpan)
  //   ) parseChoice
  // ) parseRepeat

  aCtx->tracingOn = true;

  pushSymbolCtxData(aCtx, "parseRepeat");
  pushSymbolCtxData(aCtx, "parseChoice");
  pushSymbolCtxData(aCtx, "parseSpan");
  pushUIntegerCtxData(aCtx, 0);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "AZ");
  pushSymbolCtxData(aCtx, "az");
  prependWord(aCtx);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseSpan");
  pushUIntegerCtxData(aCtx, 0);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "\n");
  pushSymbolCtxData(aCtx, "\t");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, " ");
  prependWord(aCtx);
  prependWord(aCtx);
  prependWord(aCtx);
  wrapWord(aCtx);
  prependWord(aCtx);
  wrapWord(aCtx);
  prependWord(aCtx);
  
  // now evaluate it
//  evalCommandInContext(aCtx, asJObj(newSymbol("interpret", NULL, 0)));
  AssertIntFalse(asParserFailed(aCtx));
\stopCTest
\skipTestCase
\stopTestSuite