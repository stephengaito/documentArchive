% A ConTeXt document [master document: ../jInterp.tex ]

\subsection[title=Primitives]

\TODO{At the moment we do NOT deal correctly with UTF-8 characters.... 
which we can and should.} 

We need to implement the following \joylol\ words:

\startitemize[1]

\item \bold{\type{Fail}} successively takes items off the process stack 
until it reaches a choice symbol. It then places the last list back on the 
process stack. 

\item \bold{\type{Commit}} takes no arguments, and ensures that the first 
subsequent failure is ignored.

\item \bold{\type{Choice}} takes a list of patterns and applies each in 
turn until one succeeds. It does this by taking the top item off the list 
and then placing, itself, the reduced list, and then prepends the top item 
onto the process stack. 

\item \bold{\type{Any}} takes one argument which is the number of 
characters to match. All characters will match. 

\item \bold{\type{Pattern}} takes one argument which is the explicit 
sequence of characters which should be matched. 

\item \bold{\type{CharSet}} Takes two arguments. The first argument should 
be a list of symbols which together make up the set of characters which 
can be matched once. The second argument is the number of characters which 
\emph{must} match characters in the character set. 

\item \bold{\type{coCharSet}} Takes two arguments. The first argument 
which like a \bold{\type{CharSet}}, should be a list of symbols which 
together make up the set of characters which \emph{should not} be matched, 
all characters which are \emph{not} in the character set \emph{will} be 
matched. The second argument is the number of characters which \emph{must} 
\emph{not} match characters in the character set.

\item \bold{\type{Span}} Takes two arguments. The top argument is the list 
of symbols from which to form the character set. The second argument is 
the minimum number of times that should be matched by this character set. 
A \bold{\type{span}} matches as many consecutive characters that are in 
the character set as possible. \bold{\type{Span}} will only fail if it can 
not match at least the specified minimum number of characters. 

\item \bold{\type{coSpan}} Like \bold{\type{Span}}, \bold{\type{coSpan}}, 
takes two arguments. The top argument is a list of symbols from which to 
form the character set. The second argument is the minimum number of times 
that should be matched by characters which are \emph{not} in this 
character set. A \bold{\type{coSpan}} matches as many consecutive 
characters that are \emph{not} in the character set as possible. 
\bold{\type{coSpan}} will only fail if it can not match at least the 
specified minimum number of characters. 

\item \bold{\type{RepeatAtLeast}} repeats the top pattern at least second 
argument times. 

\item \bold{\type{RepeatAtMost}} repeats the top pattern at most second 
argument times. 

\stopitemize 

\TODO{We have not covered \quote{\bold{\type{not}}}, 
\quote{\bold{\type{and}}}, CharSet difference, captures, or actions on 
captures.} 

As suggested in \cite{ierusalimschy2008lpegArticle} we might implement 
captures using a \type{Capture} call with three distinct arguments: 

\startitemize[n] 

\item \type{begin n} where the actual capture begins $n$ characters before 
the current character. This capture method should be called \emph{as soon 
as} it is known that the current path will succeed. 

\item \type{end} this marks the end of a capture 

\item \type{full n} this is the same as a \type{begin n} immediately 
followed by an \type{end}. 

\stopitemize 

For all of the above \joylol\ words, the data stack must include both the 
current text structure (which must include a indication of the current 
character) as well as the current collection of captures. 

A compiler is a pipeline of co-routines. The parser might itself be a 
pipeline of co-routines, one for the lexer, one for the ultimate parser, 
but there could be numerous intermediary co-routines parsing more complex 
syntactic structures. 

\startCCode
static void parseSymbolWord(ContextObj *aCtx) {
  popCtxDataInto(aCtx, top);
  if (!isSymbolObj(top)) {
    raiseExceptionMsg(aCtx,
      "parse symbol expected a symbol as top");
    return;
  }
  parseString(aCtx, asSymbol(top));
}

static void parseFileWord(ContextObj *aCtx) {
  popCtxDataInto(aCtx, top);
  if (!isSymbolObj(top)) {
    raiseExceptionMsg(aCtx,
      "parse file expected a symbol as top");
    return;
  }
  parseFile(aCtx, asSymbol(top));
}
\stopCCode


\startTestSuite[jPegChoiceWords and jPegCommitWord]

\startCHeader
void jPegChoiceContinueWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegChoiceContinueWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, parserChoices);
  
  // if top is the empty list we are done...
  if (!parserChoices) return;

  // if we have failed... but are committed... 
  // we FAIL the whole choice... BUT... we are done...
  if (asParserFailed(aCtx) && asParserCommitted(aCtx)) {
    asParserCommitted(aCtx) = false;
    return;
  }
  
  // if we have not failed... we are also done...
  if (!asParserFailed(aCtx)) {
    asParserFailed(aCtx) = false;
    return;
  }
  
  if (!isPairObj(parserChoices)) {
    raiseExceptionMsg(aCtx,
      "jPeg choice parser expected a list as top");
    return;
  }
  popListInto(aCtx, parserChoices, firstChoice);
  pushSymbolCtxProcess(aCtx, "parseChoiceCont");
  pushCtxProcess(aCtx, parserChoices);
  prependListCtxProcess(aCtx, firstChoice);
  
  if (aCtx->process) {
    asParserFailed(aCtx) = false;
  }

}
\stopCCode

\startCHeader
void jPegChoiceWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegChoiceWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  asParserFailed(aCtx) = true;
  jPegChoiceContinueWord(aCtx);
}
\stopCCode

\startCHeader
void jPegCommitWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCommitWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  asParserCommitted(aCtx) = true;
}
\stopCCode

\startTestCase[tests choice and commit]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);

  // if the top of the data is an empty list
  //
  AssertPtrNull(asCtxData(aCtx));
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegChoiceContinueWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNull(asCtxData(aCtx));
  AssertPtrNull(asCtxProcess(aCtx));
  
  pushUIntegerCtxData(aCtx, 44);
  pushUIntegerCtxData(aCtx, 43);
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 42);
  prependWord(aCtx);
  
  // commit changes the commit flag
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegCommitWord(aCtx);
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));

  // failed and committed...
  //
  dup1DWord(aCtx);
  AssertIntEquals(listLength(asCtxData(aCtx)), 2);
  asParserFailed(aCtx) = true;
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  jPegChoiceContinueWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));
  
  // not failed...
  //
  dup1DWord(aCtx);
  AssertIntEquals(listLength(asCtxData(aCtx)), 2);
  asParserFailed(aCtx)   = false;
  asParserCommitted(aCtx) = false;
  jPegChoiceContinueWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));
  
  dup1DWord(aCtx);
  AssertIntEquals(listLength(asCtxData(aCtx)), 2);
  asParserCommitted(aCtx) = false;
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNull(asCtxProcess(aCtx));
  jPegChoiceWord(aCtx);
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 3);
  
  popCtxProcessInto(aCtx, top);
  popCtxProcessInto(aCtx, second);
  popCtxProcessInto(aCtx, third);
  
  AssertIntTrue(isSymbolObj(third));
  AssertStrEquals(asSymbol(third), "parseChoiceCont");
  
  AssertIntTrue(isPairObj(second));
  AssertIntTrue(isUIntegerObj(asCar(second)));
  AssertIntEquals(asUInteger(asCar(second)), 43);
  
  AssertIntTrue(isPairObj(asCdr(second)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(second))));
  AssertIntEquals(asUInteger(asCar(asCdr(second))), 44);
  
  AssertPtrNull(asCdr(asCdr(second)));
  
  AssertIntTrue(isUIntegerObj(top));
  AssertIntEquals(asUInteger(top), 42);  
\stopCTest
\stopTestCase
\stopTestSuite

The \bold{\type{parseRepeat}*} words are each optimized variants of 
choice. As such they each need to deal with parsers being commited and or 
failed. 

\startTestSuite[jPegRepeatWord]

\startCHeader
void jPegRepeatWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegRepeatWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  popCtxDataInto(aCtx, parser);

  // we always ignore and reset committed-ness
  asParserCommitted(aCtx) = false;

  // if the parser is empty... there is nothing to do...
  if (!parser) return;
  
  // if we have failed...
  // we roll back the last repeat and then...
  // we SUCCEED and are done...
  if (asParserFailed(aCtx)) {
    // the last checkpoint SHOULD have been
    // stored on the process stack
    
    asParserFailed(aCtx) = false;
    
    return;
  }
  
  // we have not failed... so we try another repeat...
  pushSymbolCtxProcess(aCtx, "parseRepeat");
  pushCtxProcess(aCtx, parser);
  prependListCtxProcess(aCtx, copyLoL(parser));
}
\stopCCode

\startTestCase[test repeating parsers]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushUIntegerCtxData(aCtx, 43);
  pushUIntegerCtxData(aCtx, 42);
  prependWord(aCtx);

  // failed
  //
  dup1DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = true;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 2);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  jPegRepeatWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));

  // succeeded
  //
  dup1DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = false;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 2);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegRepeatWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 4);
    
  popCtxProcessInto(aCtx, top42);
  popCtxProcessInto(aCtx, top43);
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, repeatWord);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseRepeat");
  
  AssertIntTrue(isPairObj(parser));
  AssertIntTrue(isUIntegerObj(asCar(parser)));
  AssertIntEquals(asUInteger(asCar(parser)), 42);
  
  AssertIntTrue(isPairObj(asCdr(parser)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(parser))));
  AssertIntEquals(asUInteger(asCar(asCdr(parser))), 43);
  
  AssertPtrNull(asCdr(asCdr(parser)));
  
  AssertIntTrue(isUIntegerObj(top42));
  AssertIntEquals(asUInteger(top42), 42);  

  AssertIntTrue(isUIntegerObj(top43));
  AssertIntEquals(asUInteger(top43), 43);  
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegRepeatAtLeastWord]

\startCHeader
void jPegRepeatAtLeastWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegRepeatAtLeastWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, parser);

  popCtxDataInto(aCtx, atLeast);
  if (!isUIntegerObj(atLeast)) {
    raiseExceptionMsg(aCtx,
      "jPeg repeatAtLeast parser expected a UInteger as top");
    return;
  }
  size_t atLeastRepeats = asUInteger(atLeast);
  
  // we always ignore and reset committed-ness
  asParserCommitted(aCtx) = false;

  // if the parser is empty... there is nothing to do
  if (!parser) return;
  
  // if we have failed...
  if (asParserFailed(aCtx)) {
    //
    // we roll back the last repeat...
    // the last checkpoint SHOULD have been
    // stored on the process stack
    
    // now we check to see if we have repeated enough times...
    if (0 < atLeastRepeats) {
      pushSymbolCtxProcess(aCtx, "parseFail");
    } else {
      asParserFailed(aCtx) = false;
    }
    
    // now we return without starting another repeat
    return;
  }
  
  // we have succeeded.... so we setup the next repeat...
  if (0 < atLeastRepeats) {
    pushSymbolCtxProcess(aCtx, "parseRepeatAtLeast");
    pushUIntegerCtxProcess(aCtx, atLeastRepeats - 1);
  } else {
    pushSymbolCtxProcess(aCtx, "parseRepeat");
  }
  pushCtxProcess(aCtx, parser);
  prependListCtxProcess(aCtx, copyLoL(parser));
}
\stopCCode

\startTestCase[test repeat at least parsers]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushUIntegerCtxData(aCtx, 43);
  pushUIntegerCtxData(aCtx, 42);
  prependWord(aCtx);

  // failed and 0 == atLeast
  //
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 0);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = true;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  jPegRepeatAtLeastWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));

  // failed and 0 < atLeast
  //
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 10);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = true;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  jPegRepeatAtLeastWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 1);
  AssertIntTrue(isSymbolObj(asCar(asCtxProcess(aCtx))));
  AssertStrEquals(asSymbol(asCar(asCtxProcess(aCtx))), "parseFail");

  // succeeded and 0 == atLeast
  //
  {
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 0);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = false;
  asCtxProcess(aCtx) = NULL;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegRepeatAtLeastWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 4);
    
  popCtxProcessInto(aCtx, top42);
  popCtxProcessInto(aCtx, top43);
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, repeatWord);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseRepeat");
  
  AssertIntTrue(isPairObj(parser));
  AssertIntTrue(isUIntegerObj(asCar(parser)));
  AssertIntEquals(asUInteger(asCar(parser)), 42);
  
  AssertIntTrue(isPairObj(asCdr(parser)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(parser))));
  AssertIntEquals(asUInteger(asCar(asCdr(parser))), 43);
  
  AssertPtrNull(asCdr(asCdr(parser)));
  
  AssertIntTrue(isUIntegerObj(top42));
  AssertIntEquals(asUInteger(top42), 42);  

  AssertIntTrue(isUIntegerObj(top43));
  AssertIntEquals(asUInteger(top43), 43);  
  }
  
  // succeeded and 0 < atLeast
  //
  {
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 10);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = false;
  asCtxProcess(aCtx) = NULL;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegRepeatAtLeastWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 5);
  
  popCtxProcessInto(aCtx, top42);
  popCtxProcessInto(aCtx, top43);
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, atLeast);
  popCtxProcessInto(aCtx, repeatWord);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseRepeatAtLeast");
  
  AssertIntTrue(isUIntegerObj(atLeast));
  AssertIntEquals(asUInteger(atLeast), 9);
  
  AssertIntTrue(isPairObj(parser));
  AssertIntTrue(isUIntegerObj(asCar(parser)));
  AssertIntEquals(asUInteger(asCar(parser)), 42);
  
  AssertIntTrue(isPairObj(asCdr(parser)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(parser))));
  AssertIntEquals(asUInteger(asCar(asCdr(parser))), 43);
  
  AssertPtrNull(asCdr(asCdr(parser)));
  
  AssertIntTrue(isUIntegerObj(top42));
  AssertIntEquals(asUInteger(top42), 42);  

  AssertIntTrue(isUIntegerObj(top43));
  AssertIntEquals(asUInteger(top43), 43);  
  }
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegRepeatAtMostWord]

\startCHeader
void jPegRepeatAtMostWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegRepeatAtMostWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  popCtxDataInto(aCtx, parser);

  popCtxDataInto(aCtx, atMost);
  if (!isUIntegerObj(atMost)) {
    raiseExceptionMsg(aCtx,
      "jPeg repeatAtMost parser expected a UInteger as top");
    return;
  }
  size_t atMostRepeats = asUInteger(atMost);

  // we always ignore and reset committed-ness
  asParserCommitted(aCtx) = false;

  // if the parser is empty... then we are done...
  if (!parser) return;

  // if we have failed...
  if (asParserFailed(aCtx)) {
    //
    // we roll back the last repeat...
    // the last checkpoint SHOULD have been
    // stored on the process stack
    
    // now we check to see if we have repeated enough times...
     if (0 == atMostRepeats) {
       pushSymbolCtxProcess(aCtx, "parseFail");
     } else {
      asParserFailed(aCtx) = false;
     }
    
    // now we return without starting another repeat
    return;
  }
  
  // we have succeeded.... so we setup the next repeat...
  if (0 < atMostRepeats) {
    pushSymbolCtxProcess(aCtx, "parseRepeatAtMost");
    pushUIntegerCtxProcess(aCtx, atMostRepeats - 1);
    pushCtxProcess(aCtx, parser);
    prependListCtxProcess(aCtx, copyLoL(parser));
  } else {
    pushSymbolCtxProcess(aCtx, "parseFail");
  }
}
\stopCCode
\startTestCase[test repeat at most parsers]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushUIntegerCtxData(aCtx, 43);
  pushUIntegerCtxData(aCtx, 42);
  prependWord(aCtx);

  // failed and 0 < atMost
  //
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 10);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = true;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  jPegRepeatAtMostWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));

  // failed and 0 == atMost
  //
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 0);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = true;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  jPegRepeatAtMostWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 1);
  AssertIntTrue(isSymbolObj(asCar(asCtxProcess(aCtx))));
  AssertStrEquals(asSymbol(asCar(asCtxProcess(aCtx))), "parseFail");

  // succeeded and 0 < atMost 
  //
  {
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 10);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = false;
  asCtxProcess(aCtx) = NULL;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegRepeatAtMostWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 5);
    
  popCtxProcessInto(aCtx, top42);
  popCtxProcessInto(aCtx, top43);
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, atMost);
  popCtxProcessInto(aCtx, repeatWord);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseRepeatAtMost");
  
  AssertIntTrue(isUIntegerObj(atMost));
  AssertIntEquals(asUInteger(atMost), 9);
  
  AssertIntTrue(isPairObj(parser));
  AssertIntTrue(isUIntegerObj(asCar(parser)));
  AssertIntEquals(asUInteger(asCar(parser)), 42);
  
  AssertIntTrue(isPairObj(asCdr(parser)));
  AssertIntTrue(isUIntegerObj(asCar(asCdr(parser))));
  AssertIntEquals(asUInteger(asCar(asCdr(parser))), 43);
  
  AssertPtrNull(asCdr(asCdr(parser)));
  
  AssertIntTrue(isUIntegerObj(top42));
  AssertIntEquals(asUInteger(top42), 42);  

  AssertIntTrue(isUIntegerObj(top43));
  AssertIntEquals(asUInteger(top43), 43);
  }

  // succeeded and 0 == atMost 
  //
  {
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 0);
  swap12DWord(aCtx);
  asParserCommitted(aCtx) = true;
  asParserFailed(aCtx) = false;
  asCtxProcess(aCtx) = NULL;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 3);
  AssertPtrNull(asCtxProcess(aCtx));
  AssertIntTrue(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegRepeatAtMostWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 1);
    
  popCtxProcessInto(aCtx, repeatWord);
  
  AssertIntTrue(isSymbolObj(repeatWord));
  AssertStrEquals(asSymbol(repeatWord), "parseFail");
  }
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegFailWord]

\startCHeader
void jPegFailWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegFailWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  asParserFailed(aCtx) = true;
  
  JObj *lastCommand = NULL;
  while(aCtx->process) {
    popCtxProcessInto(aCtx, aCommand);
    if (
      symbolIs(aCommand, "parseChoiceCont") ||
      symbolStartsWith(aCommand, "parseRepeat")
    ) {
      pushCtxProcess(aCtx, aCommand);
      pushCtxProcess(aCtx, lastCommand);
      return;
    }
    lastCommand = aCommand;
  }
}
\stopCCode

\startTestCase[a simple fail with choice/repeat words]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);  

  // no choice or repeat words
  //
  {
  dup1DWord(aCtx);
  popCtxDataInto(aCtx, noWordTest);
  pushSymbolCtxProcess(aCtx, "someWord");
  pushCtxProcess(aCtx, noWordTest);
  prependListCtxProcess(aCtx, copyLoL(noWordTest));
  asParserCommitted(aCtx) = false;
  asParserFailed(aCtx) = false;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 6);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegFailWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNull(asCtxProcess(aCtx));
  }
  
  // choice 
  //
  {
  dup1DWord(aCtx);
  popCtxDataInto(aCtx, choiceTest);
  pushSymbolCtxProcess(aCtx, "parseChoiceCont");
  pushCtxProcess(aCtx, choiceTest);
  prependListCtxProcess(aCtx, copyLoL(choiceTest));
  asParserCommitted(aCtx) = false;
  asParserFailed(aCtx) = false;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 6);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegFailWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 2);
  
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, parserWord);
  
  AssertIntTrue(isSymbolObj(parserWord));
  AssertStrEquals(asSymbol(parserWord), "parseChoiceCont");
  
  AssertIntTrue(isPairObj(parser));
  AssertIntEquals(listLength(parser), 4);
  AssertIntTrue(isSymbolObj(asCar(asCdr(parser))));
  AssertStrEquals(asSymbol(asCar(asCdr(parser))), "parseAny");
  }

  // repeat words
  //
  {
  dup1DWord(aCtx);
  popCtxDataInto(aCtx, repeatTest);
  pushSymbolCtxProcess(aCtx, "parseRepeatAtLeast");
  pushCtxProcess(aCtx, repeatTest);
  prependListCtxProcess(aCtx, copyLoL(repeatTest));
  asParserCommitted(aCtx) = false;
  asParserFailed(aCtx) = false;
  //
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 6);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntFalse(asParserFailed(aCtx));
  jPegFailWord(aCtx);
  AssertIntFalse(asParserCommitted(aCtx));
  AssertIntTrue(asParserFailed(aCtx));
  AssertPtrNotNull(asCtxData(aCtx));
  AssertIntEquals(listLength(asCtxData(aCtx)), 1);
  AssertPtrNotNull(asCtxProcess(aCtx));
  AssertIntEquals(listLength(asCtxProcess(aCtx)), 2);
  
  popCtxProcessInto(aCtx, parser);
  popCtxProcessInto(aCtx, parserWord);
  
  AssertIntTrue(isSymbolObj(parserWord));
  AssertStrEquals(asSymbol(parserWord), "parseRepeatAtLeast");
  
  AssertIntTrue(isPairObj(parser));
  AssertIntEquals(listLength(parser), 4);
  AssertIntTrue(isSymbolObj(asCar(asCdr(parser))));
  AssertStrEquals(asSymbol(asCar(asCdr(parser))), "parseAny");
  }

//  showCtxData(aCtx);
//  showCtxProcess(aCtx);

\stopCTest
\stopTestCase

\startTestCase[a complex choice/fail/commit tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);

  // (
  //   ( fail 1 any 1 any)
  //   ( 1 any commit fail 1 any 1 any)
  //   ( 1 any)
  // ) choice

  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  wrapWord(aCtx);
  
  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseFail");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseCommit");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  wrapWord(aCtx);
  
  prependWord(aCtx);
  
  pushSymbolCtxData(aCtx, "parseAny");
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseAny");
  prependWord(aCtx);
  pushUIntegerCtxData(aCtx, 1);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseFail");
  prependWord(aCtx);
  wrapWord(aCtx);
  
  prependWord(aCtx);
  wrapWord(aCtx);
  dup1DWord(aCtx);
  
  pushSymbolCtxData(aCtx, "parseChoice");
  swap12DWord(aCtx);
  prependWord(aCtx);
  
//  showCtxData(aCtx);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegAnyWord and jPegPatternWord]

\startCHeader
void jPegAnyWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegAnyWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg any parser expected a UInteger as top");
    return;
  }
  
  size_t charsToMatch     = asUInteger(top);
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while (
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (0 < charsToMatch)
  ) {
    asParserTextPosition(aCtx)++;
    charsToMatch--;
  }
    
  if (0 < charsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }

}
\stopCCode

\startCHeader
void jPegPatternWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegPatternWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, top);
  if (!isSymbolObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg pattern parser expected a symbol as top");
    return;
  }
  
  Symbol *pattern         = asSymbol(top);
  size_t patternSize      = strlen(pattern);
  size_t charsMatched     = 0;
  size_t origTextPosition = asParserTextPosition(aCtx);
  Symbol *parserText      = asParserText(aCtx) + origTextPosition;

  // TODO: need to deal with UTF-8 multi-byte characters

  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (charsMatched < patternSize) &&
    (parserText[charsMatched] == pattern[charsMatched])
  ) {
    asParserTextPosition(aCtx)++;
    charsMatched++;
  }
  
  if (charsMatched != patternSize)  {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startTestCase[simple any and pattern parser tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);

  parseString(aCtx, "aaabbb");
  AssertIntZero(asParserTextPosition(aCtx));
  pushUIntegerCtxData(aCtx, 5);
  jPegAnyWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 5);
  asParserTextPosition(aCtx) = 0;
  pushSymbolCtxData(aCtx, "aaab");
  AssertIntZero(asParserTextPosition(aCtx));
  jPegPatternWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 4);
\stopCTest
\stopTestCase
\stopTestSuite


\startTestSuite[collectJPegSpans and matchCharSetSpans]

\startCHeader
typedef struct parser_char_span {
  char firstChar;
  char lastChar;
} ParserCharSpan;

typedef struct parser_charSet_spans {
  Symbol         *charSet;
  size_t          charSetSize;
  ParserCharSpan *spans;
  size_t          numSpans;
  size_t          maxSpans;
} ParserCharSpans;

ParserCharSpans *collectJPegSpans(ContextObj *aCtx);
\stopCHeader

\startCCode
ParserCharSpans *collectJPegSpans(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *collectedSpans = 
    (ParserCharSpans*)calloc(1, sizeof(ParserCharSpans));
  collectedSpans->charSet     = NULL;
  collectedSpans->charSetSize = 0;
  collectedSpans->spans       = NULL;
  collectedSpans->numSpans    = 0;
  collectedSpans->maxSpans    = 0;
  
  popCtxDataInto(aCtx, someSpans);
  while (isPairObj(someSpans)) {
    JObj *firstSpan = asCar(someSpans);
    someSpans       = asCdr(someSpans);
    if (!isSymbolObj(firstSpan)) {
      raiseExceptionMsg(aCtx,
        "jPeg list of spans expected a symbol as next span");
      return collectedSpans; 
    }
    Symbol *spanSymbol     = asSymbol(firstSpan);
    size_t  spanSymbolSize = strlen(spanSymbol);
    switch(spanSymbolSize) {
      case 0 :
        // ignore this span
        break;
      case 2 :
        // create a new span item
        //
        if (collectedSpans->maxSpans <= collectedSpans->numSpans) {
          // need to increase the number of spans...
          ParserCharSpan *oldSpans = collectedSpans->spans;
          size_t newMaxSpans       = collectedSpans->maxSpans + 10;
          ParserCharSpan *newSpans =
            (ParserCharSpan*)calloc(newMaxSpans, sizeof(ParserCharSpan));
          assert(newSpans);
          if (oldSpans) {
            memcpy(
              newSpans,
              oldSpans,
              ((collectedSpans->maxSpans) * sizeof(ParserCharSpan))
            );
            free(oldSpans);
            oldSpans = NULL;
          }
          collectedSpans->spans    = newSpans;
          collectedSpans->maxSpans = newMaxSpans;
        }
        ParserCharSpan *newSpan =
          collectedSpans->spans + collectedSpans->numSpans;
        if (spanSymbol[0] <= spanSymbol[1]) {
          newSpan->firstChar = spanSymbol[0];
          newSpan->lastChar  = spanSymbol[1];
        } else {
          newSpan->firstChar = spanSymbol[1];
          newSpan->lastChar  = spanSymbol[0];
        }
        collectedSpans->numSpans++;
        break;
      default: {
        // append this span to the charSet
        //
        Symbol *oldCharSet = collectedSpans->charSet;
        collectedSpans->charSet =
          appendSymbols(oldCharSet, spanSymbol);
        free((char*)oldCharSet);
        collectedSpans->charSetSize = strlen(collectedSpans->charSet);
      }
    }
  }
  return collectedSpans;
}
\stopCCode

\startCHeader
Boolean matchCharSetSpans(ContextObj *aCtx, ParserCharSpans *spans);
\stopCHeader

\startCCode
Boolean matchCharSetSpans(ContextObj *aCtx, ParserCharSpans *spans) {
  assert(isContextObj(aCtx));
  
  if (!spans) return true;
  
  size_t numCurSpan  = spans->numSpans;
  Symbol *curCharPtr = asParserText(aCtx) + asParserTextPosition(aCtx);
  char curChar       = *curCharPtr;
  
  while (0 < numCurSpan) {
    ParserCharSpan *aSpan = spans->spans + numCurSpan - 1;
    if ((aSpan->firstChar <= curChar) && (curChar <= aSpan->lastChar)) {
      return true;
    } 
    numCurSpan--;
  }
  
  size_t curCharSetChar = spans->charSetSize;
  Symbol *charSet       = spans->charSet;
  
  while (0 < curCharSetChar) {
    if (curChar == charSet[curCharSetChar]) {
      return true;
    }
    curCharSetChar--;
  }
  
  return false;
}

static void deleteJPegSpans(ParserCharSpans *someSpans) {
  if (!someSpans) return;
  if (someSpans->charSet) free((char*)someSpans->charSet);
  if (someSpans->spans)   free(someSpans->spans);
  free(someSpans);
}
\stopCCode

\startTestCase[simple jPeg span tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushSymbolCtxData(aCtx, "AZ");
  pushSymbolCtxData(aCtx, "az");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "-test");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "space");
  prependWord(aCtx);
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  AssertPtrNotNull(spans);
  AssertStrEquals(spans->charSet, "space-test");
  AssertIntEquals(spans->charSetSize, 10);
  AssertPtrNotNull(spans->spans);
  AssertIntEquals(spans->numSpans, 2);
  AssertIntEquals(spans->maxSpans, 10);
  AssertIntEquals(spans->spans[0].firstChar, 'a');
  AssertIntEquals(spans->spans[0].lastChar,  'z');
  AssertIntEquals(spans->spans[1].firstChar, 'A');
  AssertIntEquals(spans->spans[1].lastChar,  'Z');
  
  parseString(aCtx, "WoRd 10-");
  AssertIntEquals(getParserCurChar(aCtx), 'W');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), 'o');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), 'R');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), 'd');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), ' ');
  AssertIntFalse(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), '1');
  AssertIntFalse(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), '0');
  AssertIntFalse(matchCharSetSpans(aCtx, spans));
  advanceParserTextPosition(aCtx);
  AssertIntEquals(getParserCurChar(aCtx), '-');
  AssertIntTrue(matchCharSetSpans(aCtx, spans));
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[jPegCharSetWords and jPegSpanWords]

\startCHeader
void jPegCharSetWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCharSetWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t charsToMatch     = asUInteger(top);
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (0 < charsToMatch) &&
    matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsToMatch--;
  }
  
  deleteJPegSpans(spans);

  if (0 < charsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startCHeader
void jPegCoCharSetWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCoCharSetWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t charsToMatch     = asUInteger(top);
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    (0 < charsToMatch) &&
    !matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsToMatch--;
  }
  
  deleteJPegSpans(spans);

  if (0 < charsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startCHeader
void jPegSpanWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegSpanWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t minCharsToMatch  = asUInteger(top);
  size_t charsMatched     = 0;
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsMatched++;
  }
  
  deleteJPegSpans(spans);
 
  if (charsMatched < minCharsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startCHeader
void jPegCoSpanWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCoSpanWord(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  ParserCharSpans *spans = collectJPegSpans(aCtx);
  
  popCtxDataInto(aCtx, top);
  if (!isUIntegerObj(top)) {
    raiseExceptionMsg(aCtx,
      "jPeg charSet parser expected a UInteger as top");
    deleteJPegSpans(spans);
    return;
  }
  
  size_t minCharsToMatch  = asUInteger(top);
  size_t charsMatched     = 0;
  size_t origTextPosition = asParserTextPosition(aCtx);
  
  // TODO: need to deal with UTF-8 multi-byte characters
  
  while(
    (asParserTextPosition(aCtx) <= asParserTextSize(aCtx)) &&
    !matchCharSetSpans(aCtx, spans)
  ) {
    asParserTextPosition(aCtx)++;
    charsMatched++;
  }

  deleteJPegSpans(spans);

  if (charsMatched < minCharsToMatch) {
    asParserTextPosition(aCtx) = origTextPosition;
    jPegFailWord(aCtx);
  }
}
\stopCCode

\startTestCase[charSet and span tests]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushSymbolCtxData(aCtx, "AZ");
  pushSymbolCtxData(aCtx, "az");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "-test");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "space");
  prependWord(aCtx);

  parseString(aCtx, "aaa-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 4);
  swap12DWord(aCtx);
  jPegCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 4);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 5);
  swap12DWord(aCtx);
  jPegCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  parseString(aCtx, "$%^-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 3);
  swap12DWord(aCtx);
  jPegCoCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 3);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));

  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 4);
  swap12DWord(aCtx);
  jPegCoCharSetWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));

  parseString(aCtx, "aaa-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 2);
  swap12DWord(aCtx);
  jPegSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 4);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 5);
  swap12DWord(aCtx);
  jPegSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  
  parseString(aCtx, "$%^-10");
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 2);
  swap12DWord(aCtx);
  jPegCoSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 3);
  AssertIntFalse(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));

  resetParserTextPosition(aCtx);
  dup1DWord(aCtx);
  pushUIntegerCtxData(aCtx, 4);
  swap12DWord(aCtx);
  jPegCoSpanWord(aCtx);
  AssertIntEquals(asParserTextPosition(aCtx), 0);
  AssertIntTrue(asParserFailed(aCtx));
  AssertIntFalse(asCtxExceptionRaised(aCtx));
\stopCTest
\stopTestCase
\stopTestSuite

\startCHeader
void registerJPegWords(ContextObj *aCtx);
\stopCHeader

\startCCode
void registerJPegWords(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  SymbolTableObj *symTab = asCtxSymbols(aCtx);
  assert(isSymbolTableObj(symTab));
  
  registerCFunction(symTab, "parseSymbol",        parseSymbolWord);
  registerCFunction(symTab, "parseFile",          parseFileWord);
  registerCFunction(symTab, "parseChoice",        jPegChoiceWord);
  registerCFunction(symTab, "parseChoiceCont",    jPegChoiceContinueWord);
  registerCFunction(symTab, "parseCommit",        jPegCommitWord);
  registerCFunction(symTab, "parseFail",          jPegFailWord);
  registerCFunction(symTab, "parseAny",           jPegAnyWord);
  registerCFunction(symTab, "parsePattern",       jPegPatternWord);
  registerCFunction(symTab, "parseCharSet",       jPegCharSetWord);
  registerCFunction(symTab, "parseCoCharSet",     jPegCoCharSetWord);
  registerCFunction(symTab, "parseSpan",          jPegSpanWord);
  registerCFunction(symTab, "parseCoSpan",        jPegCoSpanWord);
  registerCFunction(symTab, "parseRepeat",        jPegRepeatWord);
  registerCFunction(symTab, "parseRepeatAtLeast", jPegRepeatAtLeastWord);
  registerCFunction(symTab, "parseRepeatAtMost",  jPegRepeatAtMostWord);
}
\stopCCode


\startTestSuite[general parser tests]

\startTestCase[tests a simple repeating word/whitespace parser]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  parseString(aCtx, "this is a test");

  // build the following parser on the data stack...
  // ( 
  //   (
  //     ((" " "\t" "\n") 0 parseSpan)
  //     (("az" "AZ") 0 parseSpan)
  //   ) parseChoice
  // ) parseRepeat

  aCtx->tracingOn = true;

  pushSymbolCtxData(aCtx, "parseRepeat");
  pushSymbolCtxData(aCtx, "parseChoice");
  pushSymbolCtxData(aCtx, "parseSpan");
  pushUIntegerCtxData(aCtx, 0);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "AZ");
  pushSymbolCtxData(aCtx, "az");
  prependWord(aCtx);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "parseSpan");
  pushUIntegerCtxData(aCtx, 0);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "\n");
  pushSymbolCtxData(aCtx, "\t");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, " ");
  prependWord(aCtx);
  prependWord(aCtx);
  prependWord(aCtx);
  wrapWord(aCtx);
  prependWord(aCtx);
  wrapWord(aCtx);
  prependWord(aCtx);
  
  // now evaluate it
//  evalCommandInContext(aCtx, asJObj(newSymbol("interpret", NULL, 0)));
  AssertIntFalse(asParserFailed(aCtx));
\stopCTest
\skipTestCase
\stopTestSuite