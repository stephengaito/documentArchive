% A ConTeXt document [master document: ../jInterp.tex ]

\subsection[title=Capture]

\startCHeader
void clearCtxCaptures(ContextObj *aCtx);
\stopCHeader

\startCCode
void clearCtxCaptures(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  aCtx->parserCaptures = NULL;
}
\stopCCode

\startCHeader
void pushCtxCaptures(ContextObj *aCtx, JObj *lolToPush);
\stopCHeader

\startCCode
void pushCtxCaptures(ContextObj *aCtx, JObj *lolToPush) {
  assert(isContextObj(aCtx));
  aCtx->parserCaptures =
    asJObj(newPair(lolToPush, aCtx->parserCaptures));
}
\stopCCode

\startCHeader
void pushNullCtxCaptures(ContextObj *aCtx);
\stopCHeader

\startCCode
void pushNullCtxCaptures(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  aCtx->parserCaptures = 
    asJObj(newPair(NULL, aCtx->parserCaptures));
}
\stopCCode

\startCHeader
JObj *popCtxCaptures(ContextObj *aCtx);

#define popCtxCapturesInto(aCtx, aVar)          \
assert(isContextObj(aCtx));                     \
JObj *aVar = popCtxCaptures(aCtx);              \
if (aCtx->tracingOn) {                          \
  StringBufferObj *aStrBuf = newStringBuffer(); \
  strBufPrintf(aStrBuf, "%s = ", #aVar);        \
  printJObj(aStrBuf, asJObj(aVar), "", 20);     \
  strBufPrintf(aStrBuf, "\n");                  \
  printf("%s", getCString(aStrBuf));            \
  strBufClose(aStrBuf);                         \
  free(aStrBuf);                                \
}
\stopCHeader

\startCCode
JObj *popCtxCaptures(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  if (!aCtx->parserCaptures) return NULL;
  
  assert(isPairObj(aCtx->parserCaptures));
  JObj *poppedLoL      = asCar(aCtx->parserCaptures);
  aCtx->parserCaptures = asCdr(aCtx->parserCaptures);
  
  DEBUG(ParserDebug, "popCtxCaptures: %p %s\n",
    poppedLoL, getJObjName(poppedLoL)
  );
  
  return poppedLoL;
}
\stopCCode

\startCHeader
void showCtxCaptures(ContextObj *aCtx);
\stopCHeader

\startCCode
void showCtxCaptures(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  showCtxStack(aCtx, aCtx->parserCaptures, "captures");
}
\stopCCode

\startCHeader
void appendSymbolCtxCaptures(ContextObj *aCtx, Symbol *aSymbol);
\stopCHeader

\startCCode
void appendSymbolCtxCaptures(ContextObj *aCtx, Symbol *aSymbol) {
  assert(isContextObj(aCtx));
  assert(aSymbol);
  
  popCtxCapturesInto(aCtx, top);
  JObj *result =
    asJObj(concatLists(top,
      asJObj(newSymbol(aSymbol, "unknown", 0))));
  pushCtxCaptures(aCtx, result);
}
\stopCCode

\startCHeader
void jPegCaptureContinueWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCaptureContinueWord(ContextObj *aCtx){
  assert(isContextObj(aCtx));
  
  DEBUG(ParserDebug, "jPegCaptureContinueWord%s\n","");
  
  popCtxProcessInto(aCtx, captureStartObj);
  
  if (!asParserFailed(aCtx)) {
    if (!isUIntegerObj(captureStartObj)) {
      DEBUG(ParserDebug,
        "jPegCaptureContinueWord: capture start is not a UInetger%s\n","");
      raiseExceptionMsg(aCtx,
        "jPeg capture parser expected a UInteger as capture start");
      return;
    }
    UInteger captureStart = asUInteger(captureStartObj);
    UInteger captureEnd   = asParserTextPosition(aCtx);
    
    if (captureStart <= captureEnd) {
      size_t symbolLen = captureEnd - captureStart;
      char *newSymbol = calloc(symbolLen+1, sizeof(char));
      strncpy(
        newSymbol,
        asParserText(aCtx) + captureStart,
        symbolLen
      );
      appendSymbolCtxCaptures(aCtx, newSymbol);
      DEBUG(ParserDebug,
        "jPegCaptureContinueWord: start %zu end %zu symbol [%s]\n",
        captureStart, captureEnd, newSymbol
      );
    } else {
      DEBUG(ParserDebug,
        "jPegCaptureContinueWord: capture end before capture start%s\n","");
    }
  } else {
    DEBUG(ParserDebug,
      "jPegCaptureContinueWord: parser failed... ignoring capture%s\n","");
  }
  
}
\stopCCode

\startCHeader
void jPegCaptureWord(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegCaptureWord(ContextObj *aCtx){
  assert(isContextObj(aCtx));
  
  DEBUG(ParserDebug, "jPegCaptureWord: startCapture: %zu\n",
    asParserTextPosition(aCtx));

  popCtxDataInto(aCtx, parser);
    
  pushUIntegerCtxProcess(aCtx, asParserTextPosition(aCtx));
  pushSymbolCtxProcess(aCtx, "parseCaptureCont");
  prependListCtxProcess(aCtx, parser);
}
\stopCCode