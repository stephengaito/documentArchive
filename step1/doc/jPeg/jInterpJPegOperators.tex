% A ConTeXt document [master document: ../jInterp.tex ]

\subsection[title=Operator Precedence Parsing] 

We base our implementation of Operator Precedence Parsing on Andy Chu's 
excellent exposition of Pratt Parsing, \cite{chu2016prattParsing} and 
\cite{chu2016prattParsingGitHub}. 

Quoting Chu:

\startBlockQuote

To me, these are its [Pratt Parsing's] salient characteristics: 

\startitemize[n]

\item It's mutually recursive between a core \type{parse(int rbp)} 
function and \type{nud()} and \type{led()} \quote{plugin functions} for 
each operator. In my code, these are the \type{p.ParseUntil(int 
precedence)} method, and \type{Null*()} and \type{Left*()} functions. 

\item Many recursive algorithms like tree traversal are purely functional. 
In contrast, Pratt parsing has the property that the recursive procedures 
also mutate state, i.e. the current token. This is just like recursive 
descent parsing, which is one reason they go together well. 

\stopitemize
\stopBlockQuote

In our case our \quote{parser} (\quote{context}) state is maintained in 
the jPeg context. We add nud (null denotation) and led (left denotaiton) 
dictionaries to contain references to the \quote{plugin functions} 
(denotations) for each operator. 

We implement \type{lookupLeftDenotation} and \type{lookupNullDenotation} 
jPeg words as well as corresponding \type{registerLeftDenotation} and 
\type{registerNullDenotation} joylol words to lookup and register left and 
null denotations respectively. 

Chu's Pratt Parser's \type{ParseUntil} function, is really a 
\type{parseUntil} structure similar to the existing jPeg repeat structures 
(\type{repeat}, \type{repeatAtLeast}, and \type{repeatAtMost}). Hence, we 
implement primitive jPeg \type{parseWhile} and \type{parseUntil} words 
from which Chu's Pratt Parser \type{ParseUntil} can be built. 

Given these new jPeg privitives, we can then build joylol words which 
implement a more comprehensive Pratt Parser similar to the praser outlined 
by Chu, \cite{chu2016prattParsing} and \cite{chu2016prattParsingGitHub}. 

\startTestSuite[registerNullDenotation and lookupNullDenotation]

\startCHeader
void jPegRegisterNullDenotation(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegRegisterNullDenotation(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  popCtxDataInto(aCtx, name2register);
  popCtxDataInto(aCtx, nudList);

  if (!isSymbolObj(name2register)) {
    raiseExceptionMsg(aCtx,
      "register null denotation requires a symbol as top");
    return;
  }

  if (!isPairObj(nudList)) {
    raiseExceptionMsg(aCtx,
      "register null denotation requires a list as second");
    return;
  }

  // ensure nudList has correct constituents
  if (listLength(nudList) != 2) {
    raiseExceptionMsg(aCtx,
      "register null denotation requires a list with two elements");
    return;    
  }
  
  JObj *firstElement = getNthElement(nudList, 0);
  if (!isSymbolObj(firstElement) && !isCFunctionObj(firstElement)) {
    raiseExceptionMsg(aCtx,
      "register null denotation requires a function as first element");
    return;    
  }

  JObj *secondElement = getNthElement(nudList, 1);
  if (!isUIntegerObj(secondElement)) {
    raiseExceptionMsg(aCtx,
      "register null denotation requires a uInteger as second element");
    return;    
  }

  if (!asParserNuds(aCtx)) reinitializeParser(aCtx, "default");
  SymbolTableObj *nuds = asParserNuds(aCtx);
  insertSymbol(nuds, asSymbol(name2register), nudList);
}
\stopCCode

\startCHeader
void jPegLookupNullDenotation(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegLookupNullDenotation(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  popCtxDataInto(aCtx, name2lookup);

  if (!isSymbolObj(name2lookup)) {
    raiseExceptionMsg(aCtx,
      "lookupNullDenotation requires a symbol as top");
    return;
  }

  if (!asParserNuds(aCtx)) reinitializeParser(aCtx, "default");
  SymbolTableObj *nuds = asParserNuds(aCtx);
  pushCtxData(aCtx, findSymbol(nuds, asSymbol(name2lookup)));
}
\stopCCode

\startTestCase[should be able to register and lookup a null denotation]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushUIntegerCtxData(aCtx, 200);
  pushSymbolCtxData(aCtx, "testNud");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "~");
  jPegRegisterNullDenotation(aCtx);
  AssertPtrNull(aCtx->data);
  
  pushSymbolCtxData(aCtx, "~");
  jPegLookupNullDenotation(aCtx);
  popCtxDataInto(aCtx, nudList);
  AssertIntTrue(isPairObj(nudList));
  AssertIntEquals(listLength(nudList), 2);
  JObj *firstElement = getNthElement(nudList, 0);
  AssertIntTrue(isSymbolObj(firstElement));
  AssertStrEquals(asSymbol(firstElement), "testNud");
  JObj *secondElement = getNthElement(nudList, 1);
  AssertIntTrue(isUIntegerObj(secondElement));
  AssertIntEquals(asUInteger(secondElement), 200);
\stopCTest
\stopTestCase
\stopTestSuite
