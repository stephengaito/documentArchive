% A ConTeXt document [master document: ../jInterp.tex ]

\subsection[title=Operator Precedence Parsing] 

We base our implementation of Operator Precedence Parsing on Andy Chu's 
excellent exposition of Pratt Parsing, \cite{chu2016prattParsing} and 
\cite{chu2016prattParsingGitHub}. 

Quoting Chu:

\startBlockQuote

To me, these are its [Pratt Parsing's] salient characteristics: 

\startitemize[n]

\item It's mutually recursive between a core \type{parse(int rbp)} 
function and \type{nud()} and \type{led()} \quote{plugin functions} for 
each operator. In my code, these are the \type{p.ParseUntil(int 
precedence)} method, and \type{Null*()} and \type{Left*()} functions. 

\item Many recursive algorithms like tree traversal are purely functional. 
In contrast, Pratt parsing has the property that the recursive procedures 
also mutate state, i.e. the current token. This is just like recursive 
descent parsing, which is one reason they go together well. 

\stopitemize
\stopBlockQuote

In our case our \quote{parser} (\quote{context}) state is maintained in 
the jPeg context. We add nud (null denotation) and led (left denotaiton) 
dictionaries to contain references to the \quote{plugin functions} 
(denotations) for each operator. 

We implement \type{lookupLeftDenotation} and \type{lookupNullDenotation} 
jPeg words as well as corresponding \type{registerLeftDenotation} and 
\type{registerNullDenotation} joylol words to lookup and register left and 
null denotations respectively. 

Chu's Pratt Parser's \type{ParseUntil} function, is really a 
\type{parseUntil} structure similar to the existing jPeg repeat structures 
(\type{repeat}, \type{repeatAtLeast}, and \type{repeatAtMost}). Hence, we 
implement primitive jPeg \type{parseWhile} and \type{parseUntil} words 
from which Chu's Pratt Parser \type{ParseUntil} can be built. 

Given these new jPeg privitives, we can then build joylol words which 
implement a more comprehensive Pratt Parser similar to the praser outlined 
by Chu, \cite{chu2016prattParsing} and \cite{chu2016prattParsingGitHub}. 

\startTestSuite[registerNullDenotation and lookupNullDenotation]

\startCHeader
void jPegRegisterNullDenotation(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegRegisterNullDenotation(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  popCtxDataInto(aCtx, name2register);
  popCtxDataInto(aCtx, nudList);

  if (!isSymbolObj(name2register)) {
    raiseExceptionMsg(aCtx,
      "register null denotation requires a symbol as top");
    return;
  }

  if (!isPairObj(nudList)) {
    raiseExceptionMsg(aCtx,
      "register null denotation requires a list as second");
    return;
  }

  // ensure nudList has correct constituents
  if (listLength(nudList) != 2) {
    raiseExceptionMsg(aCtx,
      "register null denotation requires a list with two elements");
    return;    
  }
  
  JObj *firstElement = getNthElement(nudList, 0);
  if (!isSymbolObj(firstElement) &&
      !isCFunctionObj(firstElement) &&
      !isPairObj(firstElement)) {
    raiseExceptionMsg(aCtx,
      "register null denotation requires a function as first element");
    return;    
  }

  JObj *secondElement = getNthElement(nudList, 1);
  if (!isUIntegerObj(secondElement)) {
    raiseExceptionMsg(aCtx,
      "register null denotation requires a uInteger as second element");
    return;    
  }

  if (!asParserNuds(aCtx)) reinitializeParser(aCtx, "default");
  SymbolTableObj *nuds = asParserNuds(aCtx);
  insertSymbol(nuds, asSymbol(name2register), nudList);
}
\stopCCode

\startCHeader
#define jPegLookupNullDenotationFunc(aCtx, name2lookup) \
  findSymbol(asParserNuds(aCtx), asSymbol(name2lookup))

void jPegLookupNullDenotation(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegLookupNullDenotation(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  popCtxDataInto(aCtx, name2lookup);

  if (!isSymbolObj(name2lookup)) {
    raiseExceptionMsg(aCtx,
      "lookupNullDenotation requires a symbol as top");
    return;
  }

  if (!asParserNuds(aCtx)) reinitializeParser(aCtx, "default");
  pushCtxData(aCtx, jPegLookupNullDenotationFunc(aCtx, name2lookup));
}
\stopCCode

\startTestCase[should be able to register and lookup a null denotation]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushUIntegerCtxData(aCtx, 200);
  pushSymbolCtxData(aCtx, "testNud");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "~");
  jPegRegisterNullDenotation(aCtx);
  AssertPtrNull(aCtx->data);
  
  pushSymbolCtxData(aCtx, "~");
  jPegLookupNullDenotation(aCtx);
  popCtxDataInto(aCtx, nudList);
  AssertIntTrue(isPairObj(nudList));
  AssertIntEquals(listLength(nudList), 2);
  JObj *firstElement = getNthElement(nudList, 0);
  AssertIntTrue(isSymbolObj(firstElement));
  AssertStrEquals(asSymbol(firstElement), "testNud");
  JObj *secondElement = getNthElement(nudList, 1);
  AssertIntTrue(isUIntegerObj(secondElement));
  AssertIntEquals(asUInteger(secondElement), 200);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[registerLeftDenotation and lookupLeftDenotation]

\startCHeader
void jPegRegisterLeftDenotation(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegRegisterLeftDenotation(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  popCtxDataInto(aCtx, name2register);
  popCtxDataInto(aCtx, ledList);

  if (!isSymbolObj(name2register)) {
    raiseExceptionMsg(aCtx,
      "register left denotation requires a symbol as top");
    return;
  }

  if (!isPairObj(ledList)) {
    raiseExceptionMsg(aCtx,
      "register left denotation requires a list as second");
    return;
  }

  // ensure nudList has correct constituents
  if (listLength(ledList) != 3) {
    raiseExceptionMsg(aCtx,
      "register left denotation requires a list with two elements");
    return;    
  }
  
  JObj *firstElement = getNthElement(ledList, 0);
  if (!isSymbolObj(firstElement) &&
      !isCFunctionObj(firstElement) &&
      !isPairObj(firstElement)) {
    raiseExceptionMsg(aCtx,
      "register left denotation requires a function as first element");
    return;    
  }

  JObj *secondElement = getNthElement(ledList, 1);
  if (!isUIntegerObj(secondElement)) {
    raiseExceptionMsg(aCtx,
      "register left denotation requires a uInteger as second element");
    return;    
  }

  JObj *thirdElement = getNthElement(ledList, 2);
  if (!isUIntegerObj(thirdElement)) {
    raiseExceptionMsg(aCtx,
      "register left denotation requires a uInteger as third element");
    return;    
  }

  if (!asParserLeds(aCtx)) reinitializeParser(aCtx, "default");
  SymbolTableObj *leds = asParserLeds(aCtx);
  insertSymbol(leds, asSymbol(name2register), ledList);
}
\stopCCode

\startCHeader
#define jPegLookupLeftDenotationFunc(aCtx, name2lookup)  \
  findSymbol(asParserLeds(aCtx), asSymbol(name2lookup))

void jPegLookupLeftDenotation(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegLookupLeftDenotation(ContextObj *aCtx) {
  assert(isContextObj(aCtx));

  popCtxDataInto(aCtx, name2lookup);

  if (!isSymbolObj(name2lookup)) {
    raiseExceptionMsg(aCtx,
      "lookupLeftDenotation requires a symbol as top");
    return;
  }

  if (!asParserLeds(aCtx)) reinitializeParser(aCtx, "default");
  pushCtxData(aCtx, jPegLookupLeftDenotationFunc(aCtx, name2lookup));
}
\stopCCode

\startTestCase[should be able to register and lookup a left denotation]

\startCTest
  ContextObj *aCtx = newContext(NULL, NULL, "testParser");
  AssertIntTrue(isContextObj(aCtx));
  
  registerBasicWords(aCtx);
  registerControlWords(aCtx);
  registerJPegWords(aCtx);
  
  pushUIntegerCtxData(aCtx, 201);
  pushUIntegerCtxData(aCtx, 200);
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "testLed");
  prependWord(aCtx);
  pushSymbolCtxData(aCtx, "+");
  jPegRegisterLeftDenotation(aCtx);
  AssertPtrNull(aCtx->data);
  
  pushSymbolCtxData(aCtx, "+");
  jPegLookupLeftDenotation(aCtx);
  popCtxDataInto(aCtx, ledList);
  AssertIntTrue(isPairObj(ledList));
  AssertIntEquals(listLength(ledList), 3);
  JObj *firstElement = getNthElement(ledList, 0);
  AssertIntTrue(isSymbolObj(firstElement));
  AssertStrEquals(asSymbol(firstElement), "testLed");
  JObj *secondElement = getNthElement(ledList, 1);
  AssertIntTrue(isUIntegerObj(secondElement));
  AssertIntEquals(asUInteger(secondElement), 200);
  JObj *thirdElement = getNthElement(ledList, 2);
  AssertIntTrue(isUIntegerObj(thirdElement));
  AssertIntEquals(asUInteger(thirdElement), 201);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[parseExpression]

\startCHeader
void jPegParseNullExpressionContinue(ContextObj *aCtx);
void jPegParseLeftExpressionContinue(ContextObj *aCtx);
void jPegParseExpression(ContextObj *aCtx);
\stopCHeader

\startCCode
void jPegParseNullExpressionContinue(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxProcessInto(aCtx, rightBindingPrecedence);
  popCtxProcessInto(aCtx, tokenizer);
  popCtxProcessInto(aCtx, backTrackPosition);
  peekCtxDataInto(aCtx, token);
  
  // token SHOULD be a symbol... how do we fail if it isn't???
  
  JObj *nudList = jPegLookupNullDenotationFunc(aCtx, token);
  getNthElementInto(nudList, 0, nudFunction);
  getNthElementInto(nudList, 1, bindingPrecedence);
  pushCtxData(aCtx, bindingPrecedence);
  // token is already now on the second
  pushCtxProcess(aCtx, nudFunction);
}

void jPegParseLeftExpressionContinue(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  
}

void jPegParseExpression(ContextObj *aCtx) {
  assert(isContextObj(aCtx));
  
  popCtxDataInto(aCtx, parseExpList);
  
  getNthElementInto(aCtx, 0, tokenizer);
  getNthElementInto(aCtx, 1, rightBindingPrecedence);
  
  if (!isSymbolObj(tokenizer) &&
      !isCFunctionObj(tokenizer) &&
      !isPairObj(tokenizer)) {
    raiseExceptionMsg(aCtx,
      "parse expression requires a function as top");
    return;
  }

  if (!isUIntegerObj(rightBindingPrecedence)) {
    raiseExceptionMsg(aCtx,
      "parse expression requires a UInteger as second");
    return;
  }
  
  // ToDo: how do we deal with failure?!?!?!?
  // such as end of input?
  
  // asParserFailed(aCtx) = true;
  
  pushUIntegerCtxProcess(aCtx, asParserTextPosition(aCtx));
  pushCtxProcess(aCtx, tokenizer);
  pushCtxProcess(aCtx, righBindingPrecedence);
  pushSymbolCtxProcess(aCtx, "parseNullExpressionCont");
  
  if (isPairObj(tokenizer)) prependListCtxProcess(aCtx, tokenizer)
  else pushCtxProcess(aCtx, tokenizer)
}
\stopCCode

\startTextCase[should]

\startCTest

\stopCTest
\stopTestCase
\stopTestSuite
