% A ConTeXt document [master document: joyLoLMinus.tex ]

\subsection[title=Symbol Table]

\setCHeaderStream{public}
\startCHeader
typedef struct symbolEntry_struct {
  Symbol *symbol;
  JObj   *jObj;
} SymbolEntry;

typedef struct symbolTable_struct {
  size_t       tag;
  SymbolEntry *symbols;
  size_t       numSymbols;
  size_t       maxSymbols;
  Symbol      *name;
} SymbolTableObj;

#define SymbolTable_GrowthSize 10

SymbolTableObj *newSymbolTable(Symbol *name);

JObj *findSymbol(
  SymbolTableObj *aTable,
  Symbol         *aSymbol
);

void insertSymbol(
  SymbolTableObj *aTable,
  Symbol         *aSymbol,
  JObj *anObj
);

void deleteSymbol(
  SymbolTableObj *aTable,
  Symbol         *aSymbol
);
void printTableToFile(
  SymbolTableObj *aTable,
  FILE           *aFile,
  Symbol         *indent
);

void registerCFunction(
  SymbolTableObj *aTable,
  Symbol         *symbol,
  CFunction      *func
);

void registerCtxCFunction(
  SymbolTableObj *aTable,
  Symbol         *symbol,
  CtxCFunction   *func
);

void symbolTablePrinter(JObj *anObj, Symbol *indent, size_t timeToLive);

#define isSymbolTableObj(anObj) \
  ((anObj) && ((((JObj*)(anObj))->tag) == SymbolTableTag))
#define asSymbolTableObj(anObj) ((SymbolTableObj*)(anObj))
\stopCHeader

\startCCode
SymbolTableObj *newSymbolTable(Symbol *name) {
  SymbolTableObj *newTable =
    (SymbolTableObj*)calloc(1, sizeof(SymbolTableObj));
  assert(newTable);
  newTable->tag        = SymbolTableTag;
  newTable->symbols    = NULL;
  newTable->numSymbols = 0;
  newTable->maxSymbols = 0;
  newTable->name       = strdup(name);
  return newTable;
}

size_t findSymbolIndex(SymbolTableObj *aTable,  Symbol *aSymbol) {
  assert(aTable);
  assert(aSymbol);
  
  size_t firstIndex = 0;
  size_t lastIndex  = aTable->numSymbols;
  
  while(1) {
    assert(0 <= firstIndex);
    assert(firstIndex <= lastIndex);
    assert(lastIndex  <= aTable->maxSymbols);
    
    if (firstIndex == lastIndex) {
      return firstIndex;
    } else if (firstIndex + 1 == lastIndex) {
      int cmp = strcmp(aTable->symbols[firstIndex].symbol, aSymbol);
      if (0 <= cmp) {
        return firstIndex;
      } else {
        return lastIndex;
      }
    } else {
      size_t probeIndex = (firstIndex + lastIndex) >> 1; // divide by two
      assert(firstIndex <= probeIndex);
      assert(probeIndex <= lastIndex);
      int cmp = strcmp(aTable->symbols[probeIndex].symbol, aSymbol);
      if (cmp == 0) {
        return probeIndex;
      } else if (cmp < 0) {
        firstIndex = probeIndex;
      } else {
        lastIndex = probeIndex;
      }
    }
  }  
}

JObj *findSymbol(SymbolTableObj *aTable, Symbol *aSymbol) {  
  assert(aTable);
  assert(aSymbol);
  
  size_t symbolIndex = findSymbolIndex(aTable, aSymbol);
  assert(0 <= symbolIndex);
  assert(symbolIndex <= aTable->numSymbols);
  assert(symbolIndex <= aTable->maxSymbols);
    
  if (symbolIndex == aTable->numSymbols) return NULL;
  
  int cmp = strcmp(aTable->symbols[symbolIndex].symbol, aSymbol);
  
  if (cmp != 0) return NULL;
  
  return aTable->symbols[symbolIndex].jObj;
}

void increaseMaxSymbols(SymbolTableObj *aTable) {
  assert(aTable);
  SymbolEntry *oldSymbols = aTable->symbols;
  size_t newMaxSymbols    = aTable->maxSymbols + SymbolTable_GrowthSize;
  SymbolEntry *newSymbols =
    (SymbolEntry*)calloc(newMaxSymbols, sizeof(SymbolEntry));
  assert(newSymbols);
  if (oldSymbols) {
    memcpy(
      newSymbols,
      oldSymbols,
      ((aTable->maxSymbols) * sizeof(SymbolEntry))
    );
    free(oldSymbols);
    oldSymbols = NULL;
  }
  aTable->symbols    = newSymbols;
  aTable->maxSymbols = newMaxSymbols;
  assert(aTable->symbols);
  assert(aTable->numSymbols <= aTable->maxSymbols);
}

void insertSymbol(SymbolTableObj *aTable, Symbol *aSymbol, JObj *anObj) {
  assert(aTable);
  assert(aSymbol);
  
  size_t symbolIndex = findSymbolIndex(aTable, aSymbol);
  assert(0 <= symbolIndex);
  assert(symbolIndex <= aTable->numSymbols);
  assert(symbolIndex <= aTable->maxSymbols);
  
  DEBUG(DebugMask,
    "insertSymbol: index: %zd  num: %zd max: %zd\n",
    symbolIndex,
    aTable->numSymbols,
    aTable->maxSymbols
  );
  DEBUG(DebugMask,
    "insertSymbol: inserting: [%s]<%s>: %p\n",
    aSymbol,
    getJObjName(anObj),
    anObj
  );
  if (symbolIndex < aTable->numSymbols) {
    DEBUG(DebugMask,
      "insertSymbol: found: [%s]\n",
      aTable->symbols[symbolIndex].symbol
    );
  } else {
    DEBUG(DebugMask, "%s", "insertSymbol: found: no symbols\n");
  }
  
  if (symbolIndex == aTable->numSymbols) {
    if (aTable->maxSymbols <= aTable->numSymbols) increaseMaxSymbols(aTable);
    aTable->symbols[aTable->numSymbols].symbol = strdup(aSymbol);
    aTable->symbols[aTable->numSymbols].jObj   = anObj;
    aTable->numSymbols++;
    assert(aTable->numSymbols <= aTable->maxSymbols);
    return;
  }
  
  int cmp = strcmp(aTable->symbols[symbolIndex].symbol, aSymbol);
  assert(0 <= cmp);
  if (cmp == 0) return; // symbol has already been inserted
  if (cmp != 0) { // aSymbol is less than the current index.. so make space
    if (aTable->maxSymbols <= aTable->numSymbols) increaseMaxSymbols(aTable);
    SymbolEntry *newSymbol = aTable->symbols + aTable->numSymbols;
    SymbolEntry *curSymbol = newSymbol - 1;
    SymbolEntry *insSymbol = aTable->symbols + symbolIndex;
    for (; insSymbol < newSymbol ; ) {
      newSymbol->symbol = curSymbol->symbol;
      newSymbol->jObj   = curSymbol->jObj;
      newSymbol--;
      curSymbol--;
    }
  }
  aTable->symbols[symbolIndex].symbol = strdup(aSymbol);
  aTable->symbols[symbolIndex].jObj   = anObj;
  aTable->numSymbols++;
  assert(aTable->numSymbols <= aTable->maxSymbols);
}

void deleteSymbol(SymbolTableObj *aTable, Symbol *aSymbol) {
  assert(aTable);
  assert(aSymbol);
  
  size_t symbolIndex = findSymbolIndex(aTable, aSymbol);
  assert(0 <= symbolIndex);
  assert(symbolIndex <= aTable->numSymbols);
  assert(symbolIndex <= aTable->maxSymbols);

  if (symbolIndex == aTable->numSymbols) return; // nothing to delete
  
  int cmp = strcmp(aTable->symbols[symbolIndex].symbol, aSymbol);
  if (cmp != 0) return; // nothing to delete
  SymbolEntry *newSymbol = aTable->symbols + symbolIndex;
  SymbolEntry *curSymbol = newSymbol + 1;
  SymbolEntry *lastSymbol = aTable->symbols + aTable->numSymbols;
  for (; curSymbol < lastSymbol ; ) {
    newSymbol->symbol = curSymbol->symbol;
    newSymbol->jObj   = curSymbol->jObj;
    newSymbol++;
    curSymbol++;
  }
  aTable->symbols[aTable->numSymbols].symbol = NULL;
  aTable->numSymbols--;
  assert(0 <= aTable->numSymbols);
}

void symbolTablePrinter(
  JObj   *anObj,
  Symbol *indent,
  size_t  timeToLive
) {
  DEBUG(DebugMask, "symbolTablePrinter %p\n", anObj);
  assert(isSymbolTableObj(anObj));
  
  SymbolTableObj *aTable = asSymbolTableObj(anObj);
  
  char* newIndent = appendSymbols(indent, "  ");
  for( size_t i = 0; i < aTable->numSymbols; i++) {
    printf(
      "%ssymTab[%zd] = [%s]\n",
      indent,
      i,
      aTable->symbols[i].symbol
    );
    printJObj(
      aTable->symbols[i].jObj,
      newIndent,
      timeToLive
    );
  }
  free(newIndent);
}

void registerCFunction(
  SymbolTableObj *aTable,
  Symbol         *symbol,
  CFunction      *func
) {
  assert(aTable);
  assert(symbol);
  assert(func);
  
  CFunctionObj *newObj = newCFunction(func);
  insertSymbol(aTable, symbol, asJObj(newObj));
}

void registerCtxCFunction(
  SymbolTableObj *aTable,
  Symbol         *symbol,
  CtxCFunction   *func
) {
  assert(aTable);
  assert(symbol);
  assert(func);
  
  CtxCFunctionObj *newObj = newCtxCFunction(func);
  insertSymbol(aTable, symbol, asJObj(newObj));
}

\stopCCode

