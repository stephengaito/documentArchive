% A ConTeXt document [master document: jInterps.tex]

\section[title=Overview]

The whole of the JoyLoL language is oriented around the concept of lists. 
For \emph{pure} JoyLoL, all CoAlgebras are implemented directly as lists 
of lists. \emph{The only things there are, in \emph{pure} JoyLoL, are 
lists}. 

For the \emph{impure} version of JoyLoL, provided in this release, we 
permit the existence of CoAlgebras which are implemented using 
computational structures related to the underlying computer architecture 
upon which the JoyLoL interpreter is running. Potentially, impure versions 
of JoyLoL might run faster. However the cost of greater performance is the 
greater possibility that the underlying implementation might not be as 
rigorously proven correct as a pure version of JoyLoL. Equally 
importantly, \emph{impure} versions of JoyLoL, allow, \quote{a bear of 
little brain}, like myself, to think in terms of higher level concepts 
while programming the fundamental algorithms in the theory associated with 
JoyLoL. 

Since no general purpose computer processor is designed as a pure list 
processor, \emph{any implementation} of JoyLoL (pure or impure) will of 
necessity contain non-list code which is used to \emph{implement} lists. 
The purpose of this CoAlgebraic extension is to provide as simple and 
transparent an implementation of lists as possible. 

In fact, \emph{this} (core) CoAlgebraic extension does not actually 
implement lists. The implementation of lists is reserved for the 
\type{Pairs} CoAlgebraic extension developed in a separate document. 

This \type{CoAlgs} CoAlgebraic extension provides the infrastructure with 
which to both organize the currently loaded collection of CoAlgebras, as 
well as provide \type{CoAlgObj}s which represent individual instances 
of any loaded CoAlgebra. Of particular importance is that these 
\type{CoAlgObj}s are automatically garbage collected. 

The CoAlgebras \quote{extension} provides the basis upon which the whole 
of the JoyLoL implementation is built. It provides a first class 
interface. 

\setCHeaderStream{public}

We begin our implementation by pre-defining the three most important 
structures. We need to pre-define them here, since these three structures 
are mutually recursive. 

\startitemize

\item A \type{JoyLoLInterp} represents the JoyLoL interpreter. It includes 
the collection of all loaded CoAlgebraic extensions, as well as the object 
memory. 

\startCHeader 
typedef struct joylol_interpreter_struct JoyLoLInterp;
\stopCHeader 

\item A \type{CoAlgebra} represents the standard (class) data and (class 
or instance) methods associated with the implementation of a CoAlgebraic 
extension. 

\startCHeader
typedef struct coalgebra_struct CoAlgebra;
\stopCHeader

\item A \type{CoAlgObj} represents a relatively opaque object to one of 
many possible \emph{instances} of a CoAlgebra. 

\startCHeader
typedef struct coalgebra_object_struct CoAlgObj;
\stopCHeader 
\stopitemize

The memory extension provides a first class JoyLoL implementation of 
\quote{memory}. A memory block has:

\startitemize

\item a size

\item an item size

\item a next item

\item a full indicator

\stopitemize

Things you can do with a memory block:

\startitemize

\item get a new item

\item get a new block

\stopitemize

%\startJFrame

The lists extension is the core JoyLoL extension. It provides the core 
lists of lists structures. It \emph{only} provides the most basic JoyLoL 
expressions. It has no ability to preform any computation other than to 
build up List of Lists structures. 

I suggest we use [generational garbage 
collection](http://wiki.c2.com/?GenerationalGarbageCollection) together 
with immutable objects so that objects in more recent "heaps" can only 
point to older "heaps" and not visa versa. This means that, if the 
individual "heaps" are first class Lua objects, then we can use the 
finalization of the heap object to ["stop and 
copy"](http://wiki.c2.com/?StopAndCopy) live JoyLoL objects into older 
heaps just before the newer heap is reclaimed by the Lua GC. Essentially 
we are letting the Lua GC drive the JoyLoL GC. 

%\stopJFrame

%\startsyntax

%\stopsyntax 

%\startinitialization

%\stopinitialization


\subsection[title=Required CoAlgebraic extensions]

For any given (impure) implementation of a JoyLoL interpreter, there will 
be a collection of CoAlgebraic extensions \emph{required} for the 
interpreter to function. By listing this collection of required 
extensions, we can give each one a unique and well known integer 
identifier, which can be used in the running code to quickly verify the 
class type of a given \type{CoAlgObj}. 

The required extensions for this implementation is:

\setCHeaderStream{public}
\startCHeader
#define UnusedTag         0
#define JInterpsTag       1
#define BooleansTag       2
#define CFunctionsTag     3
#define ContextsTag       4
#define DictionariesTag   5
#define LuaFunctionsTag   6
#define NaturalsTag       7
#define PairsTag          8
#define ParsersTag        9
#define SymbolsTag        10
#define TemplatesTag      11
#define TextsTag          12
#define NumRequiredCoAlgs 13

#define JInterpsName      "JoyLoLInterps"
#define BooleansName      "Booleans"
#define CFunctionsName    "CFunctions"
#define ContextsName      "Contexts"
#define DictionariesName  "Dictionaries"
#define LuaFunctionsName  "LuaFunctions"
#define NaturalsName      "Naturals"
#define PairsName         "Pairs"
#define ParsersName       "Parsers"
#define SymbolsName       "Symbols"
#define TemplatesName     "Templates"
#define TextsName         "Texts"
\stopCHeader

Since each CoAlgebraic extension can be developed separately, we need to 
ensure there is a strict \emph{semantic} version control. We use the 
\type{CoAlgVersion} structure to contain the corresponding Major, Minor, 
and Patch version numbers for a given extension. Since our JoyLoL 
interpreter might depend upon specific aspects of extension's the 
\quote{Application Programming Interface} (API), our list of required 
extensions, below, also contains the minimum required compatible version 
of the extension. 

\startCHeader
// see: http://semver.org/
//
typedef struct coalg_version_struct {
  size_t major;
  size_t minor;
  size_t patch;
} CoAlgVersion;
\stopCHeader

When each CoAlgebraic extension is registered, its name is compared to the 
following list of required extensions. If a match is found then the 
corresponding (and well known) index is used to store a pointer to the 
\type{CoAlgebra} structure for the given extension. If a match is found 
the extension's current version is compared to the minimally required 
version. The registration of the extension is only accepted if these 
versions are compatible. 

\setCCodeStream{interpreter}
\startCCode
typedef struct required_coalgs_struct {
  const char*  name;
  size_t       tag;
  CoAlgVersion version;
} RequiredCoAlgs;

RequiredCoAlgs requiredCoAlgs[] = {
  { JInterpsName,     JInterpsTag,     {0, 1, 0 }},
  { BooleansName,     BooleansTag,     {0, 1, 0 }},
  { CFunctionsName,   CFunctionsTag,   {0, 1, 0 }},
  { ContextsName,     ContextsTag,     {0, 1, 0 }},
  { DictionariesName, DictionariesTag, {0, 1, 0 }},
  { LuaFunctionsName, LuaFunctionsTag, {0, 1, 0 }},
  { NaturalsName,     NaturalsTag,     {0, 1, 0 }},
  { PairsName,        PairsTag,        {0, 1, 0 }},
  { ParsersName,      ParsersTag,      {0, 1, 0 }},
  { SymbolsName,      SymbolsTag,      {0, 1, 0 }},
  { TemplatesName,    TemplatesTag,    {0, 1, 0 }},
  { TextsName,        TextsTag,        {0, 1, 0 }},
  { NULL,             0,               {0, 0, 0 }}
};
\stopCCode

Finally we provide a number of semi-standard typdefs to provide a semantic 
meaning to various typical variable uses. 

\startCHeader
typedef size_t     Boolean;
typedef const char Symbol;
\stopCHeader