% A ConTeXt document [master document: jInterps.tex]

\section[title=Overview]

The whole of the JoyLoL language is oriented around the concept of lists. 
For \emph{pure} JoyLoL, all CoAlgebras are implemented directly as lists 
of lists. \emph{The only things there are, in \emph{pure} JoyLoL, are 
lists}. 

For the \emph{impure} version of JoyLoL, provided in this release, we 
permit the existence of CoAlgebras which are implemented using 
computational structures related to the underlying computer architecture 
upon which the JoyLoL interpreter is running. Potentially, impure versions 
of JoyLoL might run faster. However the cost of greater performance is the 
greater possibility that the underlying implementation might not be as 
rigorously proven correct as a pure version of JoyLoL. Equally 
importantly, \emph{impure} versions of JoyLoL, allow, \quote{a bear of 
little brain}, like myself, to think in terms of higher level concepts 
while programming the fundamental algorithms in the theory associated with 
JoyLoL. 

Since no general purpose computer processor is designed as a pure list 
processor, \emph{any implementation} of JoyLoL (pure or impure) will of 
necessity contain non-list code which is used to \emph{implement} lists. 
The purpose of this CoAlgebraic extension is to provide as simple and 
transparent an implementation of lists as possible. 

In fact, \emph{this} (core) CoAlgebraic extension does not actually 
implement lists. The implementation of lists is reserved for the 
\type{Pairs} CoAlgebraic extension developed in a separate document. 

This \type{CoAlgs} CoAlgebraic extension provides the infrastructure with 
which to both organize the currently loaded collection of CoAlgebras, as 
well as provide \type{JObj}s which represent individual instances 
of any loaded CoAlgebra. Of particular importance is that these 
\type{JObj}s are automatically garbage collected. 

The CoAlgebras \quote{extension} provides the basis upon which the whole 
of the JoyLoL implementation is built. It provides a first class 
interface. 

\setCHeaderStream{public}

We begin our implementation by pre-defining the three most important 
structures. We need to pre-define them here, since these three structures 
are mutually recursive. 

\startitemize

\item A \type{JoyLoLInterp} represents the JoyLoL interpreter. It includes 
the collection of all loaded CoAlgebraic extensions, as well as the object 
memory. 

\startCHeader 
typedef struct joylol_interpreter_struct JoyLoLInterp;
\stopCHeader 

\item A \type{CoAlgebra} represents the standard (class) data and (class 
or instance) methods associated with the implementation of a CoAlgebraic 
extension. 

\startCHeader
typedef struct joylol_class_struct JClass;
\stopCHeader

\item A \type{JObj} represents a relatively opaque object to one of 
many possible \emph{instances} of a CoAlgebra. 

\startCHeader
typedef struct joylol_object_struct JObj;
\stopCHeader 
\stopitemize

The memory extension provides a first class JoyLoL implementation of 
\quote{memory}. A memory block has:

\startitemize

\item a size

\item an item size

\item a next item

\item a full indicator

\stopitemize

Things you can do with a memory block:

\startitemize

\item get a new item

\item get a new block

\stopitemize

The lists extension is the core JoyLoL extension. It provides the core 
lists of lists structures. It \emph{only} provides the most basic JoyLoL 
expressions. It has no ability to preform any computation other than to 
build up List of Lists structures. 

I suggest we use [generational garbage 
collection](http://wiki.c2.com/?GenerationalGarbageCollection) together 
with immutable objects so that objects in more recent "heaps" can only 
point to older "heaps" and not visa versa. This means that, if the 
individual "heaps" are first class Lua objects, then we can use the 
finalization of the heap object to ["stop and 
copy"](http://wiki.c2.com/?StopAndCopy) live JoyLoL objects into older 
heaps just before the newer heap is reclaimed by the Lua GC. Essentially 
we are letting the Lua GC drive the JoyLoL GC. 

\subsection[title=Required CoAlgebraic extensions]

For any given (impure) implementation of a JoyLoL interpreter, there will 
be a collection of CoAlgebraic extensions \emph{required} for the 
interpreter to function. By listing this collection of required 
extensions, we can give each one a unique and well known integer 
identifier, which can be used in the running code to quickly verify the 
class type of a given \type{JObj}. 

Listed in the order in which they must be initialized, the required 
extensions for this implementation are: 

\setCHeaderStream{public}
\startCHeader
#define UnusedTag          0
#define JInterpsTag        1
#define DictionariesTag    2
#define BooleansTag        3
#define CFunctionsTag      4
#define CoAlgebrasTag      5
#define ContextsTag        6
#define CrossCompilersTag  7
#define DictNodesTag       8
#define FragmentsTag       9
#define LoadersTag        10
#define LuaFunctionsTag   11
#define NaturalsTag       12
#define PairsTag          13
#define ParsersTag        14
#define StringBuffersTag  15
#define SymbolsTag        16
#define TemplatesTag      17
#define TextsTag          18
#define NumRequiredCoAlgs 19

#define JInterpsName       "jInterps"       /*  1 */
#define DictionariesName   "dictionaries"   /*  2 */
#define BooleansName       "booleans"       /*  3 */
#define CFunctionsName     "cFunctions"     /*  4 */
#define CoAlgebrasName     "coAlgebras"     /*  5 */
#define ContextsName       "contexts"       /*  6 */
#define CrossCompilersName "crossCompilers" /*  7 */
#define DictNodesName      "dictNodes"      /*  8 */
#define FragmentsName      "fragments"      /*  9 */
#define LoadersName        "loaders"        /* 10 */
#define LuaFunctionsName   "luaFunctions"   /* 11 */
#define NaturalsName       "naturals"       /* 12 */
#define PairsName          "pairs"          /* 13 */
#define ParsersName        "parsers"        /* 14 */
#define StringBuffersName  "stringBuffers"  /* 15 */
#define SymbolsName        "symbols"        /* 16 */
#define TemplatesName      "templates"      /* 17 */
#define TextsName          "texts"          /* 18 */
\stopCHeader

Since each CoAlgebraic extension can be developed separately, we need to 
ensure there is a strict \emph{semantic} version control. We use the 
\type{CoAlgVersion} structure to contain the corresponding Major, Minor, 
and Patch version numbers for a given extension. Since our JoyLoL 
interpreter might depend upon specific aspects of extension's the 
\quote{Application Programming Interface} (API), our list of required 
extensions, below, also contains the minimum required compatible version 
of the extension. 

\startCHeader
// see: http://semver.org/
//
typedef struct coalg_version_struct {
  size_t major;
  size_t minor;
  size_t patch;
} CoAlgVersion;
\stopCHeader

When each CoAlgebraic extension is registered, its name is compared to the 
following list of required extensions. If a match is found then the 
corresponding (and well known) index is used to store a pointer to the 
\type{CoAlgebra} structure for the given extension. If a match is found 
the extension's current version is compared to the minimally required 
version. The registration of the extension is only accepted if these 
versions are compatible. 

\setCHeaderStream{private}
\startCHeader
typedef struct required_objects_struct {
  const char*  name;
  size_t       tag;
  CoAlgVersion version;
} RequiredObjects;

extern RequiredObjects requiredCoAlgs[];
\stopCHeader
\setCHeaderStream{public}

\setCCodeStream{interpreter}
\startCCode
RequiredObjects requiredCoAlgs[] = {
  { JInterpsName,       JInterpsTag,       {0, 1, 0 }}, //  1
  { DictionariesName,   DictionariesTag,   {0, 1, 0 }}, //  2
  { BooleansName,       BooleansTag,       {0, 1, 0 }}, //  3
  { CFunctionsName,     CFunctionsTag,     {0, 1, 0 }}, //  4
  { CoAlgebrasName,     CoAlgebrasTag,     {0, 1, 0 }}, //  5
  { ContextsName,       ContextsTag,       {0, 1, 0 }}, //  6
  { CrossCompilersName, CrossCompilersTag, {0, 1, 0 }}, //  7
  { DictNodesName,      DictNodesTag,      {0, 1, 0 }}, //  8
  { FragmentsName,      FragmentsTag,      {0, 1, 0 }}, //  9
  { LoadersName,        LoadersTag,        {0, 1, 0 }}, // 10
  { LuaFunctionsName,   LuaFunctionsTag,   {0, 1, 0 }}, // 11
  { NaturalsName,       NaturalsTag,       {0, 1, 0 }}, // 12
  { PairsName,          PairsTag,          {0, 1, 0 }}, // 13
  { ParsersName,        ParsersTag,        {0, 1, 0 }}, // 14
  { StringBuffersName,  StringBuffersTag,  {0, 1, 0 }}, // 15
  { SymbolsName,        SymbolsTag,        {0, 1, 0 }}, // 16
  { TemplatesName,      TemplatesTag,      {0, 1, 0 }}, // 17
  { TextsName,          TextsTag,          {0, 1, 0 }}, // 18
  { NULL,               0,                 {0, 0, 0 }}
};
\stopCCode

\startLuaCode
local joylol = { }

-- load all required CoAlgebraic extensions -- creation phase

joylol.jInterps       = require 'joylol.jInterps'       --  1
joylol.dicionaries    = require 'joylol.dictionaries'   --  2
joylol.booleans       = require 'joylol.booleans'       --  3
joylol.cFunctions     = require 'joylol.cFunctions'     --  4
joylol.coAlgebras     = require 'joylol.coAlgebras'     --  5
joylol.contexts       = require 'joylol.contexts'       --  6
joylol.crossCompilers = require 'joylol.crossCompilers' --  7
joylol.dictNodes      = require 'joylol.dictNodes'      --  8
joylol.fragments      = require 'joylol.fragments'      --  9
joylol.loaders        = require 'joylol.loaders'        -- 10
joylol.luaFunctions   = require 'joylol.luaFunctions'   -- 11
joylol.naturals       = require 'joylol.naturals'       -- 12
joylol.pairs          = require 'joylol.pairs'          -- 13
joylol.parsers        = require 'joylol.parsers'        -- 14
joylol.stringBuffers  = require 'joylol.stringBuffers'  -- 15
joylol.symbols        = require 'joylol.symbols'        -- 16
joylol.templates      = require 'joylol.templates'      -- 17
joylol.texts          = require 'joylol.texts'          -- 18

-- load all required CoAlgebraic extensions -- initialization phase

joylol.jInterps.initializeAllRequired()

\stopLuaCode

\section[title=Required cross compilers]

One of the key objectives of the JoyLoL interpreter is to ensure as much 
as possible of its own code and the code of any of its extensions is 
proven correct. While it is theoretically impossible to ever prove any 
implementation of reality to be 100\percent correct, we can ensure that 
those code fragements which can only be tests as opposed to proven 
correct, is as small as possible.

It is the \type{CrossCompiler} CoAlgebra which manages the process of 
proving \emph{implemented} JoyLoL words are proven correct. The 
\type{CrossCompiler} coalgebras do this by first verifying and then 
assembling JoyLoL words from adequately tests code fragments in a 
particular programming language. There is one \type{CrossCompiler} for 
each programming language as embedded in a computer system. 

For the current JoyLoL implementation, the required \type{CrossCompilers} are:

\setCHeaderStream{public}
\startCHeader
#define Unused_CC                 0
#define AnsiC_CC                  1
#define AnsiC_Lua_CC              2
#define PureLua_CC                3
#define NumRequiredCrossCompilers 4

#define AnsiC_Name     "ansiC"     /*  1 */
#define AnsiC_Lua_Name "ansiC-Lua" /*  2 */
#define PureLua_Name   "pureLua"   /*  3 */
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern RequiredObjects requiredCompilers[];
\stopCHeader
\setCHeaderStream{public}

\setCCodeStream{interpreter}
\startCCode
RequiredObjects requiredCompilers[] = {
  { AnsiC_Name,       AnsiC_CC,     {0, 1, 0 }}, //  1
  { AnsiC_Lua_Name,   AnsiC_Lua_CC, {0, 1, 0 }}, //  2
  { PureLua_Name,     PureLua_CC,   {0, 1, 0 }}, //  3
  { NULL,             0,            {0, 0, 0 }}
};
\stopCCode
\section[title=Semi-standard typedefs]

Finally we provide a number of semi-standard typdefs to provide a semantic 
meaning to various typical variable uses. 

\startCHeader
typedef size_t     Boolean;
typedef const char Symbol;
\stopCHeader
