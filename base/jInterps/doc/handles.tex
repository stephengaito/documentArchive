% A ConTeXt document [master document: coAlgs.tex]

\section[title=CoAlgHandles]
\setCHeaderStream{public}
\setCCodeStream{handles}

Since the implementation of any particular CoAlgebraic extension will of 
necessity make use of \type{CoAlgHandle}s, we \emph{begin} by providing 
their implementation. While a programming \quote{handle} typically has no 
publicly accessible internal structure, our \type{CoAlgHandle}s have a 
simple three part structure. 

\subsection[title=Type part] The first (type) part is a \type{CoAlgebra*} 
pointer to the data structure which represents the CoAlgebra for which the 
handle is a handle. This CoAlgebra pointer ensures that the implementation 
code knows what the given handle, is a handle \emph{for}, as well as what 
it can \emph{do}. 

\subsection[title=Flag part] The second (flag) part is a collection of 
bits to provide useful meta-flags associated with a handle. At least three 
of these meta-flags are reserved by the JoyLoL interpreter to signal 
ongoing garbage collection, equality determination as well as printing. 
Since any handle is potentially part of a cyclic structure, these 
meta-flags ensure garbage collection, equality detection and printing do 
not fall into infinite cycles. 

All non-reserved meta-flags may be used by the implementation of a 
CoAlgebra extension for its own internal purposes. Typically meta-flags 
might be used to signal how to interpret the data stored in the third 
(data) part of the handle. For the \type{Naturals} CoAlgebraic extension, 
a meta-flag will be used to signal that the handle's data part is a 
pointer to a Gnu Multi-precision integer, rather than to a double word 
integer. This allows significant speed optimizations in the typical cases, 
but allows for full data representations in rare but important cases. 

All reserved meta-flags will be located in low order bits of the flag data 
word. This ensures that any CoAlgebraic extension which makes use of 
meta-flags can simply rotate the reserved flags off the end of the word 
before making use of the non-reserved flags. In particular a CoAlgebraic 
extension \emph{could} interpret its flags as an integer or pointer. Such 
interpretations are private to each extension, and should \emph{not} be 
relied upon by code which is not part of the code's own extension. 

As \quote{global} meta-flags we reserve the following three 
\emph{low-order} bits together with a Mask of all three bits and the 
number of reserved bits to shift (left). 

\startCHeader
#define MARK_SWEEP_FLAG     0x1L
#define PRINT_FLAG          0x2L
#define EQUAL_FLAG          0x4L
#define RESERVED_FLAG_MASK  0x7L
#define RESERVED_FLAG_SHIFT 3
\stopCHeader

\subsection[title=Data part] The third (data) part is a union of the four 
typical ways a \emph{pair} of words might be used. One important use case 
is as a pair of \type{CoAlgHandle*} pointers. The \emph{most} common use 
of a \type{CoAlgHandle} will be as a list \quote{pair}, which contains 
Lisp-like \type{car} and \type{cdr} pointers to other lists. However, the 
data part of a handle, can be used in any way in which an extension wishes 
to use them. For example the \type{Naturals} extension, might use this 
pair of words as alternatively, a double word integer, a pair of single 
word integers, or as a pointer to a more complex data structure. 

We start by providing generic ANSI-C typedefs for each of these four 
alternatives. 

\startCHeader
typedef struct two_pointers_struct {
  CoAlgHandle* a;
  CoAlgHandle* b;
} TwoPointers;

typedef struct two_words_struct {
  size_t a;
  size_t b;
} TwoWords;

typedef struct mixed_word_struct {
  void* ptr;
  size_t wrd;
} MixedWords;

#ifdef __LP64__
#define DoubleWord __uint128_t
#else
#define DoubleWord uint64_t
#endif


typedef union {
  TwoPointers ptrs;
  TwoWords    words;
  MixedWords  mixed;
  DoubleWord  dword;
} HandleData;
\stopCHeader

Now using these typedefs we define a \type{CoAlgHandle} as:

\startCHeader
typedef struct coalgebra_handle_struct {
  CoAlgebra*   type;
  size_t       flags;  // an arbitrary collection of bits
  HandleData   data;
} CoAlgHandle;
\stopCHeader

\section[title=isAtom isPair]

A common requirement is to determine whether or not a given 
\type{CoAlgHandle} is an \quote{atom} or a \quote{pair}. Quite simply we 
define anything that is not an instance of \type{Pairs} an \quote{atom}.

\startCHeader
#define isAtom(aHandle) \
  ((aHandle) && (aHandle)->type && ((aHandle)->type->isA != PairsTag))
  
#define isPair(aHandle) \
  ((aHandle) && (aHandle)->type && ((aHandle)->type->isA == PairsTag))
\stopCHeader

\section[title=Handle Memory]

Since a JoyLoL interpreter is essentially a list processor, any JoyLoL 
program will create (and orphan) a very large number of list \type{Pairs} 
over the course of a computation. This means that we need to make the 
allocation and eventual garbage collection of orphaned \type{CoAlgHandles} 
as efficient as possible.

We do this by defining a \type{HandleMemory} as a pair of pointers. The 
first pointer points to a linked list of free handles. The second pointer 
points to a linked list of \type{HandleBlock}s. 

\startCHeader
typedef struct handle_block_struct HandleBlock;

typedef struct handle_memory_struct {
  CoAlgHandle* freeHandles;
  HandleBlock* rootHandleBlock;
} HandleMemory;

typedef struct handle_block_struct {
  CoAlgHandle* block;
  HandleBlock* nextBlock;
} HandleBlock;
\stopCHeader

\subsection[title=Allocating new handles]

\startTestSuite[newHandle]

To allocate a new \type{CoAlgHandle} the first free handle is taken from 
the linked list of free handles. If there are no remaining free handles, 
then we first attempt to collect any garbage and then if this fails to get 
any new free handles, a new \type{HandleBlock} is allocated together with 
its collection of free handles. 

\setCCodeStream{handles}
\startCHeader
extern CoAlgHandle* newHandle(JoyLoLInterp* jInterp);
\stopCHeader

\startCCode
CoAlgHandle* newHandle(JoyLoLInterp* jInterp) {
  assert(jInterp);
  // ensure there are some free handles
  if ( ! jInterp->hMem.freeHandles ) collectGarbage(jInterp);
  if ( ! jInterp->hMem.freeHandles ) addHandleBlock(jInterp);
  assert(jInterp->hMem.freeHandles);

  CoAlgHandle* aNewHandle   = jInterp->hMem.freeHandles;
  jInterp->hMem.freeHandles = aNewHandle->data.ptrs.b;

  aNewHandle->type        = NULL;
  aNewHandle->flags       = 0;
  aNewHandle->data.ptrs.a = NULL;
  aNewHandle->data.ptrs.b = NULL;

  return aNewHandle;
}
\stopCCode

\startTestCase[Allocate one new CoAlgHandle]
\startCTest
  JoyLoLInterp* jInterp = newJoyLoLInterp();
  AssertPtrNotNull(jInterp);

  AssertPtrNull(jInterp->hMem.freeHandles);
  AssertPtrNull(jInterp->hMem.rootHandleBlock);

  // get one new handle to ensure our lazily
  // initialized handle memory structures 
  // are initialized...
  CoAlgHandle* aNewHandle = newHandle(jInterp);

  AssertPtrNotNull(jInterp->hMem.freeHandles);
  AssertPtrNotNull(jInterp->hMem.rootHandleBlock);
  AssertPtrNotNull(aNewHandle );
  AssertPtrNull(aNewHandle->data.ptrs.a);
  AssertPtrNull(aNewHandle->data.ptrs.b);
  AssertPtrEquals(aNewHandle,
    jInterp->hMem.rootHandleBlock->block);

  // now get one more handle to ensure
  // we can properly deal with handle blocks/memory
  
  CoAlgHandle* oldFreeHandles =
    jInterp->hMem.freeHandles;
  CoAlgHandle* newfreeHandles = 
    jInterp->hMem.freeHandles->data.ptrs.b;

  aNewHandle = newHandle(jInterp);
  AssertPtrNotNull(aNewHandle );
  AssertPtrNull(aNewHandle->data.ptrs.a);
  AssertPtrNull(aNewHandle->data.ptrs.b);
  AssertPtrEquals(oldFreeHandles, aNewHandle);
  AssertPtrEquals(newfreeHandles, jInterp->hMem.freeHandles);
\stopCTest
\stopTestCase

\startTestCase[Allocate lots of new CoAlgHandles]

\startCTest
  JoyLoLInterp* jInterp = newJoyLoLInterp();
  AssertPtrNotNull(jInterp);

  CoAlgHandle* aNewHandle = NULL;
  for ( size_t i = 0; i < 3*HANDLE_BLOCK_SIZE; i++ ) {
    aNewHandle = newHandle(jInterp);
  }
  AssertPtrNotNull(aNewHandle);
  AssertPtrNull(aNewHandle->data.ptrs.a);
  AssertPtrNull(aNewHandle->data.ptrs.b);
\stopCTest
\stopTestCase
\stopTestSuite

\subsection[title=Allocating new Handle blocks]

\startTestSuite[addHandleBlock]

\setCHeaderStream{private}
\startCHeader
#define HANDLE_BLOCK_SIZE 1024

extern void addHandleBlock(JoyLoLInterp* jInterp);
\stopCHeader


\startCCode
void addHandleBlock(JoyLoLInterp* jInterp) {
  DEBUG(FALSE, "addHandleBlock > %p %zu\n", 
    jInterp, (size_t)HANDLE_BLOCK_SIZE);
  assert(jInterp);
  
  // obtain a new handle block
  HandleBlock* aNewHandleBlock = 
    (HandleBlock*)calloc(1, sizeof(HandleBlock));
  assert( IS_MEM_ALIGNED(aNewHandleBlock) );

  // integrate this new handle block into the linked list of
  // handle blocks
  if ( jInterp->hMem.rootHandleBlock ) {
    HandleBlock *lastHandleBlock = jInterp->hMem.rootHandleBlock;
    while ( lastHandleBlock->nextBlock ) {
      lastHandleBlock = lastHandleBlock->nextBlock;
    }
    assert(lastHandleBlock->nextBlock == NULL);
    lastHandleBlock->nextBlock = aNewHandleBlock;
  } else {
    jInterp->hMem.rootHandleBlock = aNewHandleBlock;
  }
  DEBUG(FALSE, "addHandleBlock = %p %p\n", 
    jInterp, aNewHandleBlock);

  // make sure this handle block has some CoAlgHandles
  aNewHandleBlock->block = 
    (CoAlgHandle*)calloc(HANDLE_BLOCK_SIZE, sizeof(CoAlgHandle));
  assert( aNewHandleBlock->block );
  assert( IS_MEM_ALIGNED(aNewHandleBlock->block) );

  // add these new CoAlgHandles to the free list
  CoAlgHandle* nextHandle = aNewHandleBlock->block;
  CoAlgHandle* lastHandle = nextHandle + HANDLE_BLOCK_SIZE - 1;
  for ( ; nextHandle < lastHandle ; nextHandle++ ) {
    assert( IS_MEM_ALIGNED(nextHandle) );
    nextHandle->data.ptrs.a = NULL;
    nextHandle->data.ptrs.b = nextHandle + 1;
  }
  nextHandle->data.ptrs.b = jInterp->hMem.freeHandles;
  jInterp->hMem.freeHandles = aNewHandleBlock->block;
  DEBUG(FALSE, "addHandleBlock < %p %p %p\n",
    jInterp, aNewHandleBlock, aNewHandleBlock->block);
}
\stopCCode

\startTestCase[must add new handle block]
\startCTest
  // create the first list block and make sure it is 
  // properly integrated into linked list of list blocks

  JoyLoLInterp* jInterp = newJoyLoLInterp();

  AssertPtrNotNull(jInterp);
  AssertPtrNull(jInterp->hMem.rootHandleBlock);
  AssertPtrNull(jInterp->hMem.freeHandles);

  addHandleBlock(jInterp);
  AssertPtrNotNull(jInterp->hMem.rootHandleBlock);
  AssertPtrNotNull(jInterp->hMem.rootHandleBlock->block);
  AssertPtrNull(jInterp->hMem.rootHandleBlock->nextBlock);
  AssertPtrNotNull(jInterp->hMem.freeHandles);

  // check to make sure freeHandles list is correctly linked
  CoAlgHandle* nextHandle = jInterp->hMem.rootHandleBlock->block;
  CoAlgHandle* lastHandle = nextHandle + HANDLE_BLOCK_SIZE - 1;
  for ( ; nextHandle < lastHandle ; nextHandle++ ) {
    AssertIntTrue(IS_MEM_ALIGNED(nextHandle));
    AssertPtrNull(nextHandle->data.ptrs.a);
    AssertPtrEquals(nextHandle->data.ptrs.b, nextHandle + 1);
  }
  AssertPtrNull(nextHandle->data.ptrs.b);
  AssertPtrEquals(jInterp->hMem.freeHandles,
    jInterp->hMem.rootHandleBlock->block);

  // add another handle block
  CoAlgHandle* oldFreeHandles = jInterp->hMem.freeHandles;
  addHandleBlock(jInterp);
  AssertPtrNotNull(jInterp->hMem.rootHandleBlock->nextBlock);
  AssertPtrNotNull(jInterp->hMem.rootHandleBlock->nextBlock->block);
  AssertPtrNull(jInterp->hMem.rootHandleBlock->nextBlock->nextBlock);
  AssertPtrNotNull(jInterp->hMem.freeHandles);

  // check to make sure freeHandles list is correctly linked
  nextHandle = jInterp->hMem.rootHandleBlock->nextBlock->block;
  lastHandle = nextHandle + HANDLE_BLOCK_SIZE - 1;
  for ( ; nextHandle < lastHandle ; nextHandle++ ) {
    AssertIntTrue(IS_MEM_ALIGNED(nextHandle));
    AssertPtrNull(nextHandle->data.ptrs.a);
    AssertPtrEquals(nextHandle->data.ptrs.b, nextHandle + 1);
  }
  AssertPtrEquals(nextHandle->data.ptrs.b, oldFreeHandles);
  AssertPtrEquals(jInterp->hMem.freeHandles,
    jInterp->hMem.rootHandleBlock->nextBlock->block);
\stopCTest
\stopTestCase
\stopTestSuite

\subsection[title=Garbage collection]

\setCHeaderStream{private}
\startCHeader
extern void collectGarbage(JoyLoLInterp* jInterp);
\stopCHeader

\startCCode
void collectGarbage(JoyLoLInterp* jInterp) {
  DEBUG(FALSE, "collectGarbage %p\n", jInterp);
  // add a garbage collection mark-sweep here
  assert(jInterp);
}
\stopCCode

Old unused CuTests.

\starttyping
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "CuTest.h"

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/lists.h"
#include "joyLoL/lists_private.h"
#include "joyLoL/printer.h"

// suiteName: - Pairs CoAlgebra tests -

void Test_createPairsCoAlgebra(CuTest* tc) {
  CoAlgebras *coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Pairs* pairs = coAlgs->pairs;
  CuAssertPtrNotNull(tc, pairs);

  CuAssertPtrNotNull(tc, pairs->listMemory);
}

void Test_printPairs(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  CuAssertPtrNotNull(tc, coAlgs->pairs);

  PairAtom* aNewPair = newPair(coAlgs,
                               newPair(coAlgs, NULL, NULL),
                               newPair(coAlgs, NULL, NULL));
  CuAssertPtrNotNull(tc, aNewPair);
  CuAssertIntEquals(tc, printSizeDebug(aNewPair, FALSE), 28);
  CuAssertStrEquals(tc, printLoLDebug(aNewPair, FALSE), "( ( ) ) ( )");
}
\stoptyping
