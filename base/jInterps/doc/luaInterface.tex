% A ConTeXt document [master document: jInterps.tex]

\section[title=Lua interface functions]
\setCCodeStream{lua}

\startTestSuite[ set, add and get LuaPath]

\startCHeader
#define setLuaPath(lstate, aLuaPath, addToCPath)  \
  lua_getglobal(lstate, "package");               \
  lua_pushstring(lstate, aLuaPath);               \
  lua_setfield(lstate, -2,                        \
    (addToCPath ? "cpath" : "path"));             \
  lua_pop(lstate, 1)

#define addLuaPath(lstate, aLuaPath, addToCPath)              \
for(size_t iAddLuaPath = 0; iAddLuaPath < 1; iAddLuaPath++) { \
  luaL_Buffer lBuf;                                           \
  luaL_buffinit(lstate, &lBuf);                               \
  luaL_addstring(&lBuf, aLuaPath);                            \
  luaL_addstring(&lBuf, ";");                                 \
  lua_getglobal(lstate, "package");                           \
  lua_getfield(lstate, -1,                                    \
    (addToCPath ? "cpath" : "path"));                         \
  luaL_addvalue (&lBuf);                                      \
  luaL_pushresult(&lBuf);                                     \
  lua_setfield(lstate, -2,                                    \
    (addToCPath ? "cpath" : "path"));                         \
  lua_pop(lstate, 1);                                         \
}

#define getLuaPathInto(lstate, result, getCPath)  \
  lua_getglobal(lstate, "package");               \
  lua_getfield(lstate, -1,                        \
    (getCPath ? "cpath" : "path"));               \
  Symbol *result =                                \
    strdup(lua_tostring(lstate, -1));             \
  lua_pop(lstate, 2)

#define PATH_BUFFER_SIZE  8000

#define buildCWDPathInto(buffer, aDir)                  \
  char *buffer = (char*)calloc(1, PATH_BUFFER_SIZE);    \
  if (!getcwd(buffer, PATH_BUFFER_SIZE)) {              \
    fprintf(stderr, "\nERROR:\n");                      \
    fprintf(stderr, "  Path buffer size too small\n");  \
    fprintf(stderr, "  while building CWD path\n\n");   \
    exit(-1);                                           \
  }                                                     \
  strncat(buffer, "/",                                  \
    PATH_BUFFER_SIZE - strlen(buffer) - 1);             \
  strncat(buffer, aDir,                                 \
    PATH_BUFFER_SIZE - strlen(buffer) - 1)

#define addBuildLuaPath(lstate)            \
  buildCWDPathInto(buildLuaPath,           \
    "build/?.lua");                        \
  addLuaPath(lstate, buildLuaPath, FALSE); \
  free(buildLuaPath);                      \
  buildCWDPathInto(buildCPath,             \
    "build/?.so");                         \
  addLuaPath(lstate, buildCPath, TRUE);    \
  free(buildCPath)
  
#define buildHomePathInto(buffer, homeBuffer, aDir)     \
  char *buffer = (char*)calloc(1, PATH_BUFFER_SIZE);    \
  char *homeBuffer = getenv("HOME");                    \
  if (!homeBuffer) {                                    \
    fprintf(stderr, "\nERROR:\n");                      \
    fprintf(stderr, "  Environment variable 'HOME'\n"); \
    fprintf(stderr, "  is empty!\n\n");                 \
    exit(-1);                                           \
  }                                                     \
  strncat(buffer, homeBuffer,                           \
    PATH_BUFFER_SIZE - strlen(buffer) - 1);             \
  strncat(buffer, "/",                                  \
    PATH_BUFFER_SIZE - strlen(buffer) - 1);             \
  strncat(buffer, aDir,                                 \
    PATH_BUFFER_SIZE - strlen(buffer) - 1)

#define addJoyLoLLuaPath(lstate)                 \
  buildHomePathInto(joyLoLLuaPath, homeLuaPath,  \
    ".joylol/?.lua");                            \
  addLuaPath(lstate, joyLoLLuaPath, FALSE);      \
  free(joyLoLLuaPath);                           \
  buildHomePathInto(joyLoLCPath, homeCPath,      \
    ".joylol/?.so");                             \
  addLuaPath(lstate, joyLoLCPath, TRUE);         \
  free(joyLoLCPath)
\stopCHeader

\startTestCase[should set, add and get package.path]

\startCTest
  getLuaPathInto(lstate, origPath, FALSE);
  AssertPtrNotNull(origPath);
  AssertPtrNotNull(strstr(origPath, "?.lua"));

  addLuaPath(lstate, "tests", FALSE);
  getLuaPathInto(lstate, testPath, FALSE);
  AssertPtrNotNull(testPath);

  AssertIntZero(strncmp(testPath, "tests;", strlen("tests;")));
  
  setLuaPath(lstate, origPath, FALSE);
  getLuaPathInto(lstate, newTestPath, FALSE);
  AssertPtrNotNull(newTestPath);
  AssertIntZero(strcmp(origPath, newTestPath));

  free((void*)testPath);
  free((void*)newTestPath);
  free((void*)origPath);
\stopCTest
\stopTestCase

\startTestCase[should set, add and get package.cpath]

\startCTest
  getLuaPathInto(lstate, origPath, TRUE);
  AssertPtrNotNull(origPath);
  AssertPtrNotNull(strstr(origPath, "?.so"));

  addLuaPath(lstate, "tests", TRUE);
  getLuaPathInto(lstate, testPath, TRUE);
  AssertPtrNotNull(testPath);

  AssertIntZero(strncmp(testPath, "tests;", strlen("tests;")));
  
  setLuaPath(lstate, origPath, TRUE);
  getLuaPathInto(lstate, newTestPath, TRUE);
  AssertPtrNotNull(newTestPath);
  AssertIntZero(strcmp(origPath, newTestPath));
  
  free((void*)testPath);
  free((void*)newTestPath);
  free((void*)origPath);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[require lua modules]

\startCHeader
#define requireLuaModule(lstate, aLuaModule)              \
  lua_getglobal(lstate, "require");                       \
  lua_pushstring(lstate, aLuaModule);                     \
  if (lua_pcall(lstate, 1, 1, 0)) {                       \
    /* there was an error...                              \
     * so return a copy of the error message              \
     */                                                   \
    fprintf(stderr, "Failed to load [%s]\n", aLuaModule); \
    fprintf(stderr, "Error:\n");                          \
    fprintf(stderr, "%s\n", lua_tostring(lstate, -1));    \
    lua_close(lstate);                                    \
    exit(-1);                                             \
  }                                                       \
  lua_pop(lstate, 1)
\stopCHeader

\stopTestSuite

\component gitVersion-c

\startCCode
static int lua_jInterps_getGitVersion (lua_State *lstate) {
  Symbol* aKey   = lua_tostring(lstate, 1);
  if (aKey) {
    getGitVersionInto(gitVersionKeyValues, aKey, aValue);
    lua_pushstring(lstate, aValue);
  } else {
    lua_pushstring(lstate, "no valid key provided");
  }
  return 1;
}
\stopCCode

\startCCode
static const struct luaL_Reg lua_jInterps [] = {
  {"gitVersion", lua_jInterps_getGitVersion},
  {NULL, NULL}
};
\stopCCode

\startCCode
static void registerJInterpsLuaInterface(lua_State *lstate) {
  assert(lstate);
  luaL_newlib(lstate, lua_jInterps);
}
\stopCCode

Now each shared library needs to implement the following code to provide 
an interface between the generic C-implementation and the Lua module for 
the shared library. 

\startCCode
int luaopen_joylol_jInterps (lua_State *lstate) {
  setJoyLoLInterpInto(lstate, jInterp);
  registerJInterps(jInterp);
  registerJInterpsLuaInterface(lstate);
  return 1;
}
\stopCCode

In some instances, such as the typical \type{CTest} program 
\type{allCTests}, this Lua module (which can be \type{require}d as a 
shared library) is actually statically linked into the executable. In 
these cases we need the ability to mimic the standard Lua \type{require} 
process. The following \type{requireStaticallyLinkedJInterps} does just this. 

\startCHeader
Boolean requireStaticallyLinkedJInterps(
  lua_State *lstate
);
\stopCHeader

\startCCode
Boolean requireStaticallyLinkedJInterps(
  lua_State *lstate
) {
  lua_getglobal(lstate, "package");
  lua_getfield(lstate, -1, "loaded");
  luaopen_joylol_jInterps(lstate);
  lua_setfield(lstate, -2, "joylol.jInterps");
  lua_setfield(lstate, -2, "loaded");
  lua_pop(lstate, 1);
  return TRUE;
}
\stopCCode
