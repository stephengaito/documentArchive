% A ConTeXt document [master document: jInterps.tex]

\section[title=Lua interface functions]
\setCCodeStream{lua}

\startTestSuite[ set, add and get LuaPath]

\startCHeader
#define setLuaPath(lstate, aLuaPath, addToCPath)  \
  lua_getglobal(lstate, "package");               \
  lua_pushstring(lstate, aLuaPath);               \
  lua_setfield(lstate, -2,                        \
    (addToCPath ? "cpath" : "path"));             \
  lua_pop(lstate, 1)

#define addLuaPath(lstate, aLuaPath, addToCPath)              \
for(size_t iAddLuaPath = 0; iAddLuaPath < 1; iAddLuaPath++) { \
  luaL_Buffer lBuf;                                           \
  luaL_buffinit(lstate, &lBuf);                               \
  luaL_addstring(&lBuf, aLuaPath);                            \
  luaL_addstring(&lBuf, ";");                                 \
  lua_getglobal(lstate, "package");                           \
  lua_getfield(lstate, -1,                                    \
    (addToCPath ? "cpath" : "path"));                         \
  luaL_addvalue (&lBuf);                                      \
  luaL_pushresult(&lBuf);                                     \
  lua_setfield(lstate, -2,                                    \
    (addToCPath ? "cpath" : "path"));                         \
  lua_pop(lstate, 1);                                         \
}

#define getLuaPathInto(lstate, result, getCPath)  \
  lua_getglobal(lstate, "package");               \
  lua_getfield(lstate, -1,                        \
    (getCPath ? "cpath" : "path"));               \
  Symbol *result =                                \
    strdup(lua_tostring(lstate, -1));             \
  lua_pop(lstate, 2)

#define PATH_BUFFER_SIZE  8000

#define buildCWDPathInto(buffer, aDir)                  \
  char *buffer = (char*)calloc(1, PATH_BUFFER_SIZE);    \
  if (!getcwd(buffer, PATH_BUFFER_SIZE)) {              \
    /*return*/ luaL_error(lstate, "%s%s%s",             \
      "\nERROR:\n",                                     \
      "  Path buffer size too small\n",                 \
      "  while building CWD path\n\n");                 \
  }                                                     \
  strncat(buffer, "/",                                  \
    PATH_BUFFER_SIZE - strlen(buffer) - 1);             \
  strncat(buffer, aDir,                                 \
    PATH_BUFFER_SIZE - strlen(buffer) - 1)

#define addBuildLuaPath(lstate)            \
  buildCWDPathInto(buildLuaPath,           \
    "build/?.lua");                        \
  addLuaPath(lstate, buildLuaPath, FALSE); \
  free(buildLuaPath);                      \
  buildCWDPathInto(buildCPath,             \
    "build/?.so");                         \
  addLuaPath(lstate, buildCPath, TRUE);    \
  free(buildCPath)
  
#define buildHomePathInto(buffer, homeBuffer, aDir)     \
  char *buffer = (char*)calloc(1, PATH_BUFFER_SIZE);    \
  char *homeBuffer = getenv("HOME");                    \
  if (!homeBuffer) {                                    \
    /*return*/ luaL_error(lstate, "%s",                 \
      "\nERROR:\n",                                     \
      "  Environment variable 'HOME'\n",                \
      "  is empty!\n\n");                               \
  }                                                     \
  strncat(buffer, homeBuffer,                           \
    PATH_BUFFER_SIZE - strlen(buffer) - 1);             \
  strncat(buffer, "/",                                  \
    PATH_BUFFER_SIZE - strlen(buffer) - 1);             \
  strncat(buffer, aDir,                                 \
    PATH_BUFFER_SIZE - strlen(buffer) - 1)

#define addJoyLoLLuaPath(lstate)                 \
  buildHomePathInto(joyLoLLuaPath, homeLuaPath,  \
    ".joylol/?.lua");                            \
  addLuaPath(lstate, joyLoLLuaPath, FALSE);      \
  free(joyLoLLuaPath);                           \
  buildHomePathInto(joyLoLCPath, homeCPath,      \
    ".joylol/?.so");                             \
  addLuaPath(lstate, joyLoLCPath, TRUE);         \
  free(joyLoLCPath)
\stopCHeader

\startTestCase[should set, add and get package.path]

\startCTest
  getLuaPathInto(lstate, origPath, FALSE);
  AssertPtrNotNull(origPath);
  AssertPtrNotNull(strstr(origPath, "?.lua"));

  addLuaPath(lstate, "tests", FALSE);
  getLuaPathInto(lstate, testPath, FALSE);
  AssertPtrNotNull(testPath);

  AssertIntZero(strncmp(testPath, "tests;", strlen("tests;")));
  
  setLuaPath(lstate, origPath, FALSE);
  getLuaPathInto(lstate, newTestPath, FALSE);
  AssertPtrNotNull(newTestPath);
  AssertIntZero(strcmp(origPath, newTestPath));

  free((void*)testPath);
  free((void*)newTestPath);
  free((void*)origPath);
\stopCTest
\stopTestCase

\startTestCase[should set, add and get package.cpath]

\startCTest
  getLuaPathInto(lstate, origPath, TRUE);
  AssertPtrNotNull(origPath);
  AssertPtrNotNull(strstr(origPath, "?.so"));

  addLuaPath(lstate, "tests", TRUE);
  getLuaPathInto(lstate, testPath, TRUE);
  AssertPtrNotNull(testPath);

  AssertIntZero(strncmp(testPath, "tests;", strlen("tests;")));
  
  setLuaPath(lstate, origPath, TRUE);
  getLuaPathInto(lstate, newTestPath, TRUE);
  AssertPtrNotNull(newTestPath);
  AssertIntZero(strcmp(origPath, newTestPath));
  
  free((void*)testPath);
  free((void*)newTestPath);
  free((void*)origPath);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[require lua modules]

\startCHeader
#define requireLuaModule(lstate, aLuaModule)  \
  lua_getglobal(lstate, "require");           \
  lua_pushstring(lstate, aLuaModule);         \
  if (lua_pcall(lstate, 1, 1, 0)) {           \
    /* there was an error...                  \
     * so return a copy of the error message  \
     */                                       \
    /*return*/ luaL_error(lstate,             \
      "Failed to load [%s]\n%s%s\n",          \
      aLuaModule,                             \
      "ERROR:\n",                             \
      lua_tostring(lstate, -1));              \
  }                                           \
  lua_pop(lstate, 1)
\stopCHeader

\startCHeader
#define requireLuaModuleInto(lstate, aLuaModule, result)  \
  Boolean result = TRUE;                                  \
  lua_getglobal(lstate, "require");                       \
  lua_pushstring(lstate, aLuaModule);                     \
  if (lua_pcall(lstate, 1, 1, 0)) {                       \
    /* there was an error... */                           \
    result = FALSE;                                       \
  }                                                       \
  lua_pop(lstate, 1)
\stopCHeader

\stopTestSuite

\startCCode
static int lua_jInterps_initializeAllRequired(lua_State *lstate) {
  getJoyLoLInterpInto(lstate, jInterp);
  assert(jInterp);
  
  // first check that core stdout and stderr are defined
  if (!(jInterp->writeStdOut) || !(jInterp->writeStdErr)) {
    return luaL_error(lstate, "%s%s",
      "\nERROR:\n",
      "  Core output methods are missing\n");
  }
  
  // now check that all required CoAlg extensions 
  // have been registered
  //
  RequiredCoAlgs *curCoAlg = requiredCoAlgs;
  for ( ; curCoAlg->name ; curCoAlg++) {
    size_t curTag = curCoAlg->tag;
    if (!getCoAlgClass(jInterp, curTag)) {
      return luaL_error(lstate, "%s%s%s%s\n\n",
        "\nERROR:\n",
       "  Missing a required CoAlgebraic extension\n",
       "  need to require joylol.",
       curCoAlg->name);
    }
  }

  // now call the initialization function for each 
  // required CoAlgebraic extension
  for( size_t i = 1; i < NumRequiredCoAlgs; i++) {
    CoAlgClass *aCoAlg = getCoAlgClass(jInterp, i);
    if (aCoAlg) {
      aCoAlg->initializeFunc(jInterp, aCoAlg);
    }
  }
  
  // finally check that all important interpreter 
  // objects have been assigned
  if (
    !(jInterp->dict.root) || 
    !(jInterp->dict.firstSymbol) ||
    !(jInterp->loader) ||
    !(jInterp->rootCtx)
    ) {
      return luaL_error(lstate, "%s%s",
        "\nERROR:\n",
        "  some required objects are missing\n\n");
    }
  return 0;
}
\stopCCode

\component gitVersion-c

\startCCode
static int lua_jInterps_getGitVersion (lua_State *lstate) {
  Symbol* aKey   = lua_tostring(lstate, 1);
  if (aKey) {
    getGitVersionInto(gitVersionKeyValues, aKey, aValue);
    lua_pushstring(lstate, aValue);
  } else {
    lua_pushstring(lstate, "no valid key provided");
  }
  return 1;
}
\stopCCode

\startCCode
static const struct luaL_Reg lua_jInterps [] = {
  {"gitVersion",            lua_jInterps_getGitVersion},
  {"initializeAllRequired", lua_jInterps_initializeAllRequired},
  {NULL, NULL}
};
\stopCCode

\startCCode
static void requireAllRequiredCoAlgs(
  lua_State    *lstate,
  JoyLoLInterp *jInterp
) {
  assert(lstate);
  assert(jInterp);
  assert(jInterp->coAlgs);

  // start by creating a master table
  lua_createtable(lstate, 0, NumRequiredCoAlgs + 5); // -3
  
  // now place jInterps into the master table
  lua_pushstring(lstate, "jInterps");                // -2
  luaL_newlib(lstate, lua_jInterps);                 // -1
  lua_settable(lstate, -3);
  
  // now walk through the required coAlgs
  // requiring each in turn and 
  // placing it into the master table
  RequiredCoAlgs *curCoAlg = requiredCoAlgs;
  for ( ; curCoAlg->name ; curCoAlg++) {
    size_t curTag = curCoAlg->tag;
    if (!(jInterp->coAlgs[curTag].sClass)) {
      lua_pushstring(lstate, curCoAlg->name); // -2
      lua_getglobal(lstate, "require");
      luaL_Buffer modName;
      luaL_buffinit(lstate, &modName);
      luaL_addstring(&modName, "joylol.");
      luaL_addstring(&modName, curCoAlg->name);
      luaL_pushresult(&modName);
      if (lua_pcall(lstate, 1, 1, 0)) {       // -> -1
        // deal with the error!
      }
      lua_settable(lstate, -3);
    }
  }  
}
\stopCCode

Now each shared library needs to implement the following code to provide 
an interface between the generic C-implementation and the Lua module for 
the shared library. 

\startCCode
int luaopen_joylol_jInterps (lua_State *lstate) {
  setJoyLoLInterpInto(lstate, jInterp);
  registerJInterps(jInterp);
  requireAllRequiredCoAlgs(lstate, jInterp);
  return 1;
}
\stopCCode

In some instances, such as the typical \type{CTest} program 
\type{allCTests}, this Lua module (which can be \type{require}d as a 
shared library) is actually statically linked into the executable. In 
these cases we need the ability to mimic the standard Lua \type{require} 
process. The following \type{requireStaticallyLinkedJInterps} does just this. 

\setCHeaderStream{public}
\startCHeader
extern Boolean requireStaticallyLinkedJInterps(
  lua_State *lstate
);
\stopCHeader

\startCCode
Boolean requireStaticallyLinkedJInterps(
  lua_State *lstate
) {
  lua_getglobal(lstate, "package");
  lua_getfield(lstate, -1, "loaded");
  
  // fake a luaopen_joylol_jInterps 
  // BUT without the requireAllRequiredCoAlgs
  setJoyLoLInterpInto(lstate, jInterp);
  registerJInterps(jInterp);
  luaL_newlib(lstate, lua_jInterps);
  
  lua_setfield(lstate, -2, "joylol.jInterps");
  lua_setfield(lstate, -2, "loaded");
  lua_pop(lstate, 1);
  return TRUE;
}
\stopCCode
