% A ConTeXt document [master document: stringBuffers.tex]

\section[title=Code]
\setCHeaderStream{public}

\dependsOn[jInterps]
\dependsOn[symbols]
%\dependsOn[context]

\startCHeader
typedef struct string_buffer_object_struct {
  CoAlgObj      super;
  FILE         *memFile;
  char         *buffer;
  size_t        bufSize;
} StringBufferObj;
\stopCHeader

\setCHeaderStream{private}
\startCHeader
#define asMemFile(aLoL)   (((StringBufferObj*)(aLoL))->memFile)
#define asBuffer(aLoL)    (((StringBufferObj*)(aLoL))->buffer)
#define asBufSize(aLoL)   (((StringBufferObj*)(aLoL))->bufSize)
\stopCHeader
\setCHeaderStream{public}

\startTestSuite[newStringBuffer]


\startCHeader
typedef StringBufferObj* (NewStringBuffer)(
  JoyLoLInterp*
);

#define newStringBuffer(jInterp)                                  \
  (                                                               \
    assert(getStringBuffersClass(jInterp)->newStringBufferFunc),  \
    getStringBuffersClass(jInterp)->newStringBufferFunc(jInterp)  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern StringBufferObj* newStringBufferImpl(JoyLoLInterp* jInterp);
\stopCHeader
\setCHeaderStream{public}

\startCCode
StringBufferObj* newStringBufferImpl(JoyLoLInterp* jInterp) {
  assert(jInterp);
  
  StringBufferObj* result =
    (StringBufferObj*)newObject(jInterp, StringBuffersTag);
  assert(result);
  asMemFile(result) = NULL;
  asBuffer(result)  = NULL;
  asBufSize(result) = 0;
  return result;
}
\stopCCode

\startCHeader
typedef void (StrBufClose)(
  StringBufferObj*
);

#define strBufClose(jInterp, aStrBuf)                          \
  (                                                           \
    assert(getStringBuffersClass(jInterp)->strBufCloseFunc),  \
    getStringBuffersClass(jInterp)->strBufCloseFunc(aStrBuf)  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void strBufCloseImpl(StringBufferObj* aStrBuf);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void strBufCloseImpl(StringBufferObj* aStrBuf) {
  if (!isStringBuffer(aStrBuf)) return;

  if (asMemFile(aStrBuf)) fclose(asMemFile(aStrBuf));
  if (asBuffer(aStrBuf))  free(asBuffer(aStrBuf));
  asMemFile(aStrBuf) = NULL;
  asBuffer(aStrBuf)  = NULL;
  asBufSize(aStrBuf) = 0;
}
\stopCCode

\setCHeaderStream{private}
\startCHeader
extern void strBufReOpen(StringBufferObj* aStrBuf);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void strBufReOpen(StringBufferObj* aStrBuf) {
  if (!isStringBuffer(aStrBuf)) return;

  if (asMemFile(aStrBuf)) strBufCloseImpl(aStrBuf);
  asMemFile(aStrBuf) = 
    open_memstream(&asBuffer(aStrBuf), &asBufSize(aStrBuf));
}
\stopCCode

\startTestCase[should create some new stringBuffers]

\startCTest
  AssertPtrNotNull(jInterp);

  StringBufferObj* aStrBuf = newStringBuffer(jInterp);
  AssertPtrNotNull(aStrBuf);
  AssertPtrNotNull(asType(aStrBuf));
  AssertIntEquals(asTag(aStrBuf), StringBuffersTag);
  AssertPtrNull(asMemFile(aStrBuf));
  AssertPtrNull(asBuffer(aStrBuf));
  AssertIntZero(asBufSize(aStrBuf));
  AssertIntTrue(isStringBuffer(aStrBuf));
  AssertIntTrue(isAtom(aStrBuf));
  AssertIntFalse(isPair(aStrBuf));
  strBufClose(jInterp, aStrBuf);
  AssertPtrNull(asMemFile(aStrBuf));
  AssertPtrNull(asBuffer(aStrBuf));
  AssertStrEquals(getCString(jInterp, aStrBuf), "");
  AssertPtrNotNull(asBuffer(aStrBuf));
  strBufClose(jInterp, aStrBuf);
  AssertPtrNull(asMemFile(aStrBuf));
  AssertPtrNull(asBuffer(aStrBuf));
  AssertIntZero(asBufSize(aStrBuf));
  strBufPrintf(jInterp, aStrBuf, "a test string");
  AssertPtrNotNull(asMemFile(aStrBuf));
  AssertStrEquals(getCString(jInterp, aStrBuf), "a test string");
  AssertPtrNotNull(asBuffer(aStrBuf));
  AssertIntEquals(asBufSize(aStrBuf), 13);
  strBufClose(jInterp, aStrBuf); // need to release the FILE*
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[isStringBuffer]

\startCHeader
#define isStringBuffer(aStrBuf)            \
  (                                        \
    (                                      \
      (aStrBuf) &&                         \
      asType(aStrBuf) &&                   \
      (asTag(aStrBuf) == StringBuffersTag) \
    ) ?                                    \
    TRUE : FALSE                           \
  )
\stopCHeader

\startTestCase[should return true if a string buffer]

\startCTest
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  AssertIntTrue(isStringBuffer(aStrBuf));
  //AssertIntTrue(symbolIs(aSym, "this is a test"));
\stopCTest
\stopTestCase

\startTestCase[should return false if not a string buffer]
\startCTest
  AssertIntFalse(isStringBuffer(NULL));
  CoAlgObj *aObj = newObject(jInterp, BooleansTag);
  AssertIntFalse(isStringBuffer(aObj));
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[getCString and strBufGetAsSymbol]

\startCHeader
typedef Symbol *(GetCString)(
  StringBufferObj*
);

#define getCString(jInterp, aStrBuf)                          \
  (                                                           \
    assert(getStringBuffersClass(jInterp)->getCStringFunc),   \
    (getStringBuffersClass(jInterp)->getCStringFunc(aStrBuf)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern Symbol *getCStringImpl(StringBufferObj *aStrBuf);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Symbol *getCStringImpl(StringBufferObj *aStrBuf) {
  if (!isStringBuffer(aStrBuf)) return NULL;
  if (!asMemFile(aStrBuf)) strBufReOpen(aStrBuf);
  fflush(asMemFile(aStrBuf));
  return asBuffer(aStrBuf);
}
\stopCCode

\stopTestSuite

\startTestSuite[strBufPrintf]

\startCHeader
typedef Boolean (StrBufPrintf)(
  StringBufferObj*,
  Symbol*,
  ...
);

#define strBufPrintf(jInterp, aStrBuf, ...)                                   \
  (                                                                           \
    assert(getStringBuffersClass(jInterp)->strBufPrintfFunc),                 \
    (getStringBuffersClass(jInterp)->strBufPrintfFunc(aStrBuf, __VA_ARGS__ )) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern Boolean strBufPrintfImpl(
  StringBufferObj   *aStrBuf,
  const char        *format, 
  ...
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean strBufPrintfImpl(
  StringBufferObj   *aStrBuf,
  const char        *format,
  ...
) {
  if (!isStringBuffer(aStrBuf)) return FALSE;
  if (!asMemFile(aStrBuf)) strBufReOpen(aStrBuf);
  
  va_list printfArgs;
  va_start(printfArgs, format);
  int numChars = vfprintf(asMemFile(aStrBuf), format, printfArgs);
  va_end(printfArgs);
  return (0 <= numChars);
}
\stopCCode

\startTestCase[should printf to a sting buffer]
\startCTest
  StringBufferObj* aStrBuf = newStringBuffer(jInterp);
  strBufPrintf(jInterp, aStrBuf, "a test [%s]", "an inner string");
  AssertStrEquals(getCString(jInterp, aStrBuf), "a test [an inner string]");
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[stringBuffer equality]

\setCHeaderStream{private}
\startCHeader
Boolean stringBuffersEqual(
  JoyLoLInterp *jInterp,
  CoAlgObj     *lolA,
  CoAlgObj     *lolB
);
\stopCHeader

\startCCode
Boolean stringBuffersEqual(
  JoyLoLInterp *jInterp,
  CoAlgObj     *lolA,
  CoAlgObj     *lolB
) {
  DEBUG(jInterp, "stringBuffersEqual a:%p b:%p\n", lolA, lolB);
  if (!lolA && !lolB) return TRUE;
  if (!lolA || !lolB) return FALSE;
  if (asType(lolA) != asType(lolB)) return FALSE;
  if (asTag(lolA)  != StringBuffersTag) return FALSE;
  if (strcmp(
    getCStringImpl((StringBufferObj*)lolA),
    getCStringImpl((StringBufferObj*)lolB)
    ) != 0) return FALSE;
  return TRUE;
}
\stopCCode

\startTestCase[should return true if stringBuffers are equal]

\startCTest
  AssertIntTrue(stringBuffersEqual(jInterp, NULL, NULL));
  StringBufferObj *strBufA = newStringBuffer(jInterp);
  strBufPrintf(jInterp, strBufA, "test");
  StringBufferObj *strBufB = newStringBuffer(jInterp);
  strBufPrintf(jInterp, strBufB, "test");
  AssertIntTrue(stringBuffersEqual(
    jInterp, (CoAlgObj*)strBufA, (CoAlgObj*)strBufB));
\stopCTest
\stopTestCase

\startTestCase[should return false if stringBuffers are not equal]

\startCTest
  StringBufferObj *strBufA = newStringBuffer(jInterp);
  strBufPrintf(jInterp, strBufA, "testA");
  StringBufferObj *strBufB = newStringBuffer(jInterp);
  strBufPrintf(jInterp, strBufB, "testB");
  AssertIntFalse(stringBuffersEqual(
    jInterp, NULL, (CoAlgObj*)strBufB));
  AssertIntFalse(stringBuffersEqual(
    jInterp, (CoAlgObj*)strBufA, NULL));
  AssertIntFalse(stringBuffersEqual(
    jInterp, (CoAlgObj*)strBufA, (CoAlgObj*)strBufB));
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[printing stringBuffers]

\setCHeaderStream{private}
\startCHeader
extern size_t printStringBufferCoAlg(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  CoAlgObj        *aLoL
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean printStringBufferCoAlg(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  CoAlgObj        *aLoL
) {
  assert(aStrBuf);
  assert(asTag(aStrBuf) == StringBuffersTag);
  
  assert(aLoL);
  assert(asTag(aLoL) == StringBuffersTag);

  strBufPrintfImpl(aStrBuf, "%s ", 
    getCStringImpl((StringBufferObj*)aLoL));
  return TRUE;
}
\stopCCode

\startCCode
// We need to protect our list walking printer from the possibility that a
// structure (and dictionaries will be) contain cycles...
//
// We do this by re-using the garbage collector's mark-sweep bit.
// This is crude and will certainly need to be chaged at some point...
// but it should work now... the likely future change will be to add
// further fields to the PairAtom structure.
// (or to use a hash table).
\stopCCode

\startCHeader
typedef void (PrintLoL)(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  CoAlgObj        *aLoL
);

#define printLoL(jInterp, aStrBuf, aLoL)       \ 
  (                                            \
    assert(getStringBuffersClass(jInterp)      \
      ->printLoLFunc),                         \
    (getStringBuffersClass(jInterp)            \
      ->printLoLFunc(jInterp, aStrBuf, aLoL))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
void printLoLImpl(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  CoAlgObj        *aLoL
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void printLoLImpl(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  CoAlgObj        *aLoL
) {
  DEBUG(jInterp, "printLoL %p %p\n", aStrBuf, aLoL);

  if (aLoL) {
    assert(asType(aLoL));
    Boolean result =
      (asType(aLoL)->printFunc)(jInterp, aStrBuf, aLoL);
    assert(result);
  }
}
\stopCCode
\startTestCase[should print stringBuffers]

\startCTest
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(getStringBuffersClass(jInterp));

  StringBufferObj* aTestStrBuf = newStringBuffer(jInterp);
  AssertPtrNotNull(aTestStrBuf);
  strBufPrintf(jInterp, aTestStrBuf, "test string");
  
  StringBufferObj* aStrBuf = newStringBuffer(jInterp);
  printStringBufferCoAlg(
    jInterp, aStrBuf, (CoAlgObj*)aTestStrBuf);
  AssertStrEquals(getCString(jInterp, aStrBuf), "test string ");
  
  strBufClose(jInterp, aStrBuf);
  printLoL(jInterp, aStrBuf, (CoAlgObj*)aTestStrBuf);
  AssertStrEquals(getCString(jInterp, aStrBuf), "test string ");
  strBufClose(jInterp, aStrBuf);
  strBufClose(jInterp, aTestStrBuf);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[registerStringBuffers]

\startCHeader
typedef struct stringBuffers_class_struct {
  CoAlgClass       super;
  NewStringBuffer *newStringBufferFunc;
  StrBufClose     *strBufCloseFunc;
  GetCString      *getCStringFunc;
  StrBufPrintf    *strBufPrintfFunc;
  PrintLoL        *printLoLFunc;
} StringBuffersClass;
\stopCHeader

\startCCode
static Boolean initializeStringBuffers(
  JoyLoLInterp *jInterp,
  CoAlgClass   *aCoAlgClass
) {
  assert(jInterp);
  assert(aCoAlgClass);
  registerStringBufferWords(jInterp);
  return TRUE;
}
\stopCCode

\setCHeaderStream{private}
\startCHeader
extern Boolean registerStringBuffers(JoyLoLInterp* jInterp);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean registerStringBuffers(JoyLoLInterp* jInterp) {
  assert(jInterp);
  assert(jInterp->coAlgs);
  
  StringBuffersClass* theCoAlg  =
    joyLoLCalloc(1, StringBuffersClass);
  theCoAlg->super.name            = StringBuffersName;
  theCoAlg->super.objectSize      = sizeof(StringBufferObj);
  theCoAlg->super.initializeFunc  = initializeStringBuffers;
  theCoAlg->super.equalityFunc    = stringBuffersEqual;
  theCoAlg->super.printFunc       = printStringBufferCoAlg;
  theCoAlg->newStringBufferFunc   = newStringBufferImpl;
  theCoAlg->strBufCloseFunc       = strBufCloseImpl;
  theCoAlg->getCStringFunc        = getCStringImpl;
  theCoAlg->strBufPrintfFunc      = strBufPrintfImpl;
  theCoAlg->printLoLFunc          = printLoLImpl;
  size_t tag =
    registerCoAlgClass(jInterp, (CoAlgClass*)theCoAlg);
  
  // sanity check...
  assert(tag == StringBuffersTag);
  assert(jInterp->coAlgs[tag].sClass);

  return TRUE;
}
\stopCCode

\startTestCase[should register the stringBuffers coAlg]

\startCTest
  // CTestsSetup has already created a jInterp
  // and run registerStringBuffers
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs);
  AssertPtrNotNull(getStringBuffersClass(jInterp));
  StringBuffersClass *coAlg =
    getStringBuffersClass(jInterp);
  AssertIntTrue(registerStringBuffers(jInterp));
  AssertPtrNotNull(getStringBuffersClass(jInterp));
  AssertPtrEquals(getStringBuffersClass(jInterp), coAlg);
  AssertIntEquals(
    getStringBuffersClass(jInterp)->super.objectSize,
    sizeof(StringBufferObj)
  )
\stopCTest
\stopTestCase
\stopTestSuite
