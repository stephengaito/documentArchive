% A ConTeXt document [master document: coAlgs.tex]

\section[title=Instance Code]

%\setCHeaderStream{public}
\setCHeaderStream{unUsed}
\startCHeader
#ifndef JOYLOL_LISTS_H
#define JOYLOL_LISTS_H

// We mark Pairs/Atoms using the least significant three bits of the car
// pointer.
//
// The least significant bit is used as the mark-sweep marker.
#define MARK_SWEEP_MARKER       0x1L
// The next least significant bit is used as the print-sweep marker.
#define PRINT_MARKER            0x2L
// The next least signficant bit is used as the equal-sweep marker.
#define EQUAL_MARKER            0x4L

// The higher bits are used as a pointer to either a CoAlg object:
//#define AS_COALG(aPtr) ((CoAlgebra*)(((size_t)aPtr) & (~(MEM_ALIGNMENT))))
//#define AS_TAG(aPtr)   ((size_t)aPtr)

// A Pair consists of a pair of pointers the car and cdr pointers,
// pointing to another Pair/Atom.
//
// An Atom consists of a tag and a pointer pointing to either a
// String/Symbol or a Function.

typedef struct pair_atom_struct PairAtom; // pre-defined to break circular definition below

typedef struct pair_atom_struct {
  CoAlgebra*        coAlg;
  size_t            tag;
  union {
    Assertion*      assertion;
    Boolean         boolean;
    Context*        context;
    Description*    description;
    JoyLoLFunction* func;
    Natural         natural;
    Observation*    observation;
    Pair            pair;
    Symbol*         symbol;
  };
} PairAtom;

typedef struct list_block_struct {
  PairAtom* block;
  struct list_block_struct* nextBlock;
} ListBlock;

typedef struct list_memory_struct {
  ListBlock* rootListBlock;
  PairAtom*  freePairs;
} ListMemory;

ListMemory* createListMemory(void);

extern PairAtom* newPairAtom(CoAlgebras* coAlgs);

extern PairAtom* newPair(CoAlgebras* coAlgs, PairAtom* car, PairAtom* cdr);

extern PairAtom* copyLoL(CoAlgebras* coAlgs, PairAtom* aLoL);

#define equalLoL(lolA, lolB) equalLoLDebug(lolA, lolB, FALSE)
extern size_t equalLoLDebug(PairAtom* lolA, PairAtom* lolB, size_t debugFlag);

#endif
\stopCHeader

%\setCHeaderStream{private}
\setCHeaderStream{unUsed}
\startCHeader
#ifndef JOYLOL_LISTS_PRIVATE_H
#define JOYLOL_LISTS_PRIVATE_H

#define LIST_BLOCK_SIZE 1024

extern void collectGarbage(ListMemory* someListMemory);
extern void addListBlock(ListMemory* someListMemory);

#endif
\stopCHeader

\setCCodeStream{instance}
\startCCode
// do nothing!
\stopCCode

\setCCodeStream{unUsed}
\startCCode
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "coAlgs.h"
#include "coAlgs-private.h"

ListMemory* createListMemory(void) {
  ListMemory* someListMem = (ListMemory*) calloc(1, sizeof(ListMemory));
  assert(someListMem);

  // lazy initialization by addListBlock/newPairAtom
  someListMem->rootListBlock = NULL;
  someListMem->freePairs     = NULL;

  return someListMem;
}

void addListBlock(ListMemory* someListMem) {
  DEBUG(FALSE, "addListBlock > %p %zu\n", someListMem, (size_t)LIST_BLOCK_SIZE);

  // obtain a new list block
  ListBlock* aNewListBlock = (ListBlock*)calloc(1, sizeof(ListBlock));
  assert( !( ((long int)aNewListBlock) & ((long int)0x7) ) );

  // integrate this new list block into the linked list of
  // list blocks
  if ( someListMem->rootListBlock ) {
    ListBlock *lastListBlock = someListMem->rootListBlock;
    while ( lastListBlock->nextBlock ) {
      lastListBlock = lastListBlock->nextBlock;
    }
    assert(lastListBlock->nextBlock == NULL);
    lastListBlock->nextBlock = aNewListBlock;
  } else {
    someListMem->rootListBlock = aNewListBlock;
  }
  DEBUG(FALSE, "addListBlock = %p %p\n", someListMem, aNewListBlock);

  // make sure this list block has some PairAtoms
  aNewListBlock->block = (PairAtom*)calloc(LIST_BLOCK_SIZE, sizeof(PairAtom));
  assert( aNewListBlock->block );
  assert( !( ((long int)aNewListBlock->block) & ((long int)0x7) ) );

  // add these new pairAtoms to the free list
  PairAtom* nextPairAtom = aNewListBlock->block;
  PairAtom* lastPairAtom = nextPairAtom + LIST_BLOCK_SIZE - 1;
  for ( ; nextPairAtom < lastPairAtom ; nextPairAtom++ ) {
//    assert( !( ((long int)nextPairAtom) & ((long int)0x7) ) );
    nextPairAtom->pair.car = NULL;
    nextPairAtom->pair.cdr = nextPairAtom + 1;
  }
  nextPairAtom->pair.cdr = someListMem->freePairs;
  someListMem->freePairs = aNewListBlock->block;
  DEBUG(FALSE, "addListBlock < %p %p %p\n", someListMem,
        aNewListBlock, aNewListBlock->block);
}

void collectGarbage(ListMemory* someListMem) {
  DEBUG(FALSE, "collectGarbage %p\n", someListMem);
  // add a garbage collection mark-sweep here
}

PairAtom* newPairAtom(CoAlgebras* coAlgs) {
  assert(coAlgs);
  assert(coAlgs->pairs);
  ListMemory* someListMem = coAlgs->pairs->listMemory;
  // ensure there are some list blocks
  if ( ! someListMem->freePairs ) collectGarbage(someListMem);
  if ( ! someListMem->freePairs ) addListBlock(someListMem);
  assert(someListMem->freePairs);

  PairAtom* aNewPairAtom = someListMem->freePairs;
  someListMem->freePairs = aNewPairAtom->pair.cdr;

  aNewPairAtom->coAlg    = NULL;
  aNewPairAtom->pair.car = NULL;
  aNewPairAtom->pair.cdr = NULL;

  return aNewPairAtom;
}
\stopCCode


\starttyping
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "CuTest.h"

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/lists.h"
#include "joyLoL/lists_private.h"
#include "joyLoL/printer.h"

// suiteName: - Pairs CoAlgebra tests -

void Test_createPairsCoAlgebra(CuTest* tc) {
  CoAlgebras *coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Pairs* pairs = coAlgs->pairs;
  CuAssertPtrNotNull(tc, pairs);

  CuAssertPtrNotNull(tc, pairs->listMemory);
}

void Test_newListBlock(CuTest* tc) {
  // create the first list block and make sure it is properly integrated
  // into linked list of list blocks

  ListMemory* someListMem = createListMemory();

  CuAssertPtrNull(tc, someListMem->rootListBlock);
  CuAssertPtrNull(tc, someListMem->freePairs);

  addListBlock(someListMem);
  CuAssertPtrNotNull(tc, someListMem->rootListBlock);
  CuAssertPtrNotNull(tc, someListMem->rootListBlock->block);
  CuAssertPtrNull(tc, someListMem->rootListBlock->nextBlock);
  CuAssertPtrNotNull(tc, someListMem->freePairs);

  // check to make sure freePairs list is correctly linked
  PairAtom* nextPairAtom = someListMem->rootListBlock->block;
  PairAtom* lastPairAtom = nextPairAtom + LIST_BLOCK_SIZE - 1;
  for ( ; nextPairAtom < lastPairAtom ; nextPairAtom++ ) {
//    CuAssertTrue(tc, !( ((long int)nextPairAtom) & ((long int)0x7) ));
    CuAssertPtrNull(tc, nextPairAtom->pair.car);
    CuAssertPtrEquals(tc, nextPairAtom->pair.cdr, nextPairAtom + 1);
  }
  CuAssertPtrNull(tc, nextPairAtom->pair.cdr);
  CuAssertPtrEquals(tc, someListMem->freePairs, someListMem->rootListBlock->block);

  // add another list block
  PairAtom* oldFreePairs = someListMem->freePairs;
  addListBlock(someListMem);
  CuAssertPtrNotNull(tc, someListMem->rootListBlock->nextBlock);
  CuAssertPtrNotNull(tc, someListMem->rootListBlock->nextBlock->block);
  CuAssertPtrNull(tc, someListMem->rootListBlock->nextBlock->nextBlock);
  CuAssertPtrNotNull(tc, someListMem->freePairs);

  // check to make sure freePairs list is correctly linked
  nextPairAtom = someListMem->rootListBlock->nextBlock->block;
  lastPairAtom = nextPairAtom + LIST_BLOCK_SIZE - 1;
  for ( ; nextPairAtom < lastPairAtom ; nextPairAtom++ ) {
//    CuAssertTrue(tc, !( ((long int)nextPairAtom) & ((long int)0x7) ));
    CuAssertPtrNull(tc, nextPairAtom->pair.car);
    CuAssertPtrEquals(tc, nextPairAtom->pair.cdr, nextPairAtom + 1);
  }
  CuAssertPtrEquals(tc, nextPairAtom->pair.cdr, oldFreePairs);
  CuAssertPtrEquals(tc, someListMem->freePairs, someListMem->rootListBlock->nextBlock->block);
}

void Test_newPairAtom(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  CuAssertPtrNotNull(tc, coAlgs->pairs);
  ListMemory* someListMem = coAlgs->pairs->listMemory;
  CuAssertPtrNotNull(tc, someListMem);

  CuAssertPtrNotNull(tc, someListMem->freePairs);
  PairAtom* oldFreePairs = someListMem->freePairs;
  PairAtom* newFreePairs = someListMem->freePairs->pair.cdr;

  PairAtom* aNewPair = newPairAtom(coAlgs);
  CuAssertPtrNotNull(tc, aNewPair );
  CuAssertPtrNull(tc, aNewPair->pair.car);
  CuAssertPtrNull(tc, aNewPair->pair.cdr);
  CuAssertPtrEquals(tc, oldFreePairs, aNewPair);
  CuAssertPtrEquals(tc, newFreePairs, someListMem->freePairs);
}

void Test_printPairs(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  CuAssertPtrNotNull(tc, coAlgs->pairs);

  PairAtom* aNewPair = newPair(coAlgs,
                               newPair(coAlgs, NULL, NULL),
                               newPair(coAlgs, NULL, NULL));
  CuAssertPtrNotNull(tc, aNewPair);
  CuAssertIntEquals(tc, printSizeDebug(aNewPair, FALSE), 28);
  CuAssertStrEquals(tc, printLoLDebug(aNewPair, FALSE), "( ( ) ) ( )");
}

void Test_allocateLotsOfPairAtoms(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);

  PairAtom* aNewPair = NULL;
  for ( size_t i = 0; i < 3*LIST_BLOCK_SIZE; i++ ) {
    aNewPair = newPairAtom(coAlgs);
  }
  CuAssertPtrNotNull(tc, aNewPair);
  CuAssertPtrNull(tc, aNewPair->pair.car);
  CuAssertPtrNull(tc, aNewPair->pair.cdr);
}
\stoptyping
