% A ConTeXt document [master document: coAlgs.tex]

\section[title=Class Code]

\setCHeaderStream{public}
\setCCodeStream{class}
\setCTestStream{class}
\addCTestInclude{<joylol/coAlgs.h>}

In this section we concentrate on the C code required to implement the 
kernel JoyLoL CoAlgebra. The CoAlgebra, \type{CoAlg}, is the base of the 
JoyLoL interpreter. This CoAlgebra has two parts, a \quote{class} part, 
and an \quote{instance} part. This class part manages the loading, 
registration and listing of new \quote{external} CoAlgebras. The instance 
part, discussed in the next section, manages the creation and removal of 
CoAlgebra \quote{values} (more commonly know as \quote{object} instances). 

We begin by setting up some standard C header defines, the most important 
of which deal with memory allocation and alignment as well as a simple 
\type{DEBUG} system. 

\startCHeader
#include <stdlib.h>
#include <string.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#ifndef JOYLOL_SYSTEM_CONFIG_PATH
#define JOYLOL_SYSTEM_CONFIG_PATH "/usr/local/etc/joyLoL"
#endif

#ifndef JOYLOL_SYSTEM_PLUGINS_PATH
#define JOYLOL_SYSTEM_PLUGINS_PATH "/usr/local/lib/joyLoL"
#endif

#ifndef JOYLOL_COALGS_INCREMENT
#define JOYLOL_COALGS_INCREMENT 10
#endif
 
#ifndef NULL
#define NULL (void*)0
#endif

#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

#define MEM_ALIGNMENT ((size_t)0x7)
#define IS_MEM_ALIGNED(someMem) \
  (!( ((size_t)(someMem)) & (MEM_ALIGNMENT) ))

extern void* joyLoLCalloc0(size_t numItems, size_t sizeOfItem);
#define joyLoLCalloc(numItems, itemType) \
  (itemType*)joyLoLCalloc0((numItems), sizeof(itemType))

#ifndef NDEBUG
#include <stdio.h>
#define DEBUG(debugFlag, format, ... ) \
  if (debugFlag) { printf( format, __VA_ARGS__ ); fflush(stdout); }
#else
#define DEBUG(...)
#endif
\stopCHeader

The ANSI-C implementation of a CoAlgebra is as a simple \type{struct} 
which contains the following items:

\startitemize

\item a \type{size_t} value which is unique for each registered CoAlgebra 
and hence acting as a test for identity, 

\item a \type{Symbol} value which provides a human readable \emph{name} 
for the CoAlgebra, 

\item a \type{C-function} which (recursively) tests for equality of two 
CoAlgebra instances of given type of CoAlgebra.

\item a \type{C-function} with (re)registers a given CoAlgebra with the 
JoyLoL interpreter. This registration function's primary purpose is two 
fold. It registers the CoAlgebra with the central collection of known 
CoAlgebras (to be discussed in the next subsection, below), as well as 
registers the individual JoyLoL functions provided by the CoAlgebra with 
the interpreter's dictionary of words. 

\stopitemize

\startCHeader
typedef struct coalgebras_struct        CoAlgebras;
typedef struct coalgebra_struct         CoAlgebra;
typedef struct coalgebra_handle_struct  CoAlgHandle;
typedef const char                      Symbol;

typedef size_t (CoAlgRegister)(lua_State*);
typedef size_t (CoAlgEquality)(CoAlgebra*,
                               CoAlgHandle*,
                               CoAlgHandle*,
                               size_t);
//typedef size_t (CoAlgPrintStr)(CoAlgHandle*, char*, size_t);
typedef void *CoAlgData;

typedef struct coalgebra_struct {
  size_t          isA;
  Symbol*         name;
  CoAlgRegister*  registerFunc;
  CoAlgEquality*  equalityFunc;
  //CoAlgPrintStr*  printStrFunc;
  CoAlgData       coAlgData;
} CoAlgebra;
\stopCHeader

\component gitVersion-c

\startTestSuite[set/get Lua-state global CoAlgebras LightUserData]

We want the ability to have different collections of loaded CoAlgebras for 
each Lua state. However, we also need fast access to the C-implementations 
of the loaded CoAlgebras. To achieve this we use the Lua Registry with the 
\quote{well-known} key \type{coAlgebrasKey}. We store a pointer to the 
collection of registered CoAlgebras, as a LightUserData, in the Lua 
registry under the key \type{coAlgebrasKey}, so that it is only accessible 
by the C implementation of any CoAlgebra. This ensures that the pointer to 
CoAlgebras is unique for any particular Lua state, but can be different 
for each distinct Lua state. 

This means that \type{coAlgebrasKey} must be a symbol which is unique in 
the loaded executable, but has no meaningful value \emph{other than} its 
location in memory. It is declared external in \type{coAlg.h} and is 
declared \emph{only} in the \type{coAlg.so} itself. 

\startCHeader
extern void* coAlgebrasKey;

extern CoAlgebras* getCoAlgebras(lua_State *lstate);
extern void setCoAlgebras(lua_State *lstate, CoAlgebras* coAlgs);
\stopCHeader

\startCCode
void* coAlgebrasKey = NULL;

CoAlgebras* getCoAlgebras(lua_State *lstate) {
  lua_rawgetp(lstate, LUA_REGISTRYINDEX, (void *)&coAlgebrasKey);
  CoAlgebras* coAlgs = (CoAlgebras*)lua_touserdata (lstate, -1);
  lua_pop(lstate, 1);
  return coAlgs;
}

void setCoAlgebras(lua_State *lstate, CoAlgebras* coAlgs) {
  lua_pushlightuserdata (lstate, (void *)coAlgs);
  lua_rawsetp(lstate, LUA_REGISTRYINDEX, (void *)&coAlgebrasKey);
}
\stopCCode

\startTestCase[should set and get a Lua-State global CoAlgebras LightUserData]

\startCTest
  CoAlgebras* luaCoAlgs = getCoAlgebras(lstate);
  AssertPtrNull(luaCoAlgs);
  CoAlgebras* coAlgs = (CoAlgebras*)0x100;
  setCoAlgebras(lstate, coAlgs);
  luaCoAlgs = getCoAlgebras(lstate);
  AssertPtrEquals(luaCoAlgs, coAlgs);
  CoAlgebras* newCoAlgs = (CoAlgebras*)0x200;
  setCoAlgebras(lstate, newCoAlgs);
  luaCoAlgs = getCoAlgebras(lstate);
  AssertPtrNotEquals(luaCoAlgs, coAlgs);
  AssertPtrEquals(luaCoAlgs, newCoAlgs);
  setCoAlgebras(lstate, NULL);
  luaCoAlgs = getCoAlgebras(lstate);
  AssertPtrNull(luaCoAlgs);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[registerCoAlgebra]

The CoAlgebras structure provides access to all of the CoAlgebras known to 
a given JoyLoL interpreter. As such it will be accessed repeatedly, so 
should probably be accessible with as few memory accesses as possible. 

\startCHeader
typedef struct coalgebras_struct {
  size_t numCoAlgs;
  size_t maxNumCoAlgs;
} CoAlgebras;

#define getCoAlgebrasVector(coAlgs) \
  (CoAlgebra*) (((void*)(coAlgs)) + sizeof(CoAlgebras))

#define sizeofCoAlgebras(numCoAlgs) \
  (sizeof(CoAlgebras) + sizeof(CoAlgebra)*(numCoAlgs))
  
extern size_t registerCoAlgebra(
  lua_State     *lstate,
  Symbol        *name,
  CoAlgRegister *registerFunc,
  CoAlgEquality *equalityFunc,
  CoAlgData      coAlgData
);
\stopCHeader

\startCCode
size_t registerCoAlgebra(
  lua_State     *lstate,
  Symbol        *name,
  CoAlgRegister *registerFunc,
  CoAlgEquality *equalityFunc,
  CoAlgData     coAlgData
) {
  CoAlgebras* coAlgs    = getCoAlgebras(lstate);
  CoAlgebra*  coAlgsVec = NULL;

  // we follow a policy of lazy management of the coAlgs
  // if coAlgs is NULL, we create a new one
  // if coAlgs is too small we expand it
  if (!coAlgs) {
    // we need to create a new coAlgs structure...
    //
    coAlgs = (CoAlgebras*)
      calloc(1, sizeofCoAlgebras(JOYLOL_COALGS_INCREMENT));
    assert(coAlgs);
    setCoAlgebras(lstate, coAlgs);
    
    coAlgs->numCoAlgs    = 0;
    coAlgs->maxNumCoAlgs = JOYLOL_COALGS_INCREMENT;
  }
  coAlgsVec = getCoAlgebrasVector(coAlgs);
  assert((((void*)coAlgsVec)-((void*)coAlgs)) == sizeof(CoAlgebras));

  for(size_t i = 0; i < coAlgs->numCoAlgs; i++ ) {
    if (strcmp(name, coAlgsVec[i].name) == 0) {
    
      // a coAlgebra with this name has already been registered. 
      // so return its index...
      return i;
    }
  }
  
  if (coAlgs->maxNumCoAlgs <= coAlgs->numCoAlgs) {
    // we need to expand the existing coAlgs structure...
    //  
    CoAlgebras *oldCoAlgs  = coAlgs;
    
    size_t oldNumCoAlgs    = coAlgs->numCoAlgs;
    size_t oldMaxNumCoAlgs = coAlgs->maxNumCoAlgs;
    
    size_t newMaxNumCoAlgs =
      oldMaxNumCoAlgs + JOYLOL_COALGS_INCREMENT;

    coAlgs = calloc(1, sizeofCoAlgebras(newMaxNumCoAlgs));
    assert(coAlgs);
    setCoAlgebras(lstate, coAlgs);
    
    if (oldCoAlgs) {
      memcpy(coAlgs, oldCoAlgs,
        sizeofCoAlgebras(oldNumCoAlgs));
      free(oldCoAlgs);
    }
    
    coAlgs->numCoAlgs    = oldNumCoAlgs;
    coAlgs->maxNumCoAlgs = newMaxNumCoAlgs;

    coAlgsVec = getCoAlgebrasVector(coAlgs);
  }
  assert((((void*)coAlgsVec)-((void*)coAlgs)) == sizeof(CoAlgebras));
  
  size_t newCoAlg = coAlgs->numCoAlgs;
  
  coAlgsVec[newCoAlg].isA           = newCoAlg;
  coAlgsVec[newCoAlg].name          = strdup(name);
  coAlgsVec[newCoAlg].registerFunc  = registerFunc;
  coAlgsVec[newCoAlg].equalityFunc  = equalityFunc;
  coAlgsVec[newCoAlg].coAlgData     = coAlgData;
  
  coAlgs->numCoAlgs++;
  
  return newCoAlg;
}
\stopCCode

\startTestCase[should create a new coAlgs]

We start by adding one single coAlg, this tests the creation of a 
completely new CoAlgebras structure. 

\startCTest
  char*          coAlgName        = strdup("newCoAlgA");
  char*          coAlgNameEnd     = coAlgName + strlen("newCoAlg");
  CoAlgRegister* fakeRegisterFunc = (CoAlgRegister*) 0x100;
  CoAlgEquality* fakeEqualityFunc = (CoAlgEquality*) 0x200;
  CoAlgData*     fakeCoAlgData    = (CoAlgData*)     0x300;
  
  registerCoAlgebra(lstate, coAlgName,
      fakeRegisterFunc, fakeEqualityFunc, fakeCoAlgData);
  CoAlgebras *coAlgs = getCoAlgebras(lstate);
  AssertPtrNotNull(coAlgs);
  CoAlgebra *coAlgsVec = getCoAlgebrasVector(coAlgs);
  AssertIntEquals(
    (((void*)coAlgsVec)-((void*)coAlgs)),
    sizeof(CoAlgebras)
  );
  AssertPtrNotNull(coAlgsVec);
  AssertIntEquals(coAlgsVec[0].isA, 0);
  AssertStrEquals(coAlgsVec[0].name, "newCoAlgA");
  AssertPtrEquals(coAlgsVec[0].registerFunc, fakeRegisterFunc);
  AssertPtrEquals(coAlgsVec[0].equalityFunc, fakeEqualityFunc);
  AssertPtrEquals(coAlgsVec[0].coAlgData,    fakeCoAlgData);
\stopCTest

Now we want to test the expansion of an existing CoAlgebras structure when 
the existing one runs out of \quote{space}. 

\startCTest
  AssertIntTrue(JOYLOL_COALGS_INCREMENT < 26);
  for(int i = 1; i < 26; i++) {
    CoAlgebras *oldCoAlgs = coAlgs;
    *coAlgNameEnd         = 'A' + i;
    fakeRegisterFunc     += 1;
    fakeEqualityFunc     += 1;
    fakeCoAlgData        += 1;
    registerCoAlgebra(lstate, coAlgName,
      fakeRegisterFunc, fakeEqualityFunc, fakeCoAlgData);
    coAlgs = getCoAlgebras(lstate);
    AssertPtrNotNull(coAlgs);
    if (i%JOYLOL_COALGS_INCREMENT) {
      AssertPtrEquals(oldCoAlgs, coAlgs);
    } else {
      AssertPtrNotEquals(oldCoAlgs, coAlgs);
    }
    CoAlgebra *coAlgsVec = getCoAlgebrasVector(coAlgs);
    AssertIntEquals(
      (((void*)coAlgsVec)-((void*)coAlgs)),
      sizeof(CoAlgebras)
    );
    AssertPtrNotNull(coAlgsVec);
    AssertIntEquals(coAlgsVec[i].isA, i);
    AssertStrEquals(coAlgsVec[i].name, coAlgName);
    AssertPtrEquals(coAlgsVec[i].registerFunc, fakeRegisterFunc);
    AssertPtrEquals(coAlgsVec[i].equalityFunc, fakeEqualityFunc);
    AssertPtrEquals(coAlgsVec[i].coAlgData,    fakeCoAlgData);
  }
\stopCTest

Now we want to test the addition of CoAlgebra with an existing name does 
not change the number of registered CoAlgebras but simple returns the 
existing CoAlgebra index. 

\startCTest
  CoAlgebras* oldCoAlgs = getCoAlgebras(lstate);
  size_t oldNumCoAlgs = oldCoAlgs->numCoAlgs;
  size_t anIndex = 
    registerCoAlgebra(lstate, "newCoAlgF", NULL, NULL, NULL);
  coAlgs = getCoAlgebras(lstate);
  AssertIntEquals(anIndex, 5);
  AssertPtrEquals(oldCoAlgs, coAlgs);
  AssertIntEquals(oldNumCoAlgs, coAlgs->numCoAlgs);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[getGitVersion]

We need a generic way of obtaining the git version of a given CoAlgebra. 
We do this in two parts. In the \type{bin} directory of any (collection 
of) CoAlgebra(s) there should be a pair of shell scripts. The 
\type{gitHook.sh} is a \type{bash} shell script which is run at various 
points in the git event cycle to capture the git version information into 
either a C-header file or a Lua file. These files can then be loaded as 
needed into either a C-implementation or required by Lua code, to provide 
information about the version of a given code artefact. The \type{bin} 
directory should also contain a \type{setupGitHooks} \type{bash} script 
which copies the \type{gitHook.sh} script into the correct places in the 
\type{.git} directory. 

For CoAlgebras implemented in ANSI-C, the following function will take the 
git version information in the \type{gitVersion.h} file which is 
statically linked in a given CoAlgabra's shared library and return the 
value associated with any valid key requested. 

\startCHeader
typedef struct keyValueStruct {
  const char *key;
  const char *value;
} KeyValues;

extern const char *getGitVersion(const KeyValues *gitVersion, 
                                 const char* gitVersionKey);
\stopCHeader

\startCCode
const char *getGitVersion(const KeyValues *gitVersion,
                          const char* gitVersionKey) {
  for(int i = 0 ; gitVersion[i].key ; i++) {
    if (strcmp(gitVersionKey, gitVersion[i].key) == 0) {
      return gitVersion[i].value;
    }
  }
  return "key not found";
}
\stopCCode

At the moment we can only (easily) test the \type{getGitVersion} function.

\startTestCase[should get value associated with keys]
\startCTest
  static const KeyValues testKVs[] = {
    { "key1", "value1" },
    { "key2", "value2" },
    { NULL,   NULL }
  };
  const char* aValue = getGitVersion(testKVs, "key1");
  AssertPtrNotNull(aValue);
  AssertStrEquals(aValue, "value1");
  aValue = getGitVersion(testKVs, "key2");
  AssertPtrNotNull(aValue);
  AssertStrEquals(aValue, "value2");
  aValue = getGitVersion(testKVs, "noKey");
  AssertPtrNotNull(aValue);
  AssertStrEquals(aValue, "key not found");
\stopCTest
\stopTestCase
\stopTestSuite

\subsection[title=Old tests]

\starttyping
  printf("\nStructure Sizes\n");
  printf("              void* = %zu bytes\n", sizeof(void*));
  printf("                int = %zu bytes\n", sizeof(int));
  printf("           long int = %zu bytes\n", sizeof(long int));
  printf("\n");

  PairAtom aPairAtom;
  printf("           PairAtom = %zu bytes\n", sizeof(PairAtom));
  printf("     PairAtom.coAlg = %zu bytes\n", sizeof(aPairAtom.coAlg));
  printf("       PairAtom.tag = %zu bytes\n", sizeof(aPairAtom.tag));
  printf("      PairAtom.pair = %zu bytes\n", sizeof(aPairAtom.pair));
  printf("  PairAtom.pair.car = %zu bytes\n", sizeof(aPairAtom.pair.car));
  printf("  PairAtom.pair.cdr = %zu bytes\n", sizeof(aPairAtom.pair.cdr));
  printf("   PairAtom.boolean = %zu bytes\n", sizeof(aPairAtom.boolean));
  printf("    PairAtom.symbol = %zu bytes\n", sizeof(aPairAtom.symbol));
  printf("      PairAtom.func = %zu bytes\n", sizeof(aPairAtom.func));
  printf("   PairAtom.natural = %zu bytes\n", sizeof(aPairAtom.natural));
  printf("\n");

  ListBlock aListBlock;
  printf("          ListBlock = %zu bytes\n", sizeof(ListBlock));
  printf("    ListBlock.block = %zu bytes\n", sizeof(aListBlock.block));
  printf("ListBlock.nextBlock = %zu bytes\n", sizeof(aListBlock.nextBlock));
  printf("\n");
\stoptyping

%\startsyntax

%\stopsyntax 

%\startinitialization

%\stopinitialization
