% A ConTeXt document [master document: coAlgs.tex]

\section[title=Class Code]

\setCHeaderStream{public}
\setCCodeStream{class}
\setCTestStream{class}
\addCTestInclude{<coAlgs.h>}

In this section we concentrate on the C code required to implement the 
kernel JoyLoL CoAlgebra. The CoAlgebra, \type{CoAlg}, is the base of the 
JoyLoL interpreter. This CoAlgebra has two parts, a \quote{class} part, 
and an \quote{instance} part. This class part manages the loading, 
registration and listing of new \quote{external} CoAlgebras. The instance 
part, discussed in the next section, manages the creation and removal of 
CoAlgebra \quote{values} (more commonly know as \quote{object} instances). 

We begin by setting up some standard C header defines, the most important 
of which deal with memory allocation and alignment as well as a simple 
\type{DEBUG} system. 

\startCHeader
#include <stdlib.h>
#include <string.h>

#ifndef JOYLOL_SYSTEM_CONFIG_PATH
#define JOYLOL_SYSTEM_CONFIG_PATH "/usr/local/etc/joyLoL"
#endif

#ifndef JOYLOL_SYSTEM_PLUGINS_PATH
#define JOYLOL_SYSTEM_PLUGINS_PATH "/usr/local/lib/joyLoL"
#endif

#ifndef JOYLOL_COALGS_INCREMENT
#define JOYLOL_COALGS_INCREMENT 10
#endif
 
#ifndef NULL
#define NULL (void*)0
#endif

#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

#define MEM_ALIGNMENT ((size_t)0x7)
#define IS_MEM_ALIGNED(someMem) \
  (!( ((size_t)(someMem)) & (MEM_ALIGNMENT) ))

extern void* joyLoLCalloc0(size_t numItems, size_t sizeOfItem);
#define joyLoLCalloc(numItems, itemType) \
  (itemType*)joyLoLCalloc0((numItems), sizeof(itemType))

#ifndef NDEBUG
#include <stdio.h>
#define DEBUG(debugFlag, format, ... ) \
  if (debugFlag) { printf( format, __VA_ARGS__ ); fflush(stdout); }
#else
#define DEBUG(...)
#endif
\stopCHeader

The ANSI-C implementation of a CoAlgebra is as a simple \type{struct} 
which contains the following items:

\startitemize

\item a \type{size_t} value which is unique for each registered CoAlgebra 
and hence acting as a test for identity, 

\item a \type{Symbol} value which provides a human readable \emph{name} 
for the CoAlgebra, 

\item a \type{C-function} which (recursively) tests for equality of two 
CoAlgebra instances of given type of CoAlgebra.

\item a \type{C-function} with (re)registers a given CoAlgebra with the 
JoyLoL interpreter. This registration function's primary purpose is two 
fold. It registers the CoAlgebra with the central collection of known 
CoAlgebras (to be discussed in the next subsection, below), as well as 
registers the individual JoyLoL functions provided by the CoAlgebra with 
the interpreter's dictionary of words. 

\stopitemize

\startCHeader
typedef struct coalgebras_struct        CoAlgebras;
typedef struct coalgebra_struct         CoAlgebra;
typedef struct coalgebra_handle_struct  CoAlgHandle;
typedef const char Symbol;

typedef size_t (CoAlgRegister)(CoAlgebras*);
typedef size_t (CoAlgEquality)(CoAlgebra*,
                               CoAlgHandle*,
                               CoAlgHandle*,
                               size_t);
//typedef size_t (CoAlgPrintStr)(CoAlgHandle*, char*, size_t);
typedef void *CoAlgData;

typedef struct coalgebra_struct {
  size_t          isA;
  Symbol*         name;
  CoAlgRegister*  registerFunc;
  CoAlgEquality*  equalityFunc;
  //CoAlgPrintStr*  printStrFunc;
  CoAlgData       coAlgData;
} CoAlgebra;
\stopCHeader

\startTestSuite[registerCoAlgebra]

The CoAlgebras structure provides access to all of the CoAlgebras known to 
a given JoyLoL interpreter. As such it will be accessed repeatedly, so 
should probably be accessible with as few memory accesses as possible. 

\startCHeader
typedef struct coalgebras_struct {
  size_t numCoAlgs;
  size_t maxNumCoAlgs;
} CoAlgebras;

#define getCoAlgebrasVector(coAlgs) \
  (CoAlgebra*) (((void*)(coAlgs)) + sizeof(CoAlgebras))

#define sizeofCoAlgebras(numCoAlgs) \
  (sizeof(CoAlgebras) + sizeof(CoAlgebra)*(numCoAlgs))
  
extern CoAlgebras *registerCoAlgebra(
  CoAlgebras *coAlgs,
  Symbol *name,
  CoAlgRegister *registerFunc,
  CoAlgEquality *equalityFunc,
  CoAlgData     coAlgData
);
\stopCHeader

\startCCode
CoAlgebras *registerCoAlgebra(
  CoAlgebras *coAlgs,
  Symbol *name,
  CoAlgRegister *registerFunc,
  CoAlgEquality *equalityFunc,
  CoAlgData     coAlgData
) {
  CoAlgebra* coAlgsVec;

  // we follow a policy of lazy management of the coAlgs
  // if coAlgs is NULL, we create a new one
  // if coAlgs is too small we expand it
  if (!coAlgs) {
    // we need to create a new coAlgs structure...
    //
    coAlgs = (CoAlgebras*)
      calloc(1, sizeofCoAlgebras(JOYLOL_COALGS_INCREMENT));
    assert(coAlgs);
    
    coAlgs->numCoAlgs    = 0;
    coAlgs->maxNumCoAlgs = JOYLOL_COALGS_INCREMENT;
  }
  coAlgsVec = getCoAlgebrasVector(coAlgs);
  assert((((void*)coAlgsVec)-((void*)coAlgs)) == sizeof(CoAlgebras));

  if (coAlgs->maxNumCoAlgs <= coAlgs->numCoAlgs) {
    // we need to expand the existing coAlgs structure...
    //  
    CoAlgebras *oldCoAlgs  = coAlgs;
    
    size_t oldNumCoAlgs    = coAlgs->numCoAlgs;
    size_t oldMaxNumCoAlgs = coAlgs->maxNumCoAlgs;
    
    size_t newMaxNumCoAlgs =
      oldMaxNumCoAlgs + JOYLOL_COALGS_INCREMENT;

    coAlgs = calloc(1, sizeofCoAlgebras(newMaxNumCoAlgs));
    assert(coAlgs);
    
    if (oldCoAlgs) {
      memcpy(coAlgs, oldCoAlgs,
        sizeofCoAlgebras(oldNumCoAlgs));
      free(oldCoAlgs);
    }
    
    coAlgs->numCoAlgs    = oldNumCoAlgs;
    coAlgs->maxNumCoAlgs = newMaxNumCoAlgs;

    coAlgsVec = getCoAlgebrasVector(coAlgs);
  }
  assert((((void*)coAlgsVec)-((void*)coAlgs)) == sizeof(CoAlgebras));
  
  size_t newCoAlg = coAlgs->numCoAlgs;
  
  coAlgsVec[newCoAlg].isA           = newCoAlg;
  coAlgsVec[newCoAlg].name          = strdup(name);
  coAlgsVec[newCoAlg].registerFunc  = registerFunc;
  coAlgsVec[newCoAlg].equalityFunc  = equalityFunc;
  coAlgsVec[newCoAlg].coAlgData     = coAlgData;
  
  coAlgs->numCoAlgs++;
  
  return coAlgs;
}
\stopCCode

\startTestCase[should create a new coAlgs]

We start by adding one single coAlg, this tests the creation of a 
completely new CoAlgebras structure. 

\startCTest
  char*          coAlgName        = strdup("newCoAlgA");
  char*          coAlgNameEnd     = coAlgName + strlen("newCoAlg");
  CoAlgRegister* fakeRegisterFunc = (CoAlgRegister*) 0x100;
  CoAlgEquality* fakeEqualityFunc = (CoAlgEquality*) 0x200;
  CoAlgData*     fakeCoAlgData    = (CoAlgData*)     0x300;
  
  CoAlgebras *coAlgs =
    registerCoAlgebra(NULL, coAlgName,
      fakeRegisterFunc, fakeEqualityFunc, fakeCoAlgData);
  AssertPtrNotNull(coAlgs);
  CoAlgebra *coAlgsVec = getCoAlgebrasVector(coAlgs);
  AssertIntEquals(
    (((void*)coAlgsVec)-((void*)coAlgs)),
    sizeof(CoAlgebras)
  );
  AssertPtrNotNull(coAlgsVec);
  AssertIntEquals(coAlgsVec[0].isA, 0);
  AssertStrEquals(coAlgsVec[0].name, "newCoAlgA");
  AssertPtrEquals(coAlgsVec[0].registerFunc, fakeRegisterFunc);
  AssertPtrEquals(coAlgsVec[0].equalityFunc, fakeEqualityFunc);
  AssertPtrEquals(coAlgsVec[0].coAlgData,    fakeCoAlgData);
\stopCTest

Now we want to test the expansion of an existing CoAlgebras structure when 
the existing one runs out of \quote{space}. 

\startCTest
  AssertIntTrue(JOYLOL_COALGS_INCREMENT < 26);
  for(int i = 1; i < 26; i++) {
    CoAlgebras *oldCoAlgs = coAlgs;
    *coAlgNameEnd         = 'A' + i;
    fakeRegisterFunc     += 1;
    fakeEqualityFunc     += 1;
    fakeCoAlgData        += 1;
    coAlgs = registerCoAlgebra(coAlgs, coAlgName,
      fakeRegisterFunc, fakeEqualityFunc, fakeCoAlgData);
    AssertPtrNotNull(coAlgs);
    if (i%JOYLOL_COALGS_INCREMENT) {
      AssertPtrEquals(oldCoAlgs, coAlgs);
    } else {
      AssertPtrNotEquals(oldCoAlgs, coAlgs);
    }
    CoAlgebra *coAlgsVec = getCoAlgebrasVector(coAlgs);
    AssertIntEquals(
      (((void*)coAlgsVec)-((void*)coAlgs)),
      sizeof(CoAlgebras)
    );
    AssertPtrNotNull(coAlgsVec);
    AssertIntEquals(coAlgsVec[i].isA, i);
    AssertStrEquals(coAlgsVec[i].name, coAlgName);
    AssertPtrEquals(coAlgsVec[i].registerFunc, fakeRegisterFunc);
    AssertPtrEquals(coAlgsVec[i].equalityFunc, fakeEqualityFunc);
    AssertPtrEquals(coAlgsVec[i].coAlgData,    fakeCoAlgData);
  }
\stopCTest
\stopTestCase
\stopTestSuite

\subsection[title=createCoAlgebras]

\startCHeader
extern CoAlgebras* createCoAlgebras(void);
\stopCHeader
\startCCode
CoAlgebras* createCoAlgebras(void) {
//  CoAlgebras* coAlgs = (CoAlgebras*) calloc(1, sizeof(CoAlgebras));
  CoAlgebras* coAlgs = NULL;
//  assert(coAlgs);


  // create all the known coAlgebras
//  coAlgs->assertions    = createAssertionsCoAlgebra();
//  coAlgs->booleans      = createBooleansCoAlgebra();
//  coAlgs->contexts      = createContextsCoAlgebra();
//  coAlgs->descriptions  = createDescriptionsCoAlgebra();
//  coAlgs->functions     = createFunctionsCoAlgebra();
//  coAlgs->naturals      = createNaturalsCoAlgebra();
//  coAlgs->observations  = createObservationsCoAlgebra();
//  coAlgs->pairs         = createPairsCoAlgebra();
//  coAlgs->proofs        = createProofsCoAlgebra();
//  coAlgs->symbols       = createSymbolsCoAlgebra();

  // initialize all the known coAlgebras
// need to initialize this first for listMemory
//  initPairsCoAlgebra(coAlgs); 

//  initAssertionsCoAlgebra(coAlgs);
//  initBooleansCoAlgebra(coAlgs);
//  initContextsCoAlgebra(coAlgs);
//  initDescriptionsCoAlgebra(coAlgs);
//  initFunctionsCoAlgebra(coAlgs);
//  initNaturalsCoAlgebra(coAlgs);
//  initObservationsCoAlgebra(coAlgs);
//  initProofsCoAlgebra(coAlgs);
//  initSymbolsCoAlgebra(coAlgs);

  return coAlgs;
}
\stopCCode

\startCHeader
//#include "joyLoL/coAlg/assertions.h"
//#include "joyLoL/coAlg/booleans.h"
//#include "joyLoL/coAlg/contexts.h"
//#include "joyLoL/coAlg/descriptions.h"
//#include "joyLoL/coAlg/functions.h"
//#include "joyLoL/coAlg/naturals.h"
//#include "joyLoL/coAlg/observations.h"
//#include "joyLoL/coAlg/pairs.h"
//#include "joyLoL/coAlg/proofs.h"
//#include "joyLoL/coAlg/symbols.h"

#define ASSERTION_COALG    1
#define BOOLEAN_COALG      2
#define CONTEXT_COALG      3
#define DESCRIPTION_COALG  4
#define FUNCTION_COALG     5
#define NATURAL_COALG      6
#define OBSERVATION_COALG  7
#define PAIR_COALG         8
#define PROOF_COALG        9
#define SYMBOL_COALG       10
\stopCHeader

\subsection[title=Old tests]

\starttyping
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "CuTest.h"

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/lists.h"
#include "joyLoL/dictionary.h"
#include "joyLoL/dictionary_private.h"
#include "joyLoL/text.h"
#include "joyLoL/parser.h"
#include "joyLoL/printer.h"
#include "joyLoL/eval.h"
#include "joyLoL/eval_private.h"

// suiteName: - Base CoAlgebra tests -

void Test_reportSizes(CuTest* tc) {
  printf("\nStructure Sizes\n");
  printf("              void* = %zu bytes\n", sizeof(void*));
  printf("                int = %zu bytes\n", sizeof(int));
  printf("           long int = %zu bytes\n", sizeof(long int));
  printf("\n");

  PairAtom aPairAtom;
  printf("           PairAtom = %zu bytes\n", sizeof(PairAtom));
  printf("     PairAtom.coAlg = %zu bytes\n", sizeof(aPairAtom.coAlg));
  printf("       PairAtom.tag = %zu bytes\n", sizeof(aPairAtom.tag));
  printf("      PairAtom.pair = %zu bytes\n", sizeof(aPairAtom.pair));
  printf("  PairAtom.pair.car = %zu bytes\n", sizeof(aPairAtom.pair.car));
  printf("  PairAtom.pair.cdr = %zu bytes\n", sizeof(aPairAtom.pair.cdr));
  printf("   PairAtom.boolean = %zu bytes\n", sizeof(aPairAtom.boolean));
  printf("    PairAtom.symbol = %zu bytes\n", sizeof(aPairAtom.symbol));
  printf("      PairAtom.func = %zu bytes\n", sizeof(aPairAtom.func));
  printf("   PairAtom.natural = %zu bytes\n", sizeof(aPairAtom.natural));
  printf("\n");

  ListBlock aListBlock;
  printf("          ListBlock = %zu bytes\n", sizeof(ListBlock));
  printf("    ListBlock.block = %zu bytes\n", sizeof(aListBlock.block));
  printf("ListBlock.nextBlock = %zu bytes\n", sizeof(aListBlock.nextBlock));
  printf("\n");
}

void Test_createBaseCoAlgebras(CuTest* tc) {
  CoAlgebras *coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  CuAssertPtrNotNull(tc, coAlgs->booleans);
  CuAssertPtrNotNull(tc, coAlgs->contexts);
  CuAssertPtrNotNull(tc, coAlgs->functions);
  CuAssertPtrNotNull(tc, coAlgs->naturals);
  CuAssertPtrNotNull(tc, coAlgs->pairs);
  CuAssertPtrNotNull(tc, coAlgs->symbols);
}
\stoptyping

%\startsyntax

%\stopsyntax 

%\startinitialization

%\stopinitialization
