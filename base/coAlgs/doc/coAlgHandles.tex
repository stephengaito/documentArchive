% A ConTeXt document [master document: coAlgs.tex]

\section[title=CoAlgHandles]

Since the implementation of any particular CoAlgebraic extension will of 
necessity make use of \type{CoAlgHandle}s, we \emph{begin} by providing 
their implementation. While a programming \quote{handle} typically has no 
publicly accessible internal structure, our \type{CoAlgHandle}s have a 
simple three part structure. 

The first (type) part is a \type{CoAlgebra*} pointer to the data structure 
which represents the CoAlgebra for which the handle is a handle. This 
CoAlgebra pointer ensures that the implementation code knows what the 
given handle, is a handle \emph{for}, as well as what it can \emph{do}. 

The second (flag) part is a collection of bits to provide useful 
meta-flags associated with a handle. At least three of these meta-flags 
are reserved by the JoyLoL interpreter to signal ongoing garbage 
collection, equality determination as well as printing. Since any handle 
is potentially part of a cyclic structure, these meta-flags ensure garbage 
collection, equality detection and printing do not fall into infinite 
cycles. 

All non-reserved meta-flags may be used by the implementation of a 
CoAlgebra extension for its own internal purposes. Typically meta-flags 
might be used to signal how to interpret the data stored in the third 
(data) part of the handle. For the \type{Naturals} CoAlgebraic extension, 
a meta-flag will be used to signal that the handle's data part is a 
pointer to a Gnu Multi-precision integer, rather than to a double word 
integer. This allows significant speed optimizations in the typical cases, 
but allows for full data representations in rare but important cases. 

All reserved meta-flags will be located in low order bits of the flag data 
word. This ensures that any CoAlgebraic extension which makes use of 
meta-flags can simply rotate the reserved flags off the end of the word 
before making use of the non-reserved flags. In particular a CoAlgebraic 
extension \emph{could} interpret its flags as an integer or pointer. Such 
interpretations are private to each extension, and should \emph{not} be 
relied upon by code which is not part of the code's own extension. 

The third (data) part is a union of the four typical ways a \emph{pair} of 
words might be used. One important use case is as a pair of 
\type{CoAlgHandle*} pointers. The \emph{most} common use of a 
\type{CoAlgHandle} will be as a list \quote{pair}, which contains 
Lisp-like \type{car} and \type{cdr} pointers to other lists. However, the 
data part of a handle, can be used in any way in which an extension wishes 
to use them. For example the \type{Naturals} extension, might use this 
pair of words as alternatively, a double word integer, a pair of single 
word integers, or as a pointer to a more complex data structure. 

\setCHeaderStream{public}

We begin the implementation by pre-defining the three most important 
structures. We need to pre-define them here, since these three structures 
are mutually recursive. 

\startitemize

\item A \type{CoAlgebras} represents the collection of all CoAlgebraic 
extensions loaded into the current JoyLoL interpreter. Since all of the 
parts of an JoyLoL interpreter is \emph{implemented} in one or other 
CoAlgebraic extension, the \type{CoAlgebras} structure also represents a 
running JoyLoL interpreter. 

\startCHeader 
typedef struct coalgebras_struct CoAlgebras;
\stopCHeader 

\item A \type{CoAlgebra} represents the standard (class) data and (class 
or instance) methods associated with the implementation of a CoAlgebraic 
extension. 

\startCHeader
typedef struct coalgebra_struct CoAlgebra;
\stopCHeader

\item A \type{CoAlgHandle} represents a relatively opaque handle to one of 
many possible \emph{instances} of a CoAlgebra. 

\startCHeader
typedef struct coalgebra_handle_struct CoAlgHandle;
\stopCHeader 
\stopitemize

\startCHeader

#ifdef __LP64__
#define DoubleWord uint128_t
#else
#define DoubleWord uint64_t
#endif


typedef struct coalgebra_handle_struct {
  CoAlgebra*   coAlg;
  size_t       tag;  // an arbitrary collection of bits
  union {
    struct {
      CoAlgHandle* a;
      CoAlgHandle* b;
    } ptrs;
    struct {
      size_t a;
      size_t b;
    } words;
    struct {
      void* ptr;
      size_t wrd;
    } mixed;
    DoubleWord dword;
  };
} CoAlgHandle;
\stopCHeader

\startCHeader
// We mark CoAlgHandles using the least significant three bits of the car
// pointer.
//
// The least significant bit is used as the mark-sweep marker.
#define MARK_SWEEP_MARKER       0x1L
// The next least significant bit is used as the print-sweep marker.
#define PRINT_MARKER            0x2L
// The next least signficant bit is used as the equal-sweep marker.
#define EQUAL_MARKER            0x4L
\stopCHeader

\startCHeader
typedef struct handle_block_struct {
  CoAlgHandle* block;
  struct handle_block_struct* nextBlock;
} HandleBlock;

typedef struct handle_memory_struct {
  HandleBlock* rootHandleBlock;
  CoAlgHandle* freeHandles;
} HandleMemory;

HandleMemory* createHandleMemory(void);

extern CoAlgHandle* newHandle(CoAlgebras* coAlgs);
\stopCHeader

\setCHeaderStream{private}
\startCHeader
#define HANDLE_BLOCK_SIZE 1024

extern void collectGarbage(HandleMemory* someHandleMemory);
extern void addListBlock(HandleMemory* someHandleMemory);
\stopCHeader

\setCCodeStream{unused}
%\setCCodeStream{coAlgHandles}
\startCCode
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "joylol/coAlgs.h"
#include "joylol/coAlgs-private.h"

ListMemory* createListMemory(void) {
  ListMemory* someListMem = (ListMemory*) calloc(1, sizeof(ListMemory));
  assert(someListMem);

  // lazy initialization by addListBlock/newPairAtom
  someListMem->rootListBlock = NULL;
  someListMem->freePairs     = NULL;

  return someListMem;
}

void addListBlock(ListMemory* someListMem) {
  DEBUG(FALSE, "addListBlock > %p %zu\n", someListMem, (size_t)LIST_BLOCK_SIZE);

  // obtain a new list block
  ListBlock* aNewListBlock = (ListBlock*)calloc(1, sizeof(ListBlock));
  assert( !( ((long int)aNewListBlock) & ((long int)0x7) ) );

  // integrate this new list block into the linked list of
  // list blocks
  if ( someListMem->rootListBlock ) {
    ListBlock *lastListBlock = someListMem->rootListBlock;
    while ( lastListBlock->nextBlock ) {
      lastListBlock = lastListBlock->nextBlock;
    }
    assert(lastListBlock->nextBlock == NULL);
    lastListBlock->nextBlock = aNewListBlock;
  } else {
    someListMem->rootListBlock = aNewListBlock;
  }
  DEBUG(FALSE, "addListBlock = %p %p\n", someListMem, aNewListBlock);

  // make sure this list block has some PairAtoms
  aNewListBlock->block = (PairAtom*)calloc(LIST_BLOCK_SIZE, sizeof(PairAtom));
  assert( aNewListBlock->block );
  assert( !( ((long int)aNewListBlock->block) & ((long int)0x7) ) );

  // add these new pairAtoms to the free list
  PairAtom* nextPairAtom = aNewListBlock->block;
  PairAtom* lastPairAtom = nextPairAtom + LIST_BLOCK_SIZE - 1;
  for ( ; nextPairAtom < lastPairAtom ; nextPairAtom++ ) {
//    assert( !( ((long int)nextPairAtom) & ((long int)0x7) ) );
    nextPairAtom->pair.car = NULL;
    nextPairAtom->pair.cdr = nextPairAtom + 1;
  }
  nextPairAtom->pair.cdr = someListMem->freePairs;
  someListMem->freePairs = aNewListBlock->block;
  DEBUG(FALSE, "addListBlock < %p %p %p\n", someListMem,
        aNewListBlock, aNewListBlock->block);
}

void collectGarbage(ListMemory* someListMem) {
  DEBUG(FALSE, "collectGarbage %p\n", someListMem);
  // add a garbage collection mark-sweep here
}

PairAtom* newPairAtom(CoAlgebras* coAlgs) {
  assert(coAlgs);
  assert(coAlgs->pairs);
  ListMemory* someListMem = coAlgs->pairs->listMemory;
  // ensure there are some list blocks
  if ( ! someListMem->freePairs ) collectGarbage(someListMem);
  if ( ! someListMem->freePairs ) addListBlock(someListMem);
  assert(someListMem->freePairs);

  PairAtom* aNewPairAtom = someListMem->freePairs;
  someListMem->freePairs = aNewPairAtom->pair.cdr;

  aNewPairAtom->coAlg    = NULL;
  aNewPairAtom->pair.car = NULL;
  aNewPairAtom->pair.cdr = NULL;

  return aNewPairAtom;
}
\stopCCode


\starttyping
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "CuTest.h"

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/lists.h"
#include "joyLoL/lists_private.h"
#include "joyLoL/printer.h"

// suiteName: - Pairs CoAlgebra tests -

void Test_createPairsCoAlgebra(CuTest* tc) {
  CoAlgebras *coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Pairs* pairs = coAlgs->pairs;
  CuAssertPtrNotNull(tc, pairs);

  CuAssertPtrNotNull(tc, pairs->listMemory);
}

void Test_newListBlock(CuTest* tc) {
  // create the first list block and make sure it is properly integrated
  // into linked list of list blocks

  ListMemory* someListMem = createListMemory();

  CuAssertPtrNull(tc, someListMem->rootListBlock);
  CuAssertPtrNull(tc, someListMem->freePairs);

  addListBlock(someListMem);
  CuAssertPtrNotNull(tc, someListMem->rootListBlock);
  CuAssertPtrNotNull(tc, someListMem->rootListBlock->block);
  CuAssertPtrNull(tc, someListMem->rootListBlock->nextBlock);
  CuAssertPtrNotNull(tc, someListMem->freePairs);

  // check to make sure freePairs list is correctly linked
  PairAtom* nextPairAtom = someListMem->rootListBlock->block;
  PairAtom* lastPairAtom = nextPairAtom + LIST_BLOCK_SIZE - 1;
  for ( ; nextPairAtom < lastPairAtom ; nextPairAtom++ ) {
//    CuAssertTrue(tc, !( ((long int)nextPairAtom) & ((long int)0x7) ));
    CuAssertPtrNull(tc, nextPairAtom->pair.car);
    CuAssertPtrEquals(tc, nextPairAtom->pair.cdr, nextPairAtom + 1);
  }
  CuAssertPtrNull(tc, nextPairAtom->pair.cdr);
  CuAssertPtrEquals(tc, someListMem->freePairs, someListMem->rootListBlock->block);

  // add another list block
  PairAtom* oldFreePairs = someListMem->freePairs;
  addListBlock(someListMem);
  CuAssertPtrNotNull(tc, someListMem->rootListBlock->nextBlock);
  CuAssertPtrNotNull(tc, someListMem->rootListBlock->nextBlock->block);
  CuAssertPtrNull(tc, someListMem->rootListBlock->nextBlock->nextBlock);
  CuAssertPtrNotNull(tc, someListMem->freePairs);

  // check to make sure freePairs list is correctly linked
  nextPairAtom = someListMem->rootListBlock->nextBlock->block;
  lastPairAtom = nextPairAtom + LIST_BLOCK_SIZE - 1;
  for ( ; nextPairAtom < lastPairAtom ; nextPairAtom++ ) {
//    CuAssertTrue(tc, !( ((long int)nextPairAtom) & ((long int)0x7) ));
    CuAssertPtrNull(tc, nextPairAtom->pair.car);
    CuAssertPtrEquals(tc, nextPairAtom->pair.cdr, nextPairAtom + 1);
  }
  CuAssertPtrEquals(tc, nextPairAtom->pair.cdr, oldFreePairs);
  CuAssertPtrEquals(tc, someListMem->freePairs, someListMem->rootListBlock->nextBlock->block);
}

void Test_newPairAtom(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  CuAssertPtrNotNull(tc, coAlgs->pairs);
  ListMemory* someListMem = coAlgs->pairs->listMemory;
  CuAssertPtrNotNull(tc, someListMem);

  CuAssertPtrNotNull(tc, someListMem->freePairs);
  PairAtom* oldFreePairs = someListMem->freePairs;
  PairAtom* newFreePairs = someListMem->freePairs->pair.cdr;

  PairAtom* aNewPair = newPairAtom(coAlgs);
  CuAssertPtrNotNull(tc, aNewPair );
  CuAssertPtrNull(tc, aNewPair->pair.car);
  CuAssertPtrNull(tc, aNewPair->pair.cdr);
  CuAssertPtrEquals(tc, oldFreePairs, aNewPair);
  CuAssertPtrEquals(tc, newFreePairs, someListMem->freePairs);
}

void Test_printPairs(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  CuAssertPtrNotNull(tc, coAlgs->pairs);

  PairAtom* aNewPair = newPair(coAlgs,
                               newPair(coAlgs, NULL, NULL),
                               newPair(coAlgs, NULL, NULL));
  CuAssertPtrNotNull(tc, aNewPair);
  CuAssertIntEquals(tc, printSizeDebug(aNewPair, FALSE), 28);
  CuAssertStrEquals(tc, printLoLDebug(aNewPair, FALSE), "( ( ) ) ( )");
}

void Test_allocateLotsOfPairAtoms(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);

  PairAtom* aNewPair = NULL;
  for ( size_t i = 0; i < 3*LIST_BLOCK_SIZE; i++ ) {
    aNewPair = newPairAtom(coAlgs);
  }
  CuAssertPtrNotNull(tc, aNewPair);
  CuAssertPtrNull(tc, aNewPair->pair.car);
  CuAssertPtrNull(tc, aNewPair->pair.cdr);
}
\stoptyping
