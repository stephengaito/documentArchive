% A ConTeXt document [master document: symbols.tex]

\section[title=Code]
\setCHeaderStream{public}

\dependsOn[jInterps]
%\dependsOn[context]

\startCHeader
typedef struct symbol_object_struct {
  CoAlgObj super;
  Symbol *sym;
} SymbolObj;
\stopCHeader

\setCHeaderStream{private}
\startCHeader
#define asSymbol(aObj) (((SymbolObj*)(aObj))->sym)
\stopCHeader
\setCHeaderStream{public}

\startTestSuite[newString]

\stopTestSuite

\startTestSuite[registerSymbols]

\setCHeaderStream{private}
\startCHeader
extern Boolean registerSymbols(JoyLoLInterp* jInterp);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean registerSymbols(JoyLoLInterp* jInterp) {
  assert(jInterp);
  assert(jInterp->coAlgs);
  
  CoAlgebra* theCoAlg    = (CoAlgebra*) calloc(1, sizeof(CoAlgebra));
  theCoAlg->name         = "Symbols";
  theCoAlg->objectSize   = sizeof(SymbolObj);
  theCoAlg->registerFunc = registerSymbols;
  theCoAlg->equalityFunc = NULL;
  theCoAlg->printFunc    = NULL;
  theCoAlg->coAlgData    = NULL;
  size_t tag = registerCoAlgebra(jInterp, theCoAlg);
  
  // sanity check...
  assert(tag == SymbolsTag);
  assert(jInterp->coAlgs[tag].sClass);

  registerSymbolWords(jInterp);

  return TRUE;
}
\stopCCode

\startTestCase[should register the Symbols coAlg]

\startCTest
  // CTestsSetup has already created a jInterp
  // and run registerSymbols
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs);
  AssertPtrNotNull(jInterp->coAlgs[SymbolsTag].sClass);
  CoAlgebra *coAlg = jInterp->coAlgs[SymbolsTag].sClass;
  AssertIntTrue(registerSymbols(jInterp));
  AssertPtrNotNull(jInterp->coAlgs[SymbolsTag].sClass);
  AssertPtrEquals(jInterp->coAlgs[SymbolsTag].sClass, coAlg);
  AssertIntEquals(
    jInterp->coAlgs[SymbolsTag].sClass->objectSize,
    sizeof(SymbolObj)
  )
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[newSymbol]

\startCHeader
CoAlgObj* newSymbol(JoyLoLInterp* jInterp, const char* aSymbol);
\stopCHeader

\startCCode
CoAlgObj* newSymbol(JoyLoLInterp* jInterp, const char* aSymbol) {
  assert(aSymbol);
  assert(jInterp);
  assert(jInterp->coAlgs);
  
  CoAlgObj* result = newObject(jInterp, SymbolsTag);
  assert(result);
  result->type     = jInterp->coAlgs[SymbolsTag].sClass;
  result->tag      = SymbolsTag;
  result->flags    = 0;
  asSymbol(result) = strdup(aSymbol);
  return result;
}
\stopCCode

\startTestCase[should create some new symbols]

\startCTest
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs);

  const char* testStr = "test string";
  CoAlgObj* aNewSymbol = newSymbol(jInterp, testStr);
  AssertPtrNotNull(aNewSymbol);
  AssertPtrNotNull(aNewSymbol->type);
  AssertIntEquals(aNewSymbol->tag, SymbolsTag);
  AssertPtrNotNull(asSymbol(aNewSymbol));
  AssertPtrNotEquals(asSymbol(aNewSymbol), testStr);
  AssertIntEquals(strcmp(asSymbol(aNewSymbol), testStr), 0);
  AssertIntTrue(isSymbol(aNewSymbol));
  AssertIntTrue(isAtom(aNewSymbol));
  AssertIntFalse(isPair(aNewSymbol));
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[isSymbol and symbolIs]

\startCHeader
extern Boolean isSymbol(CoAlgObj *aLoL);
\stopCHeader

\startCCode
Boolean isSymbol(CoAlgObj *aLoL) {
  if (aLoL &&
      aLoL->type &&
      (aLoL->tag == SymbolsTag)) {
    return TRUE;
  }
  return FALSE;
}
\stopCCode

\startCHeader
extern Boolean symbolIs(CoAlgObj *aLoL, Symbol *aSymbol);
\stopCHeader

\startCCode
Boolean symbolIs(CoAlgObj *aLoL, Symbol *aSymbol) {
  if (isSymbol(aLoL) &&
      (strcmp(asSymbol(aLoL), aSymbol) == 0)) {
    return TRUE;
  }
  return FALSE;
}
\stopCCode

\startTestCase[should return true if a symbol]

\startCTest
  CoAlgObj *aSym = newSymbol(jInterp, "this is a test");
  AssertIntTrue(isSymbol(aSym));
  AssertIntTrue(symbolIs(aSym, "this is a test"));
\stopCTest
\stopTestCase

\startTestCase[should return false if not a symbol]
\startCTest
  AssertIntFalse(isSymbol(NULL));
  AssertIntFalse(symbolIs(NULL, "this is NOT a test"));
  CoAlgObj *aObj = newObject(jInterp, BooleansTag);
  AssertIntFalse(isSymbol(aObj));
  AssertIntFalse(symbolIs(aObj, "this is NOT a test"));
  CoAlgObj *aSym = newSymbol(jInterp, "this is a test");
  AssertIntFalse(symbolIs(aSym, "this is NOT a test"));
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[symbol equality]

\startCHeader
Boolean symbolsEqualDebug(
  CoAlgObj* lolA,
  CoAlgObj* lolB,
  Boolean debugFlag
);

#define symbolsEqual(lolA, lolB) \
  symbolsEqualDebug(lolA, lolB, FALSE)
\stopCHeader

\startCCode
Boolean symbolsEqualDebug(
  CoAlgObj* lolA,
  CoAlgObj* lolB,
  Boolean debugFlag
) {
  DEBUG(debugFlag, "symbolsEqual a:%p b:%p\n", lolA, lolB);
  if (!lolA && !lolB) return TRUE;
  if (!lolA || !lolB) return FALSE;
  if (lolA->type != lolB->type) return FALSE;
  if (lolA->tag != SymbolsTag) return FALSE;
  if (strcmp(asSymbol(lolA), asSymbol(lolB)) != 0) return FALSE;
  return TRUE;
}
\stopCCode

\startTestCase[should return true if symbols are equal]

\startCTest
  AssertIntTrue(symbolsEqual(NULL, NULL));
  CoAlgObj *symA = newSymbol(jInterp, "the same text");
  CoAlgObj *symB = newSymbol(jInterp, "the same text");
  AssertIntTrue(symbolsEqual(symA, symB));
\stopCTest
\stopTestCase

\startTestCase[should return false if symbols are not equal]

\startCTest
  CoAlgObj *symA = newSymbol(jInterp, "text A");
  CoAlgObj *symB = newSymbol(jInterp, "text B");
  AssertIntFalse(symbolsEqual(NULL, symB));
  AssertIntFalse(symbolsEqual(symA, NULL));
  AssertIntFalse(symbolsEqual(symA, symB));
\stopCTest
\stopTestCase
\stopTestSuite

\starttyping
// strings.c
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/lists.h"
#include "joyLoL/printer.h"
#include "joyLoL/dictionary.h"

static size_t printSizeSymbolCoAlg(CoAlgObj* aLoL, size_t debugFlag) {
  DEBUG(debugFlag, "symbolCoAlg-printSize: %p\n", aLoL);
  assert(aLoL);
  assert(aLoL->coAlg);
  assert(aLoL->coAlg->isA == SYMBOL_COALG);
  DEBUG(debugFlag, "symbolCoAlg-printSize: [%s] %p\n", aLoL->symbol, aLoL);
  return strlen(aLoL->symbol) + 1;
}

static size_t printStrSymbolCoAlg(CoAlgObj* aLoL,
                                  char* buffer, size_t bufferSize) {
  assert(aLoL);
  assert(aLoL->coAlg);
  assert(aLoL->coAlg->isA == SYMBOL_COALG);

  strcat(buffer, aLoL->symbol);
  strcat(buffer, " ");
  return TRUE;
}
\stoptyping

\starttyping
// specs
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "CuTest.h"

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/lists.h"
#include "joyLoL/dictionary.h"
#include "joyLoL/printer.h"

// suiteName: - Symbols CoAlgebra tests -


void Test_printSymbols(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  CuAssertPtrNotNull(tc, coAlgs->symbols);

  const char* testStr = "test string";
  CoAlgObj* aNewSymbol = newSymbol(coAlgs, testStr);
  CuAssertPtrNotNull(tc, aNewSymbol);
  CuAssertIntEquals(tc, printSizeDebug(aNewSymbol, FALSE), strlen(testStr)+1);
  CuAssertStrEquals(tc, printLoLDebug(aNewSymbol, FALSE), testStr);
}

void Test_checkSymbolsSymbols(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);

  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* mainDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, mainDic);

  AVLNode* aNode = findSymbol(mainDic, "isSymbol");
  CuAssertPtrNotNull(tc, aNode);
  CuAssertStrEquals(tc, aNode->symbol, "isSymbol");
  CuAssertPtrNotNull(tc, aNode->value);
  CuAssertTrue(tc, isFunction(aNode->value));
}
\stoptyping