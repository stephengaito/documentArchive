% A ConTeXt document [master document: loaders.tex]

\section[title=Loader functions]

\startCHeader
typedef struct loader_object_struct {
  CoAlgObj  super;
  CoAlgObj *paths;
  CoAlgObj *extensions;
} LoaderObj;
\stopCHeader

\startCHeader
typedef LoaderObj *(NewLoader)(
  JoyLoLInterp *jInterp
);

#define newLoader(jInterp)          \
  (                                 \
    assert(getLoadersClass(jInterp) \
      ->newLoaderFunc),             \
    (getLoadersClass(jInterp)       \
      ->newLoaderFunc(jInterp))     \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern LoaderObj *newLoaderImpl(
  JoyLoLInterp *jInterp
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
LoaderObj *newLoaderImpl(
  JoyLoLInterp *jInterp
) {
  assert(jInterp);
  LoaderObj *loader = 
    (LoaderObj*)newObject(jInterp, LoadersTag);
  assert(loader);
  
  loader->paths      = NULL;
  loader->extensions = NULL;
  
  // init standard load paths
  // allow absolute paths as a last resort
  pushLoadPath(jInterp, ""); 
  pushLoadPath(jInterp, JOYLOL_SYSTEM_COALG_PATH);
  pushLoadPath(jInterp, JOYLOL_SYSTEM_CONFIG_PATH);
  pushLoadPath(jInterp, JOYLOL_USER_COALG_PATH);
  pushLoadPath(jInterp, ".");

  // init standard load extensions
  // allow absolute extensions as a last resort
  pushLoadExtension(jInterp, "");
  pushLoadExtension(jInterp, ".so");
  pushLoadExtension(jInterp, ".lua");
  pushLoadExtension(jInterp, ".joy");
  
  return loader;
}
\stopCCode

\startCHeader
typedef void (PushLoadSymbol)(
  JoyLoLInterp *jInterp,
  Symbol       *aLoadSym
);

#define pushLoadPath(jInterp, aLoadPath)      \
  (                                           \
    assert(getLoadersClass(jInterp)           \
      ->pushLoadPathFunc),                    \
    (getLoadersClass(jInterp)                 \
      ->pushLoadPathFunc(jInterp, aLoadPath)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushLoadPathImpl(
  JoyLoLInterp *jInterp,
  Symbol       *aLoadPath
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushLoadPathImpl(
  JoyLoLInterp *jInterp,
  Symbol       *aLoadPath
) {
  assert(aLoadPath);
  assert(jInterp);
  LoaderObj* loader = jInterp->loader;
  assert(loader);
  loader->paths =
    newPair(jInterp, newSymbol(jInterp, aLoadPath), loader->paths);
}
\stopCCode

\starttyping
\startCHeader
extern void pushLoadFile(JoyLoLInterp* jInterp, const char* aLoadFile);
\stopCHeader

\startCCode
void pushLoadFile(JoyLoLInterp* jInterp, const char* aLoadFile) {
  assert(aLoadFile);
  assert(jInterp);
  assert(jInterp->contexts);
  Loader* loader = jInterp->contexts->loader;
  assert(loader);
  loader->loadFiles =
    newPair(jInterp, newSymbol(jInterp, aLoadFile), loader->loadFiles);
}
\stopCCode
\stoptyping

\startCHeader
#define pushLoadExtension(jInterp, aLoadExt)      \
  (                                               \
    assert(getLoadersClass(jInterp)               \
      ->pushLoadExtensionFunc),                   \
    (getLoadersClass(jInterp)                     \
      ->pushLoadExtensionFunc(jInterp, aLoadExt)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushLoadExtensionImpl(
  JoyLoLInterp *jInterp,
  Symbol       *aLoadExtension
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushLoadExtensionImpl(
  JoyLoLInterp *jInterp,
  Symbol       *aLoadExtension
) {
  assert(aLoadExtension);
  assert(jInterp);
  LoaderObj* loader = jInterp->loader;
  assert(loader);
  loader->extensions =
    newPair(
      jInterp, 
      newSymbol(jInterp, aLoadExtension),
      loader->extensions
    );
}
\stopCCode

\setCHeaderStream{private}
\startCHeader
extern Boolean loadAJoyLoLFile(
  ContextObj *aCtx,
  Symbol     *filePath
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean loadAJoyLoLFile(
  ContextObj *aCtx,
  Symbol     *filePath
) {
  assert(aCtx);
  assert(aCtx->jInterp);
  DEBUG(FALSE, "loadATextFile [%s]\n", filePath);
  FILE* inputFile = fopen(filePath, "r");
  if (inputFile) {
    if(aCtx->verbose) printf("(%s)\n", filePath);
    TextObj* aText =
      createTextFromInputFile(aCtx->jInterp, inputFile);
    evalTextInContext(aCtx, aText);
    freeText(aText);
    fclose(inputFile);
    if (reportException(aCtx)) {
      DEBUG(FALSE, "loadATextFile [%s] RAISED EXCEPTION\n", filePath);
      return FALSE;
    }
    DEBUG(FALSE, "loadATextFile [%s] OK\n", filePath);
    return TRUE; // we have loaded this file so return TRUE;
  }
  DEBUG(FALSE, "loadATextFile [%s] FAILED\n", filePath);
  return FALSE;
}
\stopCCode

\startCHeader
typedef Boolean (LoadAFile)(
  ContextObj *aCtx,
  Symbol     *aFileToLoad
);

#define loadAFile(jInterp, aFileToLoad)       \
  (                                           \
    assert(getLoadersClass(jInterp)           \
      ->loadAFileFunc),                       \
    (getLoadersClass(jInterp)                 \
      ->loadAFileFunc(jInterp, aFileToLoad))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern Boolean loadAFileImpl(
  ContextObj *aCtx,
  Symbol     *aFileToLoad
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean loadAFileImpl(
  ContextObj *aCtx,
  Symbol     *aFileToLoad
) {
  assert(aCtx);
  assert(aCtx->jInterp);
  LoaderObj* loader = aCtx->jInterp->loader;
  assert(loader);
  if (!aFileToLoad) return FALSE;
  if (!*aFileToLoad) return FALSE;

  if (aCtx->verbose) printf("\t%s ", aFileToLoad);

  CoAlgObj* aLoadPathList = loader->paths;
  while(aLoadPathList) {
    assert(isPair(aLoadPathList));
    CoAlgObj* aLoadPath = asCar(aLoadPathList);
    if (!isSymbol(aLoadPath)) continue;

    CoAlgObj* aLoadExtensionList = loader->extensions;
    while(aLoadExtensionList) {
      assert(isPair(aLoadExtensionList));
      CoAlgObj* aLoadExtension = asCar(aLoadExtensionList);
      if (!isSymbol(aLoadExtension)) continue;

      char buffer[8000];
      buffer[0] = 0;
      assert(isSymbol(aLoadPath));
      strcat(buffer, asSymbol(aLoadPath));
      strcat(buffer, "/");
      strcat(buffer, aFileToLoad);
      assert(isSymbol(aLoadExtension));
      strcat(buffer, asSymbol(aLoadExtension));
      DEBUG(FALSE, "trying to load: [%s]\n", buffer);

      if (!access(buffer, R_OK)) {
        if (strcmp(asSymbol(aLoadExtension), ".joy") == 0) {
          if (loadAJoyLoLFile(aCtx, aFileToLoad)) {
            DEBUG(FALSE, "loaded: [%s]\n", buffer);
            return TRUE;
          }
        } else {
          assert(aCtx);
          lua_State *lstate = aCtx->jInterp->lstate;
          requireLuaModuleInto(lstate, aFileToLoad, loadedOk);
          if (loadedOk) {
            DEBUG(FALSE, "loaded: [%s]\n", buffer);
            return TRUE;
          }
        }
        // keep trying other paths/extensions ...
      }
      // try the next ext
      aLoadExtensionList = asCdr(aLoadExtensionList);
    }
    // try the next load path
    aLoadPathList = asCdr(aLoadPathList);
  }
  if(aCtx->verbose) printf("FAILED\n");
  DEBUG(FALSE, "loadAFile: FAILED%s\n", "");
  return FALSE; // we could not find this file in any of the load paths
}
\stopCCode

\starttyping
Boolean loadFiles(
  ContextObj *aCtx,
  CoAlgObj   *filesToLoad
) {
  assert(aCtx);
  assert(aCtx->coAlgebras);
  assert(aCtx->coAlgebras->contexts);
  Loader* loader = aCtx->coAlgebras->contexts->loader;
  assert(loader);
  if (!filesToLoad) return TRUE; // nothing to do...

  DEBUG(FALSE, "loadFiles > %s:%p\n", filesToLoad->coAlg->name, filesToLoad);

  if (isSymbol(filesToLoad)) { // try to load this file
    return loadAFile(aCtx, filesToLoad->symbol);
  }

  // this is a Pair in the list of load files...
  // ... walk down the list
  if (loadFiles(aCtx, filesToLoad->pair.cdr)) {
    // if all previous files have been loaded... load this one as well
    return loadFiles(aCtx, filesToLoad->pair.car);
  }
  DEBUG(FALSE, "loadFiles < %p FAILED\n", filesToLoad);
  return FALSE; // some previous file has failed to load...
}
\stoptyping

\startTestSuite[regiserLoaders]

\startCHeader
typedef struct loaders_class_struct {
  CoAlgClass      super;
  NewLoader      *newLoaderFunc;
  PushLoadSymbol *pushLoadPathFunc;
  PushLoadSymbol *pushLoadExtensionFunc;
  LoadAFile      *loadAFileFunc;
} LoadersClass;
\stopCHeader

\setCHeaderStream{private}
\startCHeader
Boolean registerLoaders(
  JoyLoLInterp *jInterp
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean registerLoaders(
  JoyLoLInterp *jInterp
) {
  assert(jInterp);
  
  LoadersClass* theCoAlg =
    joyLoLCalloc(1, LoadersClass);
  assert(theCoAlg);
  
  theCoAlg->super.name            = LoadersName;
  theCoAlg->super.objectSize      = sizeof(LoaderObj);
  theCoAlg->super.registerFunc    = registerLoaders;
  theCoAlg->super.equalityFunc    = NULL;
  theCoAlg->super.printFunc       = NULL;
  theCoAlg->newLoaderFunc         = newLoaderImpl;
  theCoAlg->pushLoadPathFunc      = pushLoadPathImpl;
  theCoAlg->pushLoadExtensionFunc = pushLoadExtensionImpl;
  theCoAlg->loadAFileFunc         = loadAFileImpl;

  size_t tag =
    registerCoAlgClass(jInterp, (CoAlgClass*)theCoAlg);
  
  // do a sanity check...
  assert(tag == LoadersTag);
  assert(tag < jInterp->numCoAlgs);
  assert(getLoadersClass(jInterp));
    
  // need to register JoyLoL words
  
  return TRUE;
}
\stopCCode

\startTestCase[should register the Loaders coAlg]

\startCTest
  // CTestsSetup has already created a jInterp 
  // and run registerJInterps
  //
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs);
  AssertIntTrue(LoadersTag < jInterp->numCoAlgs);
  AssertPtrNotNull(getLoadersClass(jInterp));
  
  LoadersClass *loadersClass = getLoadersClass(jInterp);
  size_t result = registerLoaders(jInterp);
  AssertIntTrue(result);
  AssertPtrNotNull(getLoadersClass(jInterp));
  AssertPtrEquals(getLoadersClass(jInterp), loadersClass);
  AssertIntEquals(
    getLoadersClass(jInterp)->super.objectSize,
    sizeof(LoaderObj)
  )
\stopCTest
\stopTestCase
\stopTestSuite
