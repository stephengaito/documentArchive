% A ConTeXt document [master document: dictNodes.tex]

\section[title=Find]

\startTestSuite[findSymbolRecurse]

\setCHeaderStream{public}
\startCHeader
typedef DictNodeObj *(FindSymbolRecurse)(
  JoyLoLInterp *jInterp,
  DictNodeObj  *anAVLNode,
  Symbol       *aSymbol
);

#define findSymbolRecurse(jInterp, anAVLNode, aSymbol)      \
  (                                                         \
    assert(getDictNodesClass(jInterp)                       \
      ->findSymbolRecurseFunc),                             \
    (getDictNodesClass(jInterp)                             \
      ->findSymbolRecurseFunc(jInterp, anAVLNode, aSymbol)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern DictNodeObj* findSymbolRecurseImpl(
  JoyLoLInterp *jInterp,
  DictNodeObj  *anAVLNode,
  Symbol       *aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
DictNodeObj* findSymbolRecurseImpl(
  JoyLoLInterp *jInterp,
  DictNodeObj  *anAVLNode,
  Symbol       *aSymbol
) {
  if (!anAVLNode) return NULL;
  int aStrCmp = strcmp(aSymbol, anAVLNode->symbol);
  if (aStrCmp < 0) {
    // aSymbol < anAVLNode->symbol // search the LEFT subtree
    return findSymbolRecurse(jInterp, anAVLNode->left, aSymbol);
  } else if (0 < aStrCmp) {
    // aSymbol > anAVLNode->symbol // search the RIGHT subtree
    return findSymbolRecurse(jInterp, anAVLNode->right, aSymbol);
  } else {
    // aSymbol == anAVLNode->symbol // return this association pair
    return anAVLNode;
  }
  return NULL;
}
\stopCCode

\startTestCase[should find Symbol In Empty Dictionary]
\startCTest
  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;
  
  AssertPtrNull(findSymbolRecurse(jInterp, NULL, "aSymbol"));
\stopCTest
\stopTestCase

\startTestCase[should find Symbol In Non Empty Dictionary]
\startCTest
  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  DictNodeObj* aNode = newDictNode(jInterp, "aNodeSymbol");
  AssertPtrNotNull(aNode);
  DictNodeObj* foundAPair = findSymbolRecurse(jInterp, aNode, "aNodeSymbol");
  AssertPtrNotNull(foundAPair);
  AssertStrEquals(foundAPair->symbol, "aNodeSymbol");
\stopCTest
\stopTestCase

\startTestCase[should find Symbol Not In Dictionary]
\startCTest
  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  DictNodeObj* aSimpleDic = newDictNode(jInterp, "aNodeSymbol");
  AssertPtrNotNull(aSimpleDic);
  AssertPtrNull(findSymbolRecurse(jInterp, aSimpleDic, "aSymbol"));
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[findLUBSymbolRecurse]

\startCHeader
typedef DictNodeObj *(FindLUBSymbolRecurse)(
  JoyLoLInterp *jInterp,
  DictNodeObj  *anAVLNode,
  Symbol       *aSymbol
);

#define findLUBSymbolRecurse(jInterp, anAVLNode, aSymbol)       \
  (                                                             \
    assert(getDictNodesClass(jInterp)                           \
      ->findLUBSymbolRecurseFunc),                              \
    (getDictNodesClass(jInterp)                                 \
      ->findLUBSymbolRecurseFunc(jInterp, anAVLNode, aSymbol))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
DictNodeObj* findLUBSymbolRecurseImpl(
  JoyLoLInterp *jInterp,
  DictNodeObj  *anAVLNode,
  Symbol       *aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
DictNodeObj* findLUBSymbolRecurseImpl(
  JoyLoLInterp *jInterp,
  DictNodeObj  *anAVLNode,
  Symbol       *aSymbol
) {
  assert(jInterp);
  if (!anAVLNode) return jInterp->dict.firstSymbol;

  DEBUG(jInterp, "findLUBSymbol %p {%s}[%s] %p %p\n",
        anAVLNode, anAVLNode->symbol, aSymbol,
        anAVLNode->left, anAVLNode->right);

  int aStrCmp = strcmp(aSymbol, anAVLNode->symbol);
  DEBUG(jInterp, "findLUBSymbol cmp: %d\n", aStrCmp);
  if (aStrCmp < 0) {
    // aSymbol < anAVLNode->symbol
    // the current anAVLNode->symbol is an upper bound
    // search the LEFT subtree for a smaller upper bound
    if (anAVLNode->left) {
      DictNodeObj* aNode = findLUBSymbolRecurse(jInterp, anAVLNode->left, aSymbol);
      if (!aNode) {
        // there is nothing in the LEFT subtree which is an upper bound
        // so return this node.
        return anAVLNode;
      }
      // we have found a smaller upper bound... so return it
      return aNode;
    }
    // there is nothing less than this node so return this node
    return anAVLNode;
    //
  } else if (0 < aStrCmp) {
    // anAVLNode->symbol < symbol
    // the current anAVLNode->symbol is a lower bound
    // search the RIGHT subtree for any upper bounds
    if (anAVLNode->right) {
      return findLUBSymbolRecurse(jInterp, anAVLNode->right, aSymbol);
    }
    // there is nothing greater than this node so return NULL to signal failure
    return NULL;
    //
  } else {
    // aSymbol == anAVLNode->symbol
    // the current anAVLNode->symbol is the lowest possible upper bound
    // return it
    return anAVLNode;
    //
  }
  return jInterp->dict.firstSymbol;
}
\stopCCode
\stopTestSuite
