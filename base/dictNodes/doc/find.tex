% A ConTeXt document [master document: dictNodes.tex]

\section[title=Find]

\startTestSuite[findSymbol]

\setCHeaderStream{private}
\startCHeader
extern DictNodeObj* findSymbolRecurse(
  JoyLoLInterp* jInterp,
  DictNodeObj* anAVLNode,
  Symbol* aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
DictNodeObj* findSymbolRecurse(
  JoyLoLInterp* jInterp,
  DictNodeObj* anAVLNode,
  Symbol* aSymbol
) {
  if (!anAVLNode) return NULL;
  int aStrCmp = strcmp(aSymbol, anAVLNode->symbol);
  if (aStrCmp < 0) {
    // aSymbol < anAVLNode->symbol // search the LEFT subtree
    return findSymbolRecurse(jInterp, anAVLNode->left, aSymbol);
  } else if (0 < aStrCmp) {
    // aSymbol > anAVLNode->symbol // search the RIGHT subtree
    return findSymbolRecurse(jInterp, anAVLNode->right, aSymbol);
  } else {
    // aSymbol == anAVLNode->symbol // return this association pair
    return anAVLNode;
  }
  return NULL;
}
\stopCCode

\startCHeader
typedef DictNodeObj *(FindSymbol)(
  JoyLoLInterp *jInterp,
  Symbol       *aSymbol
);

#define findSymbol(jInterp, aSymbol)      \
  (                                       \
    assert(getDictNodesClass(jInterp)  \
      ->findSymbolFunc),                  \
    (getDictNodesClass(jInterp)        \
      ->findSymbolFunc(jInterp, aSymbol)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern DictNodeObj* findSymbolImpl(
  JoyLoLInterp* jInterp,
  Symbol* aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
DictNodeObj* findSymbolImpl(
  JoyLoLInterp* jInterp,
  Symbol* aSymbol
) {
  if (!aSymbol) return NULL;
  assert(jInterp);
  return findSymbolRecurse(jInterp, jInterp->dict.root, aSymbol);
}
\stopCCode

\startTestCase[should find Symbol In Empty Dictionary]
\startCTest
  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;
  
  AssertPtrNull(findSymbolRecurse(jInterp, NULL, "aSymbol"));
\stopCTest
\stopTestCase

\startTestCase[should find Symbol In Non Empty Dictionary]
\startCTest
  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  DictNodeObj* aNode = newDict(jInterp, "aNodeSymbol");
  AssertPtrNotNull(aNode);
  DictNodeObj* foundAPair = findSymbolRecurse(jInterp, aNode, "aNodeSymbol");
  AssertPtrNotNull(foundAPair);
  AssertStrEquals(foundAPair->symbol, "aNodeSymbol");
\stopCTest
\stopTestCase

\startTestCase[should find Symbol Not In Dictionary]
\startCTest
  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  DictNodeObj* aSimpleDic = newDict(jInterp, "aNodeSymbol");
  AssertPtrNotNull(aSimpleDic);
  AssertPtrNull(findSymbolRecurse(jInterp, aSimpleDic, "aSymbol"));
\stopCTest
\stopTestCase
\stopTestSuite

\setCHeaderStream{private}
\startCHeader
DictNodeObj* findLUBSymbolRecurse(
  JoyLoLInterp *jInterp,
  DictNodeObj      *anAVLNode,
  Symbol       *aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
DictNodeObj* findLUBSymbolRecurse(
  JoyLoLInterp *jInterp,
  DictNodeObj      *anAVLNode,
  Symbol       *aSymbol
) {
  assert(jInterp);
  if (!anAVLNode) return jInterp->dict.firstSymbol;

  DEBUG(jInterp, "findLUBSymbol %p {%s}[%s] %p %p\n",
        anAVLNode, anAVLNode->symbol, aSymbol,
        anAVLNode->left, anAVLNode->right);

  int aStrCmp = strcmp(aSymbol, anAVLNode->symbol);
  DEBUG(jInterp, "findLUBSymbol cmp: %d\n", aStrCmp);
  if (aStrCmp < 0) {
    // aSymbol < anAVLNode->symbol
    // the current anAVLNode->symbol is an upper bound
    // search the LEFT subtree for a smaller upper bound
    if (anAVLNode->left) {
      DictNodeObj* aNode = findLUBSymbolRecurse(jInterp, anAVLNode->left, aSymbol);
      if (!aNode) {
        // there is nothing in the LEFT subtree which is an upper bound
        // so return this node.
        return anAVLNode;
      }
      // we have found a smaller upper bound... so return it
      return aNode;
    }
    // there is nothing less than this node so return this node
    return anAVLNode;
    //
  } else if (0 < aStrCmp) {
    // anAVLNode->symbol < symbol
    // the current anAVLNode->symbol is a lower bound
    // search the RIGHT subtree for any upper bounds
    if (anAVLNode->right) {
      return findLUBSymbolRecurse(jInterp, anAVLNode->right, aSymbol);
    }
    // there is nothing greater than this node so return NULL to signal failure
    return NULL;
    //
  } else {
    // aSymbol == anAVLNode->symbol
    // the current anAVLNode->symbol is the lowest possible upper bound
    // return it
    return anAVLNode;
    //
  }
  return jInterp->dict.firstSymbol;
}
\stopCCode

\startCHeader
typedef DictNodeObj *(FindLUBSymbol)(
  JoyLoLInterp *jInterp,
  Symbol       *aSymbol
);

#define findLUBSymbol(jInterp, aSymbol)       \
  (                                           \
    assert(getDictNodesClass(jInterp)      \
      ->findLUBSymbolFunc),                   \
    (getDictNodesClass(jInterp)            \
      ->findLUBSymbolFunc(jInterp, aSymbol))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern DictNodeObj* findLUBSymbolImpl(
  JoyLoLInterp *jInterp,
  Symbol       *aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
DictNodeObj* findLUBSymbolImpl(
  JoyLoLInterp *jInterp,
  Symbol       *aSymbol
) {
  assert(jInterp);
  if (!aSymbol) return jInterp->dict.firstSymbol;
  return findLUBSymbolRecurse(jInterp, jInterp->dict.root, aSymbol);
}
\stopCCode
