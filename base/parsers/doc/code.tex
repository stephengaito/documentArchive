% A ConTeXt document [master document: parsers.tex]

\dependsOn[jInterps]
\dependsOn[texts]
\dependsOn[dictionaries]
\dependsOn[symbols]
\dependsOn[naturals]
\dependsOn[pairs]

\setCHeaderStream{public}

\startCCode
// The Parser parses a stream of characters obtained from a specific
// text. Since one of the texts is backed by readline interaction with
// a user, it is **critical** that nextSymbol ONLY get called when
// the parser actually needs a nextSymbol (and NOT before).
\stopCCode

\startTestSuite[match list symbols]

\setCHeaderStream{private}
\startCHeader
extern char matchingListSymbol(Symbol* curSymbol);
\stopCHeader

\startCCode
char matchingListSymbol(Symbol* curSymbol) {
  if (1 < strlen(curSymbol)) return 0;

  if (curSymbol[0] == '(') return ')';
  if (curSymbol[0] == '[') return ']';
  if (curSymbol[0] == '<') return '>';
  if (curSymbol[0] == '{') return '}';

  return 0;
}
\stopCCode

\startCHeader
extern size_t isClosingSymbol(Symbol* curSymbol);
\stopCHeader

\startCCode
size_t isClosingSymbol(Symbol* curSymbol) {
  if (1 < strlen(curSymbol)) return 0;

  if (curSymbol[0] == ')') return 1;
  if (curSymbol[0] == ']') return 1;
  if (curSymbol[0] == '>') return 1;
  if (curSymbol[0] == '}') return 1;

  return 0;
}
\stopCCode

\startCHeader
void reportMismatchedClosingSymbol(
  TextObj* aText, 
  char expected,
  char found
);
\stopCHeader

\startCCode
void reportMismatchedClosingSymbol(
  TextObj* aText,
  char expected,
  char found
) {
  if (expected == 0) return;

  char message[100];
  memset(message, 0, 100);
  strcat(message, "closing list expected [");
  message[strlen(message)] = expected;
  strcat(message, "] but found [");
  message[strlen(message)] = found;
  strcat(message, "]");
  reportError(aText, message);
}
\stopCCode

\startCHeader
void reportUnmatchedClosingSymbol(
  TextObj* aText,
  char expected
);
\stopCHeader

\startCCode
void reportUnmatchedClosingSymbol(
  TextObj* aText,
  char expected
) {
  if (expected == 0) return;

  char message[100];
  memset(message, 0, 100);
  strcat(message, "adding unmatched list closing [");
  message[strlen(message)] = expected;
  strcat(message, "]");
  reportError(aText, message);
}
\stopCCode

\startTestCase[should match List Symbols]
\startCTest
  AssertIntEquals(matchingListSymbol("("), ')');
  AssertIntEquals(matchingListSymbol("["), ']');
  AssertIntEquals(matchingListSymbol("{"), '}');
  AssertIntEquals(matchingListSymbol("<"), '>');
  AssertIntEquals(matchingListSymbol("#"), 0);
  AssertIntEquals(matchingListSymbol("silly"), 0);
\stopCTest
\stopTestCase
\stopTestSuite

\startCHeader
extern CoAlgObj* parseList(
  TextObj* aText,
  char closingChar
);
\stopCHeader

\startCCode
CoAlgObj* parseList(
  TextObj* aText,
  char closingChar
) {
  assert(aText);
  DEBUG(aText->debugFlag,
    "parseList %p '%c'\n", aText, closingChar);

  CoAlgObj* firstPair = NULL;
  CoAlgObj* lastPair  = NULL;

  while (!aText->completed) {

    nextSymbol(aText);
    DEBUG(aText->debugFlag,
      "parseList ns: %p\n", aText->sym);
    if (!aText->sym) {
      reportUnmatchedClosingSymbol(aText, closingChar);
      return firstPair;
    }

    // check to see if this is a closing list symbol
    if (isSymbol(aText->sym) &&
        isClosingSymbol(asSymbol(aText->sym))) {
      if (asSymbol(aText->sym)[0] != closingChar) {
        reportMismatchedClosingSymbol(aText, closingChar,
                                      asSymbol(aText->sym)[0]);
      }
      return firstPair;
    }
    assert(aText->jInterp);
    CoAlgObj* aNewPair = newPair(aText->jInterp, NULL, NULL);

    // check to see if this is an opening list symbol
    if (isSymbol(aText->sym)) {
      char matchingSymbol = matchingListSymbol(asSymbol(aText->sym));
      if (0 < matchingSymbol) {
        asCar(aNewPair) = parseList(aText, matchingSymbol);
      } else asCar(aNewPair) = aText->sym;
    } else asCar(aNewPair) = aText->sym;

    if (!firstPair) firstPair       = aNewPair;
    if (lastPair)   asCdr(lastPair) = aNewPair;

    lastPair = aNewPair;
  }

  if (0 < closingChar) reportUnmatchedClosingSymbol(aText, closingChar);
  return firstPair;
}
\stopCCode

\startTestSuite[parse one symbol]

\startCHeader
extern CoAlgObj* parseOneSymbol(TextObj* aText);
\stopCHeader

\startCCode
CoAlgObj* parseOneSymbol(TextObj* aText) {
  assert(aText);
  DEBUG(aText->debugFlag, "parseOneSymbol %p\n", aText);
  nextSymbol(aText);
  if (!aText->sym) return NULL;

  if (aText->sym->type &&
     (aText->sym->tag != SymbolsTag)) return aText->sym;

  // check to see if this is an opening list symbol
  char matchingSymbol = matchingListSymbol(asSymbol(aText->sym));
  if (0 < matchingSymbol) {
    return parseList(aText, matchingSymbol);
  }
  return aText->sym;
}
\stopCCode

\CTestsSetup\
\startCTest
static Symbol* simpleList[] = {
  "this is a simple list ;; this is a comment ",
  NULL
};
\stopCTest

\startTestCase[parse Simple List One Symbol At A Time]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText =
    createTextFromArrayOfStrings(jInterp, simpleList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "this");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "is");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "a");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "simple");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "list");

  aLoL = parseOneSymbol(aText);
  AssertPtrNull(aLoL);
  AssertIntTrue(aText->completed);
\stopCTest
\stopTestCase

\CTestsSetup\
\startCTest
static Symbol* simpleListWithSemiColons[] = {
  " this ; is;a ;; this is a comment ",
  " and;again ;; this is a second comment ",
  NULL
};
\stopCTest

\startTestCase[parse SemiColons One Symbol At A Time]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText =
    createTextFromArrayOfStrings(jInterp, simpleListWithSemiColons);

  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "this");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), ";");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "is");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), ";");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "a");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "and");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), ";");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "again");

  aLoL = parseOneSymbol(aText);
  AssertPtrNull(aLoL);
  AssertIntTrue(aText->completed);
\stopCTest
\stopTestCase
\stopTestSuite

\setCHeaderStream{public}
\startCHeader
extern CoAlgObj* parseAllSymbols(TextObj* aText);
\stopCHeader

\startCCode
CoAlgObj* parseAllSymbols(TextObj* aText) {
  DEBUG(FALSE, "parseAllSymbols %p]\n", aText);
  return parseList(aText, 0);
}
\stopCCode


\starttyping

// suiteName: - Parser/Printer tests -



// Parse and print a number of different "happy path" lists

static Symbol* complexListWithSemiColons[] = {
  " this ; is;a test with some semi-colons ;; this is a comment ",
  " and;again;123;456;789 12;34 ;; this is a second comment ",
  " and;one;more;time ;; this is a third comment ",
  NULL
};

void Test_parseSemiColonsAllAtOnce(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText =
    createTextFromArrayOfStrings(coAlgs, complexListWithSemiColons);

  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);

  AssertPtrNotNull(aLoL);
  AssertStrEquals(printLoLDebug(aLoL, FALSE),
    "this ; is ; a test with some semi-colons and ; again ; 123 ; 456 ; 789 12 ; 34 and ; one ; more ; time");
}

void Test_parsePrintSimpleList(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText = createTextFromArrayOfStrings(coAlgs, simpleList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);
  AssertPtrNotNull(aLoL);
  AssertIntEquals(printSize(aLoL), 46);
  clearPrintSizeMarksDebug(aLoL, FALSE);
  AssertStrEquals(printLoL(aLoL), "this is a simple list");

  CoAlgObj* lolCopy = copyLoL(coAlgs, aLoL);
  AssertPtrNotEquals(aLoL, lolCopy);
  AssertTrue(equalLoLDebug(aLoL, lolCopy, FALSE));
}

static Symbol* moreComplexList[] = {
 " this ( is ( a ( more ( complex ( list () ) ) ) ) ) ;; this is a comment ",
 NULL
};

void Test_parseComplextListOneSymbolAtATime(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText = createTextFromArrayOfStrings(coAlgs, moreComplexList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "this");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(aLoL->type);
  AssertIntEquals(aLoL->tag, PairsTag);
  AssertStrEquals(printLoL(aLoL),
                    "is ( a ( more ( complex ( list ( ) ) ) ) )");

  aLoL = parseOneSymbol(aText);
  AssertPtrNull(aLoL);
  AssertTrue(aText->completed);
}

void Test_parseComplexListFromSingleString(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText = createTextFromString(coAlgs, moreComplexList[0]);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);

  AssertPtrNotNull(aLoL);
  AssertStrEquals(printLoLDebug(aLoL, FALSE),
    "this ( is ( a ( more ( complex ( list ( ) ) ) ) ) )");
}

void Test_parsePrintComplexList(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText = createTextFromArrayOfStrings(coAlgs, moreComplexList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);
  AssertPtrNotNull(aLoL);
  AssertIntEquals(printSizeDebug(aLoL, FALSE), 104);
  clearPrintSizeMarksDebug(aLoL, FALSE);
  AssertStrEquals(printLoLDebug(aLoL, FALSE),
    "this ( is ( a ( more ( complex ( list ( ) ) ) ) ) )");

  CoAlgObj* lolCopy = copyLoL(coAlgs, aLoL);
  AssertPtrNotEquals(aLoL, lolCopy);
  AssertTrue(equalLoLDebug(aLoL, lolCopy, FALSE));
}

static Symbol* differentList[] = {
 " this is  a different ( ( () () () ) ( ( ( ) ) ) ) list ;; with a comment  ",
 NULL
};

void Test_parsePrintDifferentList(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText = createTextFromArrayOfStrings(coAlgs, differentList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);
  AssertPtrNotNull(aLoL);
  AssertIntEquals(printSizeDebug(aLoL, FALSE), 113);
  clearPrintSizeMarksDebug(aLoL, FALSE);
  AssertStrEquals(printLoLDebug(aLoL, FALSE),
    "this is a different ( ( ( ) ( ) ( ) ) ( ( ( ) ) ) ) list");
}

void Test_parsePrintNaturals(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText = createTextFromString(coAlgs, " 1234567890 not1234567890 ");
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertTrue(isAtom(aLoL));
  AssertTrue(isNatural(aLoL));
  AssertIntEquals( mpz_cmp_si(aLoL->natural, 1234567890), 0);
  AssertStrEquals(printLoLDebug(aLoL, FALSE), "1234567890");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertTrue(isAtom(aLoL));
  AssertTrue(isSymbol(aLoL));
  AssertStrEquals(asSymbol(aLoL), "not1234567890");
}

void Test_parseBoolean(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);
  Symbols* symbols = coAlgs->symbols;
  AssertPtrNotNull(symbols);
  Dictionary* mainDic = symbols->dictionary;
  AssertPtrNotNull(mainDic);

  Text* aText = createTextFromString(coAlgs, " true false ");
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertTrue(isAtom(aLoL));
  AssertTrue(isSymbol(aLoL));
  AssertStrEquals(asSymbol(aLoL), "true");
  AVLNode* aNode = findSymbol(mainDic, asSymbol(aLoL));
  AssertPtrNotNull(aNode);
  AssertPtrNotNull(aNode->value);
  AssertTrue(isBoolean(aNode->value));
  AssertTrue(aNode->value->boolean);

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertTrue(isAtom(aLoL));
  AssertTrue(isSymbol(aLoL));
  AssertStrEquals(asSymbol(aLoL), "false");
  aNode = findSymbol(mainDic, asSymbol(aLoL));
  AssertPtrNotNull(aNode);
  AssertPtrNotNull(aNode->value);
  AssertTrue(isBoolean(aNode->value));
  AssertFalse(aNode->value->boolean);
}

void Test_printBoolean(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  CoAlgObj* aLoL = newBoolean(coAlgs, TRUE);
  AssertPtrNotNull(aLoL);
  AssertStrEquals(printLoLDebug(aLoL, FALSE), "true");

  aLoL = newBoolean(coAlgs, FALSE);
  AssertPtrNotNull(aLoL);
  AssertStrEquals(printLoLDebug(aLoL, FALSE), "false");
}

/******

// TODO move to context

static Symbol* factorialStrs[] = {
  " ( 0 =nat ) ( pop 1 ) ( dup 1 - factorial * ) ifte ",
  NULL
};

void ignoreTest_defineFactorial(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);
  Context* aCtx = createContext(anInterp);
  AssertPtrNotNull(aCtx);

  Text* factorialText = createTextFromArrayOfStrings(coAlgs, factorialStrs);
  AssertPtrNotNull(factorialText);

  CoAlgObj* factorialLoL = parseAllSymbols(factorialText);
  AssertPtrNotNull(factorialLoL);

  defineJoyLoL(anInterp->coAlgebras, "factorial", factorialLoL);
  freeText(factorialText);
}
******/

// Parse and print some unhappy path lists

static Symbol* incorrectMarkerList[] = {
  " this ( is a list with incorrectly > matched list markers ",
  NULL
};

void ignoreTest_parseIncorrectMarkerList(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText = createTextFromArrayOfStrings(coAlgs, incorrectMarkerList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);
  AssertPtrNotNull(aLoL);
  AssertIntEquals(printSize(aLoL), 93);
  clearPrintSizeMarksDebug(aLoL, FALSE);
  AssertStrEquals(printLoL(aLoL),
    "this ( is a list with incorrectly ) matched list markers");
}

static Symbol* unmatchedMarkerList[] = {
  " this ( is a list [ with unmatched list markers ",
  NULL
};

void ignoreTest_parseUnmatchedMarkerList(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText = createTextFromArrayOfStrings(coAlgs, unmatchedMarkerList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);
  AssertPtrNotNull(aLoL);
  AssertIntEquals(printSize(aLoL), 83);
  clearPrintSizeMarksDebug(aLoL, FALSE);
  AssertStrEquals(printLoL(aLoL),
    "this ( is a list ( with unmatched list markers ) )");
}
\stoptyping

\startTestSuite[registerParsers]

\setCHeaderStream{private}
\startCHeader
extern Boolean registerParsers(JoyLoLInterp *jInterp);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean registerParsers(JoyLoLInterp *jInterp) {
  CoAlgebra* theCoAlg    = (CoAlgebra*) calloc(1, sizeof(CoAlgebra));
  theCoAlg->name         = ParsersName;
  theCoAlg->objectSize   = sizeof(CoAlgObj);
  theCoAlg->registerFunc = registerParsers;
  theCoAlg->equalityFunc = NULL;
  theCoAlg->printSize    = NULL;
  theCoAlg->printStr     = NULL;
  size_t tag = registerCoAlgebra(jInterp, theCoAlg);
  
  // do a sanity check...
  assert(tag == ParsersTag);
  assert(jInterp->coAlgs[tag].sClass);
  
  registerParserWords(jInterp);
    
  return TRUE;
}
\stopCCode

\startTestCase[should register the Parsers coAlg]

\startCTest
  // CTestsSetup has already created a jInterp
  // and run registerParsers
  
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs);
  AssertPtrNotNull(jInterp->coAlgs[ParsersTag].sClass);
  CoAlgebra *coAlg = jInterp->coAlgs[ParsersTag].sClass;
//  AssertIntTrue(registerParsers(jInterp));
  AssertPtrNotNull(jInterp->coAlgs[ParsersTag].sClass);
  AssertPtrEquals(jInterp->coAlgs[ParsersTag].sClass, coAlg);
  AssertIntEquals(
    jInterp->coAlgs[ParsersTag].sClass->objectSize,
    sizeof(CoAlgObj)
  )
\stopCTest
\stopTestCase
\stopTestSuite
