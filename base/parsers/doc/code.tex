% A ConTeXt document [master document: parsers.tex]

\dependsOn[jInterps]
\dependsOn[booleans]
\dependsOn[symbols]
\dependsOn[naturals]
\dependsOn[pairs]
\dependsOn[dictionaries]
\dependsOn[texts]

\section[title=Code]
\setCHeaderStream{public}

\startCCode
// The Parser parses a stream of characters obtained from a specific
// text. Since one of the texts is backed by readline interaction with
// a user, it is **critical** that nextSymbol ONLY get called when
// the parser actually needs a nextSymbol (and NOT before).
\stopCCode

We start by providing some example strings that we want to be able to 
parse. These will each be used as \type{CTest} examples below.

\CTestsSetup\
\startCTest
static Symbol* simpleList[] = {
  "this is a simple list ;; this is a comment ",
  NULL
};
//
static Symbol* simpleListWithSemiColons[] = {
  " this ; is;a ;; this is a comment ",
  " and;again ;; this is a second comment ",
  NULL
};
//
static Symbol* complexListWithSemiColons[] = {
  " this ; is;a test with some semi-colons ;; this is a comment ",
  " and;again;123;456;789 12;34 ;; this is a second comment ",
  " and;one;more;time ;; this is a third comment ",
  NULL
};
//
static Symbol* moreComplexList[] = {
  " this ( is ( a ( more ( complex ( list () ) ) ) ) ) ;; this is a comment ",
  NULL
};
//
static Symbol* differentList[] = {
  " this is  a different ( ( () () () ) ( ( ( ) ) ) ) list ;; with a comment  ",
  NULL
};
//
//static Symbol* factorialStrs[] = {
//  " ( 0 =nat ) ( pop 1 ) ( dup 1 - factorial * ) ifte ",
//  NULL
//};
//
//static Symbol* incorrectMarkerList[] = {
//  " this ( is a list with incorrectly > matched list markers ",
//  NULL
//};
//
//static Symbol* unmatchedMarkerList[] = {
//  " this ( is a list [ with unmatched list markers ",
//  NULL
//};
//
\stopCTest

\startTestSuite[match list symbols]

\setCHeaderStream{private}
\startCHeader
extern char matchingListSymbol(Symbol* curSymbol);
\stopCHeader

\startCCode
char matchingListSymbol(Symbol* curSymbol) {
  if (1 < strlen(curSymbol)) return 0;

  if (curSymbol[0] == '(') return ')';
  if (curSymbol[0] == '[') return ']';
  if (curSymbol[0] == '<') return '>';
  if (curSymbol[0] == '{') return '}';

  return 0;
}
\stopCCode

\startCHeader
extern size_t isClosingSymbol(Symbol* curSymbol);
\stopCHeader

\startCCode
size_t isClosingSymbol(Symbol* curSymbol) {
  if (1 < strlen(curSymbol)) return 0;

  if (curSymbol[0] == ')') return 1;
  if (curSymbol[0] == ']') return 1;
  if (curSymbol[0] == '>') return 1;
  if (curSymbol[0] == '}') return 1;

  return 0;
}
\stopCCode

\startCHeader
void reportMismatchedClosingSymbol(
  TextObj* aText, 
  char expected,
  char found
);
\stopCHeader

\startCCode
void reportMismatchedClosingSymbol(
  TextObj* aText,
  char expected,
  char found
) {
  if (expected == 0) return;

  char message[100];
  memset(message, 0, 100);
  strcat(message, "closing list expected [");
  message[strlen(message)] = expected;
  strcat(message, "] but found [");
  message[strlen(message)] = found;
  strcat(message, "]");
  reportError(aText, message);
}
\stopCCode

\startCHeader
void reportUnmatchedClosingSymbol(
  TextObj* aText,
  char expected
);
\stopCHeader

\startCCode
void reportUnmatchedClosingSymbol(
  TextObj* aText,
  char expected
) {
  if (expected == 0) return;

  char message[100];
  memset(message, 0, 100);
  strcat(message, "adding unmatched list closing [");
  message[strlen(message)] = expected;
  strcat(message, "]");
  reportError(aText, message);
}
\stopCCode

\startTestCase[should match List Symbols]
\startCTest
  AssertIntEquals(matchingListSymbol("("), ')');
  AssertIntEquals(matchingListSymbol("["), ']');
  AssertIntEquals(matchingListSymbol("{"), '}');
  AssertIntEquals(matchingListSymbol("<"), '>');
  AssertIntEquals(matchingListSymbol("#"), 0);
  AssertIntEquals(matchingListSymbol("silly"), 0);
\stopCTest
\stopTestCase
\stopTestSuite

\startCHeader
extern CoAlgObj* parseList(
  TextObj* aText,
  char closingChar
);
\stopCHeader

\startCCode
CoAlgObj* parseList(
  TextObj* aText,
  char closingChar
) {
  assert(aText);
  DEBUG(aText->debugFlag,
    "parseList %p '%c'\n", aText, closingChar);

  CoAlgObj* firstPair = NULL;
  CoAlgObj* lastPair  = NULL;

  while (!aText->completed) {

    nextSymbol(aText);
    DEBUG(aText->debugFlag,
      "parseList ns: %p\n", aText->sym);
    if (!aText->sym) {
      reportUnmatchedClosingSymbol(aText, closingChar);
      return firstPair;
    }

    // check to see if this is a closing list symbol
    if (isSymbol(aText->sym) &&
        isClosingSymbol(asSymbol(aText->sym))) {
      if (asSymbol(aText->sym)[0] != closingChar) {
        reportMismatchedClosingSymbol(aText, closingChar,
                                      asSymbol(aText->sym)[0]);
      }
      return firstPair;
    }
    assert(aText->jInterp);
    CoAlgObj* aNewPair = newPair(aText->jInterp, NULL, NULL);

    // check to see if this is an opening list symbol
    if (isSymbol(aText->sym)) {
      char matchingSymbol = matchingListSymbol(asSymbol(aText->sym));
      if (0 < matchingSymbol) {
        asCar(aNewPair) = parseList(aText, matchingSymbol);
      } else asCar(aNewPair) = aText->sym;
    } else asCar(aNewPair) = aText->sym;

    if (!firstPair) firstPair       = aNewPair;
    if (lastPair)   asCdr(lastPair) = aNewPair;

    lastPair = aNewPair;
  }

  if (0 < closingChar) reportUnmatchedClosingSymbol(aText, closingChar);
  return firstPair;
}
\stopCCode

\startTestSuite[parse one symbol]

\startCHeader
extern CoAlgObj* parseOneSymbol(TextObj* aText);
\stopCHeader

\startCCode
CoAlgObj* parseOneSymbol(TextObj* aText) {
  assert(aText);
  DEBUG(aText->debugFlag, "parseOneSymbol %p\n", aText);
  nextSymbol(aText);
  if (!aText->sym) return NULL;

  if (aText->sym->type &&
     (asTag(aText->sym) != SymbolsTag)) return aText->sym;

  // check to see if this is an opening list symbol
  char matchingSymbol = matchingListSymbol(asSymbol(aText->sym));
  if (0 < matchingSymbol) {
    return parseList(aText, matchingSymbol);
  }
  return aText->sym;
}
\stopCCode

\startTestCase[parse Simple List One Symbol At A Time]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText =
    createTextFromArrayOfStrings(jInterp, simpleList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "this");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "is");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "a");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "simple");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "list");

  aLoL = parseOneSymbol(aText);
  AssertPtrNull(aLoL);
  AssertIntTrue(aText->completed);
\stopCTest
\stopTestCase

\startTestCase[parse SemiColons One Symbol At A Time]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText =
    createTextFromArrayOfStrings(jInterp, simpleListWithSemiColons);

  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "this");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), ";");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "is");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), ";");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "a");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "and");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), ";");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "again");

  aLoL = parseOneSymbol(aText);
  AssertPtrNull(aLoL);
  AssertIntTrue(aText->completed);
\stopCTest
\stopTestCase

\startTestCase[parse Complex List One Symbol At A Time]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText = createTextFromArrayOfStrings(jInterp, moreComplexList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), SymbolsTag);
  AssertStrEquals(asSymbol(aLoL), "this");

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertPtrNotNull(asType(aLoL));
  AssertIntEquals(asTag(aLoL), PairsTag);
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  printLoL(aStrBuf, aLoL);
  AssertStrEquals(getCString(aStrBuf),
    "is ( a ( more ( complex ( list ( ) ) ) ) ) ");
  strBufClose(aStrBuf);

  aLoL = parseOneSymbol(aText);
  AssertPtrNull(aLoL);
  AssertIntTrue(aText->completed);
\stopCTest
\stopTestCase

\startTestCase[parse Boolean and find it in main dictionary]
\startCTest
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);
  Symbols* symbols = coAlgs->symbols;
  AssertPtrNotNull(symbols);
  Dictionary* mainDic = symbols->dictionary;
  AssertPtrNotNull(mainDic);

  Text* aText = createTextFromString(coAlgs, " true false ");
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertIntTrue(isAtom(aLoL));
  AssertIntTrue(isSymbol(aLoL));
  AssertStrEquals(asSymbol(aLoL), "true");
  AVLNode* aNode = findSymbol(mainDic, asSymbol(aLoL));
  AssertPtrNotNull(aNode);
  AssertPtrNotNull(aNode->value);
  AssertIntTrue(isBoolean(aNode->value));
  AssertIntTrue(aNode->value->boolean);

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertIntTrue(isAtom(aLoL));
  AssertIntTrue(isSymbol(aLoL));
  AssertStrEquals(asSymbol(aLoL), "false");
  aNode = findSymbol(mainDic, asSymbol(aLoL));
  AssertPtrNotNull(aNode);
  AssertPtrNotNull(aNode->value);
  AssertIntTrue(isBoolean(aNode->value));
  AssertFalse(aNode->value->boolean);
\stopCTest
\skipTestCase

\startTestCase[parse Print Naturals]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText =
    createTextFromString(jInterp, " 1234567890 not1234567890 ");
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertIntTrue(isAtom(aLoL));
  AssertIntTrue(isNatural(aLoL));
  AssertIntEquals( mpz_cmp_si(asNatural(aLoL), 1234567890), 0);
  StringBufferObj* aStrBuf = newStringBuffer(jInterp);
  printLoLDebug(aStrBuf, aLoL, FALSE);
  AssertStrEquals(getCString(aStrBuf), "1234567890 ");
  strBufClose(aStrBuf);

  aLoL = parseOneSymbol(aText);
  AssertPtrNotNull(aLoL);
  AssertIntTrue(isAtom(aLoL));
  AssertIntTrue(isSymbol(aLoL));
  AssertStrEquals(asSymbol(aLoL), "not1234567890");
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[parse all symbols]

\setCHeaderStream{public}
\startCHeader
extern CoAlgObj* parseAllSymbols(TextObj* aText);
\stopCHeader

\startCCode
CoAlgObj* parseAllSymbols(TextObj* aText) {
  DEBUG(FALSE, "parseAllSymbols %p]\n", aText);
  return parseList(aText, 0);
}
\stopCCode

We begin by parsing and printing some strings which exercise \quote{happy 
paths} in our parsing code. 

\startTestCase[parse SemiColons All At Once]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText =
    createTextFromArrayOfStrings(jInterp, complexListWithSemiColons);

  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);

  AssertPtrNotNull(aLoL);
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  printLoLDebug(aStrBuf, aLoL, FALSE);
  AssertStrEquals(getCString(aStrBuf),
    "this ; is ; a test with some semi-colons and ; again ; 123 ; 456 ; 789 12 ; 34 and ; one ; more ; time ");
  strBufClose(aStrBuf);
\stopCTest
\stopTestCase

\startTestCase[parse Print Simple List and test copyLoLs]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText =
    createTextFromArrayOfStrings(jInterp, simpleList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);
  AssertPtrNotNull(aLoL);
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  printLoL(aStrBuf, aLoL);
  AssertStrEquals(getCString(aStrBuf), "this is a simple list ");
  strBufClose(aStrBuf);

  CoAlgObj* lolCopy = copyLoL(jInterp, aLoL);
  AssertPtrNotEquals(aLoL, lolCopy);
  AssertIntTrue(equalLoLDebug(aLoL, lolCopy, FALSE));
\stopCTest
\stopTestCase

\startTestCase[parse Complex List From Single String]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText =
    createTextFromString(jInterp, moreComplexList[0]);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);

  AssertPtrNotNull(aLoL);
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  printLoL(aStrBuf, aLoL);
  AssertStrEquals(getCString(aStrBuf),
    "this ( is ( a ( more ( complex ( list ( ) ) ) ) ) ) ");
  strBufClose(aStrBuf);
\stopCTest
\stopTestCase

\startTestCase[parse Print Complex List]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText =
    createTextFromArrayOfStrings(jInterp, moreComplexList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);
  AssertPtrNotNull(aLoL);
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  printLoL(aStrBuf, aLoL);
  AssertStrEquals(getCString(aStrBuf),
    "this ( is ( a ( more ( complex ( list ( ) ) ) ) ) ) ");
  strBufClose(aStrBuf);
  
  CoAlgObj* lolCopy = copyLoL(jInterp, aLoL);
  AssertPtrNotEquals(aLoL, lolCopy);
  AssertIntTrue(equalLoLDebug(aLoL, lolCopy, FALSE));
\stopCTest
\stopTestCase

\startTestCase[parse Print Different List]
\startCTest
  AssertPtrNotNull(jInterp);

  TextObj* aText =
    createTextFromArrayOfStrings(jInterp, differentList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);
  AssertPtrNotNull(aLoL);
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  printLoL(aStrBuf, aLoL);
  AssertStrEquals(getCString(aStrBuf),
    "this is a different ( ( ( ) ( ) ( ) ) ( ( ( ) ) ) ) list ");
  strBufClose(aStrBuf);
\stopCTest
\stopTestCase

Now we parse and print some strings which exercise \quote{unhappy paths} 
in our parsing code. 

\startTestCase[parse Incorrect Marker List]
\startCTest
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText = createTextFromArrayOfStrings(coAlgs, incorrectMarkerList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);
  AssertPtrNotNull(aLoL);
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  printLoL(aStrBuf, aLoL);
  AssertStrEquals(getCString(aStrBuf),
    "this ( is a list with incorrectly ) matched list markers");
  strBufClose(aStrBuf);
\stopCTest
\ignoreTestCase

\startTestCase[parse Unmatched Marker List]
\startCTest
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);

  Text* aText = createTextFromArrayOfStrings(coAlgs, unmatchedMarkerList);
  AssertPtrNotNull(aText);

  CoAlgObj* aLoL = parseAllSymbols(aText);
  AssertPtrNotNull(aLoL);
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  printLoL(aStrBuf, aLoL);
  AssertStrEquals(getCString(aStrBuf),
    "this ( is a list ( with unmatched list markers ) )");
  strBufClose(aStrBuf);
\stopCTest
\ignoreTestCase
\stopTestSuite

\startTestSuite[registerParsers]

\setCHeaderStream{private}
\startCHeader
extern Boolean registerParsers(JoyLoLInterp *jInterp);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean registerParsers(JoyLoLInterp *jInterp) {
  CoAlgebra* theCoAlg    = (CoAlgebra*) calloc(1, sizeof(CoAlgebra));
  theCoAlg->name         = ParsersName;
  theCoAlg->objectSize   = sizeof(CoAlgObj);
  theCoAlg->registerFunc = registerParsers;
  theCoAlg->equalityFunc = NULL;
  theCoAlg->printStr     = NULL;
  size_t tag = registerCoAlgebra(jInterp, theCoAlg);
  
  // do a sanity check...
  assert(tag == ParsersTag);
  assert(jInterp->coAlgs[tag].sClass);
  
  registerParserWords(jInterp);
    
  return TRUE;
}
\stopCCode

\startTestCase[should register the Parsers coAlg]

\startCTest
  // CTestsSetup has already created a jInterp
  // and run registerParsers
  
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs);
  AssertPtrNotNull(jInterp->coAlgs[ParsersTag].sClass);
  CoAlgebra *coAlg = jInterp->coAlgs[ParsersTag].sClass;
//  AssertIntTrue(registerParsers(jInterp));
  AssertPtrNotNull(jInterp->coAlgs[ParsersTag].sClass);
  AssertPtrEquals(jInterp->coAlgs[ParsersTag].sClass, coAlg);
  AssertIntEquals(
    jInterp->coAlgs[ParsersTag].sClass->objectSize,
    sizeof(CoAlgObj)
  )
\stopCTest
\stopTestCase
\stopTestSuite
