% A ConTeXt document [master document: texts.tex]

\section[title=Code]

\dependsOn[jInterps]
\dependsOn[dictionaries]
\dependsOn[symbols]

\setCHeaderStream{public}
\startCHeader
struct text_object_struct;

typedef void (NextLineFunc)(struct text_object_struct*);

typedef struct text_object_struct {
  CoAlgObj super;
  //
  // fields used by all backing types
  //
  size_t        completed;
  CoAlgObj*     sym;
  Symbol*       curLine;
  Symbol*       curChar;
  Symbol*       lastChar;
  NextLineFunc* nextLine;
  JoyLoLInterp* jInterp;
  Boolean       debugFlag;
  //
  // array of strings specific fields
  //
  Symbol** textLines;
  size_t curLineNum;
  //
  // external file specific fields
  //
  FILE* inputFile;
  //
  // readline specific fields
  //
  Symbol*  newPrompt;
  Symbol*  continuePrompt;
  Symbol*  curPrompt;
  DictObj* curNode;
  Symbol*  curCompletionText;
  size_t   curCompletionLen;
} TextObj;
\stopCHeader



\startCCode
// Texts are a collection of characters, which are used by the Parser
// to extract successive symbols.
//
// Texts are created on one of three backing suppliers of characters:
// 1. a fixed array of strings
// 2. an external file
// 3. a readline interaction with a user
//
// In all three cases, the Parser's nextSymbol method requests successive
// **lines** of characters (deliminated by new-line-characters).
//
// It is critical, for correct interaction with the user via readline,
// that the initial line is NOT obtained until actually requested by
// the parser's nextSymbol method.
//
// It is also critical that once completed, none of the sources, get
// asked for subsequent lines.
//
// When the text has been completed, the nextLine function ensures
// that aText->curLine is NULL.
\stopCCode

\startCHeader
extern void freeText(TextObj* aText);
\stopCHeader

\startCCode
void freeText(TextObj* aText) {
  if (!aText) return;

  free(aText);
}
\stopCCode

\setCHeaderStream{private}
\startCHeader
extern void nextLineExit(TextObj* aText);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void nextLineExit(TextObj* aText) {
  if (!aText) return; // there is nothing we can do!
  aText->sym       = NULL;
  aText->curLine   = NULL;
  aText->curChar   = NULL;
  aText->lastChar  = NULL;
  aText->completed = TRUE;
}
\stopCCode

/////////////////////////////////////////////////////////////////////////////
// nextSymbol
//

\startCHeader
extern void nextSymbol(TextObj* aText);
\stopCHeader

\startCCode
void nextSymbol(TextObj* aText) {
  assert(aText);
  assert(aText->jInterp);

  DEBUG(aText->debugFlag,
    "->nextSymbol [%s]{%s}\n", aText->curLine, aText->curChar);
  aText->sym = NULL;

  // ensure we have a non-empty line
  while ((!aText->completed) && (aText->curChar == aText->lastChar)) {
    aText->nextLine(aText);
  }
  if (!aText->curLine) {
    DEBUG(aText->debugFlag, "<-nextSymbol End of Text %s\n","");
    return; // we have exhausted this text
  }

  size_t  parsingNatural = TRUE;
  Symbol* symStart       = aText->curChar;
  Symbol* symEnd         = aText->curChar;
  Symbol* lastChar       = aText->lastChar;
  char    matchingQuote  = 0;
  while (symStart == symEnd) {
    while (symEnd < lastChar) {
      if (matchingQuote) {
        if (*symEnd == matchingQuote) break; // we have found our quote
        //
        // we are in the middle of a quote
        //
        symEnd++;
        parsingNatural = FALSE;
        //
      } else if (*symEnd == '\"' || *symEnd == '\'') {
        //
        // the beginning of a quote
        //
        symStart++;
        matchingQuote = *symEnd;
        symEnd++;
        //
      } else if (*symEnd < 33) {
        //
        // white space
        //
        if (symStart != symEnd)  break; // we have found a symbol
        //
        // ignore whitespace (of any type)
        //
        symStart++;
        symEnd++;
        //
      } else if (
        *symEnd == '('  || *symEnd == ')'  ||
        *symEnd == '<'  || *symEnd == '>'  ||
        *symEnd == '['  || *symEnd == ']'  ||
        *symEnd == '{'  || *symEnd == '}' ) {
        //
        // '(', ')', '<', '>', '[', ']'
        //
        if (symStart != symEnd) break; // we have found a symbol
        //
        // '(' ')' are symbols in their own right
        //
        parsingNatural = FALSE;
        symEnd++;
        break;
        //
      } else if ( *symEnd == ';') {
        //
        if (symStart != symEnd) break; // we have found a symbol
        //
        const char* symEndP1 = symEnd + 1;
        if ( symEndP1 < lastChar && *symEndP1 == ';') {
          //
          // we have found the beginning of a single line comment
          // ... so restart search for the next symbol on the next line
          //
          aText->nextLine(aText);
          if (!aText->curLine) return; // no more symbols
          symStart = aText->curChar;
          symEnd   = aText->curChar;
          lastChar = aText->lastChar;
        } else {
          //
          // ';' is a symbol in its own right
          //
          parsingNatural = FALSE;
          symEnd++;
          break;
          //
        }
        //
      } else {
        //
        // any other character is part of a symbol
        //
        // check to see if we are still parsing a natural
        //
        if ('0' <= *symEnd && *symEnd <= '9') {
          // do nothing
        } else {
          parsingNatural = FALSE;
        }
        //
        symEnd++;
        //
      }
    }

    if (symStart == symEnd) {
      aText->nextLine(aText);
      if (!aText->curLine) return; // no more symbols
      symStart = aText->curChar;
      symEnd   = aText->curChar;
      lastChar = aText->lastChar;
    }
  }

  char* aSymbol = strndup(symStart, symEnd - symStart); // TODO this thrashes memory ;-(
  if (matchingQuote && symEnd < lastChar) symEnd++; // skip ending quote
  aText->curChar = symEnd;
  DEBUG(aText->debugFlag, "--nextSymbol == [%s]\n", aSymbol);

  // check to see if this is the exit or quit symbol ...
  // ... and if so rest the nextLine function
  if (strcmp(aSymbol, "exit") == 0 || strcmp(aSymbol, "quit") == 0) {
    aText->nextLine = nextLineExit;
  }

  if (parsingNatural) {
    DEBUG(aText->debugFlag, "--nextSymbol == %s (natural)\n", aSymbol);
    // we have parsed a natural... so create a new natural
    //
    aText->sym = newNatural(aText->jInterp, aSymbol);
    //
    DEBUG(aText->debugFlag, "<-nextSymbol %s (natural)\n", aSymbol);
  } else {
    // we have parsed a symbol... so create a new symbol
    //
    DictObj* aSym = createSymbol(aText->jInterp, aSymbol);
    aText->sym = newSymbol(aText->jInterp, aSym->symbol);
    //
    DEBUG(aText->debugFlag, "<-nextSymbol [%s] (symbol)\n",
      ((SymbolObj*)(aText->sym))->sym);
  }
  free(aSymbol);
}
\stopCCode

\startCHeader
extern void reportError(TextObj *aText, const char* message);
\stopCHeader

\startCCode
void reportError(TextObj *aText, const char* message) {
  fprintf(stderr, "\n\n%s\n", message);
  if (aText->curLine) {
    fprintf(stderr, "while parsing\n");
    fprintf(stderr, "\t[%s]\n", aText->curLine);
    fprintf(stderr, "at character %zu\n\n", aText->curChar - aText->curLine);
  } else {
    fprintf(stderr, "at end of text\n\n");
  }
}
\stopCCode

\setCHeaderStream{private}
\startCHeader
extern Boolean equalityTextsCoAlg(CoAlgObj* lolA, CoAlgObj* lolB,
                                  size_t debugFlag);
\stopCHeader

\startCCode
Boolean equalityTextsCoAlg(CoAlgObj* lolA, CoAlgObj* lolB,
                           size_t debugFlag) {
  DEBUG(debugFlag, "textsCoAlg-equal a:%p b:%p\n", lolA, lolB);
  if (!lolA && !lolB) return TRUE;
  if (!lolA && lolB)  return FALSE;
  if (lolA  && !lolB) return FALSE;
  if (asType(lolA) != asType(lolB)) return FALSE;
  if (!asType(lolA)) return FALSE;
  if (asTag(lolA)  != TextsTag) return FALSE;
  if (lolA != lolB) return FALSE;
  return TRUE;
}
\stopCCode

\startTestSuite[printing texts]

\startCHeader
extern Boolean printStrTextsCoAlg(
  StringBufferObj *aStrBuf,
  CoAlgObj        *aLoL
);
\stopCHeader

\startCCode
Boolean printStrTextsCoAlg(
  StringBufferObj *aStrBuf,
  CoAlgObj        *aLoL
) {
  assert(aLoL);
  assert(asTag(aLoL) == TextsTag);

  strBufPrintf(aStrBuf, "--texts-- ");
  return TRUE;
}
\stopCCode

\startTestCase[should print texts]

\startCTest
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs[TextsTag].sClass);

  TextObj* aNewText = createTextFromString(jInterp, "a string");
  AssertPtrNotNull(aNewText);
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  printLoLDebug(aStrBuf, (CoAlgObj*)aNewText, FALSE);
  AssertStrEquals(getCString(aStrBuf), "--texts-- ");
  strBufClose(aStrBuf);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[registerTexts]

\startCHeader
extern Boolean registerTexts(JoyLoLInterp *jInterp);
\stopCHeader

\startCCode
Boolean registerTexts(JoyLoLInterp *jInterp) {
  assert(jInterp);
  assert(jInterp->coAlgs);
  
  CoAlgebra* theCoAlg    = (CoAlgebra*) calloc(1, sizeof(CoAlgebra));
  assert(theCoAlg);
  
  theCoAlg->name         = TextsName;
  theCoAlg->objectSize   = sizeof(TextObj);
  theCoAlg->registerFunc = registerTexts;
  theCoAlg->equalityFunc = equalityTextsCoAlg;
  theCoAlg->printStr     = printStrTextsCoAlg;
  size_t tag = registerCoAlgebra(jInterp, theCoAlg);
  
  // do a sanity check...
  assert(tag == TextsTag);
  assert(jInterp->coAlgs[tag].sClass);
  
  registerTextWords(jInterp);
  
  return TRUE;
}
\stopCCode

\startTestCase[should register the Texts coAlg]

\startCTest
  // CTestsSetup has already created a jInterp
  // and run registerTexts
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs);
  AssertPtrNotNull(jInterp->coAlgs[TextsTag].sClass);
  CoAlgebra *coAlg = jInterp->coAlgs[TextsTag].sClass;
//  AssertIntTrue(registerTexts(jInterp));
  AssertPtrNotNull(jInterp->coAlgs[TextsTag].sClass);
  AssertPtrEquals(jInterp->coAlgs[TextsTag].sClass, coAlg);
  AssertIntEquals(
    jInterp->coAlgs[TextsTag].sClass->objectSize,
    sizeof(TextObj)
  )
\stopCTest
\stopTestCase
\stopTestSuite
