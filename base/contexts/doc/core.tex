% A ConTeXt document [master document: contexts.tex]

\section[title=Context core code]
\setCHeaderStream{public}

\startCHeader
typedef void (PushCtx)(
  ContextObj *aCtx,
  CoAlgObj   *lolToPush
);

#define pushCtxData(aCtx, lolToPush)        \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->pushCtxDataFunc),                   \
    (getContextsClass(aCtx->jInterp)        \
      ->pushCtxDataFunc(aCtx, lolToPush))   \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushCtxDataImpl(
  ContextObj* aCtx,
  CoAlgObj* lolToPush
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushCtxDataImpl(
  ContextObj* aCtx,
  CoAlgObj* lolToPush
) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->data = newPair(aCtx->jInterp, lolToPush, aCtx->data);
}
\stopCCode

\startCHeader
typedef void (PushNullCtx)(
  ContextObj *aCtx
);

#define pushNullCtxData(aCtx)               \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->pushNullCtxDataFunc),               \
    (getContextsClass(aCtx->jInterp)        \
      ->pushNullCtxDataFunc(aCtx))          \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushNullCtxDataImpl(
  ContextObj* aCtx
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushNullCtxDataImpl(
  ContextObj* aCtx
) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->data = newPair(aCtx->jInterp, NULL, aCtx->data);
}
\stopCCode

\startCHeader
typedef void (PushSymbolCtx)(
  ContextObj *aCtx,
  Symbol     *aSymbol
);

#define pushSymbolCtxData(aCtx, aSymbol)      \
  (                                           \
    assert(aCtx),                             \
    assert(getContextsClass(aCtx->jInterp)    \
      ->pushSymbolCtxDataFunc),               \
    (getContextsClass(aCtx-jInterp)           \
      ->pushSymbolCtxDataFunc(aCtx, aSymbol)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushSymbolCtxDataImpl(
  ContextObj* aCtx,
  Symbol* aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushSymbolCtxDataImpl(
  ContextObj* aCtx,
  Symbol* aSymbol
) {
  if (!aCtx) return;
  if (!aSymbol) return;
  assert(aCtx->jInterp);

  CoAlgObj* aSymbolPA =
    getSymbol(aCtx->jInterp, aSymbol);
  if (!aSymbolPA) return;
  aCtx->data = newPair(aCtx->jInterp, aSymbolPA, aCtx->data);
}
\stopCCode

\startCHeader
typedef void (PushParsedArrayOfStringsCtx)(
  ContextObj *aCtx,
  Symbol     *someStrings[]
);

#define pushParsedArrayOfStringsCtxData(      \
  aCtx, someStrings)                          \
  (                                           \
    assert(aCtx),                             \
    assert(getContextsClass(aCtx->jInterp)    \
      ->pushParsedArrayOfStringsCtxDataFunc), \
    (getContextsClass(aCtx->jInterp)          \
      ->pushParsedArrayOfStringsCtxDataFunc(  \
        aCtx, someStrings))                   \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushParsedArrayOfStringsCtxDataImpl(
  ContextObj* aCtx,
  Symbol* someStrings[]
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushParsedArrayOfStringsCtxDataImpl(
  ContextObj* aCtx,
  Symbol* someStrings[]
) {
  if (!aCtx) return;
  if (!someStrings) return;
  TextObj* aText =
    createTextFromArrayOfStrings(aCtx->jInterp, someStrings);
  pushParsedTextCtxData(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
typedef void (PushParsedStringCtx)(
  ContextObj *aCtx,
  Symbol     *aString
);

#define pushParsedStringCtxData(aCtx, aString)      \
  (                                                 \
    assert(aCtx),                                   \
    assert(getContextsClass(aCtx->jInterp)          \
      ->pushParsedStringCtxDataFunc),               \
    (getContextsClass(aCtx->jInterp)                \
      ->pushParsedStringCtxDataFunc(aCtx, aSring))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushParsedStringCtxDataImpl(
  ContextObj* aCtx,
  Symbol* aString
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushParsedStringCtxDataImpl(
  ContextObj* aCtx,
  Symbol* aString
) {
  if (!aCtx) return;
  if (!aString) return;
  TextObj* aText =
    createTextFromString(aCtx->jInterp, aString);
  pushParsedTextCtxData(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
typedef void (PushParsedTextCtx)(
  ContextObj *aCtx,
  TextObj    *aTex
);

#define pushParsedTextCtxData(aCtx, aText)      \
  (                                             \
    assert(aCtx),                               \
    assert(getContextsClass(aCtx->jInterp)      \
      ->pushParsedTextCtxDataFunc),             \
    (getContextsClass(aCtx->jInterp)            \
      ->pushParsedTextCtxDataFunc(aCtx, aText)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushParsedTextCtxDataImpl(
  ContextObj* aCtx,
  TextObj* aText
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushParsedTextCtxDataImpl(
  ContextObj* aCtx,
  TextObj* aText
) {
  if (!aCtx) return;
  if (!aText) return;
  assert(aCtx->jInterp);
  CoAlgObj* aLoL = parseAllSymbols(aText);
  if (!aLoL) return;
  aCtx->data = newPair(aCtx->jInterp, aLoL, aCtx->data);
}
\stopCCode

\startCHeader
typedef void (PrependListCtx)(
  ContextObj *aCtx,
  CoAlgObj   *lolToPrepend
);

#define prependListCtxData(aCtx, lolToPrepend)      \
  (                                                 \
    assert(aCtx),                                   \
    assert(getContextsClass(aCtx->jInterp)          \
      ->prependListCtxDataFunc),                    \
    (getContextsClass(aCtx->jInterp)                \
      ->prependListCtxDataFunc(aCtx, lolToPrepend)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void prependListCtxDataImpl(
  ContextObj* aCtx,
  CoAlgObj* lolToPrepend
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void prependListCtxDataImpl(
  ContextObj* aCtx,
  CoAlgObj* lolToPrepend
) {
  if (!aCtx) return;
  if (!lolToPrepend) return;

  // ensure lolToPrepend is a list
  if (!isPair(lolToPrepend)) {
    lolToPrepend = newPair(aCtx->jInterp, lolToPrepend, NULL);
    assert(lolToPrepend);
  }

  // find end of lolToPrepend
  CoAlgObj* lolList = lolToPrepend;
  while(asCdr(lolList) && isPair(asCdr(lolList))) {
    lolList = asCdr(lolList);
  }

  // ensure that if lolToPrepend ends in a non-pair we make it a pair
  if (asCdr(lolList) && !isPair(asCdr(lolList))) {
    asCdr(lolList) = newPair(aCtx->jInterp, asCdr(lolList), NULL);
    assert(asCdr(lolList));
  }

  // place existing data stack at end of lolToPrepend
  asCdr(lolList) = aCtx->data;
  aCtx->data     = lolToPrepend;
}
\stopCCode

\startCHeader
typedef CoAlgObj *(PopCtx)(
  ContextObj *aCtx
);

#define popCtxData(aCtx)                    \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->popCtxDataFunc),                    \
    (getContextsClass(aCtx->jInterp)        \
      ->popCtxDataFunc(aCtx))               \
  )

#define popCtxDataInto(aCtx, aVar)                              \
assert(aCtx);                                                   \
CoAlgObj* aVar = popCtxData(aCtx);                              \
if (aCtx->tracingOn) {                                          \
  JoyLoLInterp *jInterp = aCtx->jInterp;                        \
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);          \
  strBufPrintf(jInterp, aStrBuf, "%s = ", #aVar);               \
  printLoL(jInterp, aStrBuf, aVar);                             \
  strBufPrintf(jInterp, aStrBuf, "\n");                         \
  jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));  \
  strBufClose(jInterp, aStrBuf);                                \
}
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern CoAlgObj* popCtxDataImpl(
  ContextObj* aCtx
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
CoAlgObj* popCtxDataImpl(
  ContextObj* aCtx
) {
  if (!aCtx) return NULL;
  if (!aCtx->data) return NULL;

  CoAlgObj* poppedLoL = asCar(aCtx->data);
  aCtx->data          = asCdr(aCtx->data);
  return poppedLoL;
}
\stopCCode

\startCHeader
#define pushCtxProcess(aCtx, lolToPush)        \
  (                                            \
    assert(aCtx),                              \
    assert(getContextsClass(aCtx->jInterp)     \
      ->pushCtxProcessFunc),                   \
    (getContextsClass(aCtx->jInterp)           \
      ->pushCtxProcessFunc(aCtx, lolToPush))   \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushCtxProcessImpl(
  ContextObj* aCtx,
  CoAlgObj* lolToPush
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushCtxProcessImpl(
  ContextObj* aCtx,
  CoAlgObj* lolToPush
) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->process = newPair(aCtx->jInterp, lolToPush, aCtx->process);
}
\stopCCode

\startCHeader
#define pushSymbolCtxProcess(aCtx, aSymbol)      \
  (                                              \
    assert(aCtx),                                \
    assert(getContextsClass(aCtx->jInterp)       \
      ->pushSymbolCtxProcessFunc),               \
    (getContextsClass(aCtx-jInterp)              \
      ->pushSymbolCtxProcessFunc(aCtx, aSymbol)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushSymbolCtxProcessImpl(
  ContextObj* aCtx,
  Symbol* aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushSymbolCtxProcessImpl(
  ContextObj* aCtx,
  Symbol* aSymbol
) {
  if (!aCtx) return;
  if (!aSymbol) return;
  assert(aCtx->jInterp);

  CoAlgObj* aSymbolPA =
    getSymbol(aCtx->jInterp, aSymbol);
  if (!aSymbolPA) return;
  aCtx->process = newPair(aCtx->jInterp, aSymbolPA, aCtx->process);
}
\stopCCode

\startCHeader
#define pushParsedArrayOfStringsCtxProcess(      \
  aCtx, someStrings)                             \
  (                                              \
    assert(aCtx),                                \
    assert(getContextsClass(aCtx->jInterp)       \
      ->pushParsedArrayOfStringsCtxProcessFunc), \
    (getContextsClass(aCtx->jInterp)             \
      ->pushParsedArrayOfStringsCtxProcessFunc(  \
        aCtx, someStrings))                      \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushParsedArrayOfStringsCtxProcessImpl(
  ContextObj* aCtx,
  Symbol* someStrings[]
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushParsedArrayOfStringsCtxProcessImpl(
  ContextObj* aCtx,
  Symbol* someStrings[]
) {
  if (!aCtx) return;
  if (!someStrings) return;
  TextObj* aText =
    createTextFromArrayOfStrings(aCtx->jInterp, someStrings);
  pushParsedTextCtxProcess(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
#define pushParsedStringCtxProcess(aCtx, aString)      \
  (                                                    \
    assert(aCtx),                                      \
    assert(getContextsClass(aCtx->jInterp)             \
      ->pushParsedStringCtxProcessFunc),               \
    (getContextsClass(aCtx->jInterp)                   \
      ->pushParsedStringCtxProcessFunc(aCtx, aSring))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushParsedStringCtxProcessImpl(
  ContextObj* aCtx,
  Symbol* aString
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushParsedStringCtxProcessImpl(
  ContextObj* aCtx,
  Symbol* aString
) {
  if (!aCtx) return;
  if (!aString) return;
  TextObj* aText =
    createTextFromString(aCtx->jInterp, aString);
  pushParsedTextCtxProcess(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
#define pushParsedTextCtxProcess(aCtx, aText)      \
  (                                                \
    assert(aCtx),                                  \
    assert(getContextsClass(aCtx->jInterp)         \
      ->pushParsedTextCtxProcessFunc),             \
    (getContextsClass(aCtx->jInterp)               \
      ->pushParsedTextCtxProcessFunc(aCtx, aText)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushParsedTextCtxProcessImpl(
  ContextObj* aCtx,
  TextObj* aText
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushParsedTextCtxProcessImpl(
  ContextObj* aCtx,
  TextObj* aText
) {
  if (!aCtx) return;
  if (!aText) return;
  assert(aCtx->jInterp);
  CoAlgObj* aLoL = parseAllSymbols(aText);
  if (!aLoL) return;
  aCtx->process = newPair(aCtx->jInterp, aLoL, aCtx->process);
}
\stopCCode

\startCHeader
#define prependListCtxProcess(aCtx, lolToPrepend)      \
  (                                                    \
    assert(aCtx),                                      \
    assert(getContextsClass(aCtx->jInterp)             \
      ->prependListCtxProcessFunc),                    \
    (getContextsClass(aCtx->jInterp)                   \
      ->prependListCtxProcessFunc(aCtx, lolToPrepend)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void prependListCtxProcessImpl(
  ContextObj* aCtx,
  CoAlgObj* lolToPrepend
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void prependListCtxProcessImpl(
  ContextObj* aCtx,
  CoAlgObj* lolToPrepend
) {
  if (!aCtx) return;
  if (!lolToPrepend) return;

  // ensure lolToPrepend is a list
  if (!isPair(lolToPrepend)) {
    lolToPrepend = newPair(aCtx->jInterp, lolToPrepend, NULL);
    assert(lolToPrepend);
  }

  // find end of lolToPrepend
  CoAlgObj* lolList = lolToPrepend;
  while(asCdr(lolList) && isPair(asCdr(lolList))) {
    lolList = asCdr(lolList);
  }

  // ensure that if lolToPrepend ends in a non-pair we make it a pair
  if (asCdr(lolList) && !isPair(asCdr(lolList))) {
    asCdr(lolList) = newPair(aCtx->jInterp, asCdr(lolList), NULL);
    assert(asCdr(lolList));
  }

  // place existing process stack at end of lolToPrepend
  asCdr(lolList)  = aCtx->process;
  aCtx->process   = lolToPrepend;
}
\stopCCode

\startCHeader
#define popCtxProcess(aCtx)                    \
  (                                            \
    assert(aCtx),                              \
    assert(getContextsClass(aCtx->jInterp)     \
      ->popCtxProcessFunc),                    \
    (getContextsClass(aCtx->jInterp)           \
      ->popCtxProcessFunc(aCtx))               \
  )

#define popCtxProcessInto(aCtx, aVar)                           \
assert(aCtx);                                                   \
CoAlgObj* aVar = popCtxProcess(aCtx);                           \
if (aCtx->tracingOn) {                                          \
  JoyLoLInterp *jInterp = aCtx->jInterp;                        \
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);          \
  strBufPrintf(jInterp, aStrBuf, "%s = ", #aVar);               \
  printLoL(jInterp, aStrBuf, aVar);                             \
  strBufPrintf(jInterp, aStrBuf, "\n");                         \
  jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));  \
  strBufClose(jInterp, aStrBuf);                                \
}
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern CoAlgObj* popCtxProcessImpl(
  ContextObj* aCtx
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
CoAlgObj* popCtxProcessImpl(
  ContextObj* aCtx
) {
  if (!aCtx->process) return NULL;

  CoAlgObj* poppedLoL = asCar(aCtx->process);
  aCtx->process       = asCdr(aCtx->process);
  return poppedLoL;
}
\stopCCode

\startCHeader
typedef Boolean (ExtendJoyLoL)(
  JoyLoLInterp *jInterp,
  Symbol       *definedName,
  CFunction    *aFunc
);

#define extendJoyLoL(jInterp, definedName, aFunc)       \
  (                                                     \
    assert(getContextsClass(jInterp)                    \
      ->extendJoyLoLFunc),                              \
    (getContextsClass(jInterp)                          \
      ->extendJoyLoLFunc(jInterp, definedName, aFunc))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern Boolean extendJoyLoLImpl(
  JoyLoLInterp *jInterp,
  Symbol       *definedName,
  CFunction    *aFunc
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean extendJoyLoLImpl(
  JoyLoLInterp *jInterp,
  Symbol       *definedName,
  CFunction    *aFunc
) {
  assert(jInterp);
  DictObj* aSym =
    createSymbol(jInterp, definedName);
  aSym->value =
    (CoAlgObj*)newCFunction(jInterp, aFunc);

  return TRUE;
}
\stopCCode

\startCHeader
typedef Boolean (DefineJoyLoL)(
  JoyLoLInterp *jInterp,
  Symbol       *definedName,
  CoAlgObj     *aLoL
);

#define defineJoyLoL(jInterp, definedName, aLoL)      \
  (                                                   \
    assert(getContextsClass(jInterp)                  \
      ->defineJoyLoLFunc),                            \
    (getContextsClass(jInterp)                        \
      ->defineJoyLoLFunc(jInterp, definedName, aLoL)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern Boolean defineJoyLoLImpl(
  JoyLoLInterp *jInterp,
  Symbol       *definedName,
  CoAlgObj     *aLoL
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean defineJoyLoLImpl(
  JoyLoLInterp *jInterp,
  Symbol       *definedName,
  CoAlgObj     *aLoL
) {
  assert(jInterp);
  DictObj* aSym =
    createSymbol(jInterp, definedName);
  aSym->value = copyLoL(jInterp, aLoL);

  return TRUE;
}
\stopCCode

\starttyping
\startCHeader
extern Boolean defineContext(
  JoyLoLInterp* jInterp,
  Symbol* definedName,
  ContextObj* newCtx
);
\stopCHeader

\startCCode
Boolean defineContext(
  JoyLoLInterp* jInterp,
  Symbol* definedName,
  ContextObj* newCtx
) {
  DEBUG(jInterp, "defineContext %p [%s] %p\n",
        jInterp, definedName, newCtx);
  assert(jInterp);
  DictObj* aSym =
    createSymbol(jInterp, definedName);
  aSym->value   = newContext(jInterp, newCtx);

  return TRUE;
}
\stopCCode
\stoptyping