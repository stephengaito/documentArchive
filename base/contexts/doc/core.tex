% A ConTeXt document [master document: contexts.tex]

\section[title=Context core code]

\startCHeader
extern void pushCtxData(
  ContextObj* aCtx,
  CoAlgObj* lolToPush
);
\stopCHeader

\startCCode
void pushCtxData(
  ContextObj* aCtx,
  CoAlgObj* lolToPush
) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->data = newPair(aCtx->jInterp, lolToPush, aCtx->data);
}
\stopCCode

\startCHeader
extern void pushNullCtxData(ContextObj* aCtx);
\stopCHeader

\startCCode
void pushNullCtxData(ContextObj* aCtx) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->data = newPair(aCtx->jInterp, NULL, aCtx->data);
}
\stopCCode

\startCHeader
extern void pushSymbolCtxData(
  ContextObj* aCtx,
  Symbol* aSymbol
);
\stopCHeader

\startCCode
void pushSymbolCtxData(
  ContextObj* aCtx,
  Symbol* aSymbol
) {
  if (!aCtx) return;
  if (!aSymbol) return;
  assert(aCtx->jInterp);

  CoAlgObj* aSymbolPA =
    getSymbol(aCtx->jInterp, aSymbol);
  if (!aSymbolPA) return;
  aCtx->data = newPair(aCtx->jInterp, aSymbolPA, aCtx->data);
}
\stopCCode

\startCHeader
extern void pushParsedArrayOfStringsCtxData(
  ContextObj* aCtx,
  Symbol* someStrings[]
);
\stopCHeader

\startCCode
void pushParsedArrayOfStringsCtxData(
  ContextObj* aCtx,
  Symbol* someStrings[]
) {
  if (!aCtx) return;
  if (!someStrings) return;
  TextObj* aText =
    createTextFromArrayOfStrings(aCtx->jInterp, someStrings);
  pushParsedTextCtxData(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
extern void pushParsedStringCtxData(
  ContextObj* aCtx,
  Symbol* aString
);
\stopCHeader

\startCCode
void pushParsedStringCtxData(
  ContextObj* aCtx,
  Symbol* aString
) {
  if (!aCtx) return;
  if (!aString) return;
  TextObj* aText =
    createTextFromString(aCtx->jInterp, aString);
  pushParsedTextCtxData(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
extern void pushParsedTextCtxData(
  ContextObj* aCtx,
  TextObj* aText
);
\stopCHeader

\startCCode
void pushParsedTextCtxData(
  ContextObj* aCtx,
  TextObj* aText
) {
  if (!aCtx) return;
  if (!aText) return;
  assert(aCtx->jInterp);
  CoAlgObj* aLoL = parseAllSymbols(aText);
  if (!aLoL) return;
  aCtx->data = newPair(aCtx->jInterp, aLoL, aCtx->data);
}
\stopCCode

\startCHeader
extern void prependListCtxData(
  ContextObj* aCtx,
  CoAlgObj* lolToPrepend
);
\stopCHeader

\startCCode
void prependListCtxData(
  ContextObj* aCtx,
  CoAlgObj* lolToPrepend
) {
  if (!aCtx) return;
  if (!lolToPrepend) return;

  // ensure lolToPrepend is a list
  if (!isPair(lolToPrepend)) {
    lolToPrepend = newPair(aCtx->jInterp, lolToPrepend, NULL);
    assert(lolToPrepend);
  }

  // find end of lolToPrepend
  CoAlgObj* lolList = lolToPrepend;
  while(asCdr(lolList) && isPair(asCdr(lolList))) {
    lolList = asCdr(lolList);
  }

  // ensure that if lolToPrepend ends in a non-pair we make it a pair
  if (asCdr(lolList) && !isPair(asCdr(lolList))) {
    asCdr(lolList) = newPair(aCtx->jInterp, asCdr(lolList), NULL);
    assert(asCdr(lolList));
  }

  // place existing data stack at end of lolToPrepend
  asCdr(lolList) = aCtx->data;
  aCtx->data     = lolToPrepend;
}
\stopCCode

\startCHeader
extern CoAlgObj* popCtxData(ContextObj* aCtx);

#define popCtxDataInto(aCtx, aVar)                          \
assert(aCtx);                                               \
CoAlgObj* aVar = popCtxData(aCtx);                          \
if (aCtx->tracingOn) {                                      \
  JoyLoLInterp *jInterp = aCtx->jInterp;                    \
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);      \
  printLoL(jInterp, aStrBuf, aVar);                         \
  printf("%s = %s\n", #aVar, getCString(jInterp, aStrBuf)); \
  strBufClose(jInterp, aStrBuf);                            \
}
\stopCHeader

\startCCode
CoAlgObj* popCtxData(ContextObj* aCtx) {
  if (!aCtx) return NULL;
  if (!aCtx->data) return NULL;

  CoAlgObj* poppedLoL = asCar(aCtx->data);
  aCtx->data          = asCdr(aCtx->data);
  return poppedLoL;
}
\stopCCode

\startCHeader
extern void pushCtxProcess(
  ContextObj* aCtx,
  CoAlgObj* lolToPush
);
\stopCHeader

\startCCode
void pushCtxProcess(
  ContextObj* aCtx,
  CoAlgObj* lolToPush
) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->process = newPair(aCtx->jInterp, lolToPush, aCtx->process);
}
\stopCCode

\startCHeader
extern void pushSymbolCtxProcess(
  ContextObj* aCtx,
  Symbol* aSymbol
);
\stopCHeader

\startCCode
void pushSymbolCtxProcess(
  ContextObj* aCtx,
  Symbol* aSymbol
) {
  if (!aCtx) return;
  if (!aSymbol) return;
  assert(aCtx->jInterp);

  CoAlgObj* aSymbolPA =
    getSymbol(aCtx->jInterp, aSymbol);
  if (!aSymbolPA) return;
  aCtx->process = newPair(aCtx->jInterp, aSymbolPA, aCtx->process);
}
\stopCCode

\startCHeader
extern void pushParsedArrayOfStringsCtxProcess(
  ContextObj* aCtx,
  Symbol* someStrings[]
);
\stopCHeader

\startCCode
void pushParsedArrayOfStringsCtxProcess(
  ContextObj* aCtx,
  Symbol* someStrings[]
) {
  if (!aCtx) return;
  if (!someStrings) return;
  TextObj* aText =
    createTextFromArrayOfStrings(aCtx->jInterp, someStrings);
  pushParsedTextCtxProcess(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
extern void pushParsedStringCtxProcess(
  ContextObj* aCtx,
  Symbol* aString
);
\stopCHeader

\startCCode
void pushParsedStringCtxProcess(
  ContextObj* aCtx,
  Symbol* aString
) {
  if (!aCtx) return;
  if (!aString) return;
  TextObj* aText =
    createTextFromString(aCtx->jInterp, aString);
  pushParsedTextCtxProcess(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
void pushParsedTextCtxProcess(
  ContextObj* aCtx,
  TextObj* aText
);
\stopCHeader

\startCCode
void pushParsedTextCtxProcess(
  ContextObj* aCtx,
  TextObj* aText
) {
  if (!aCtx) return;
  if (!aText) return;
  assert(aCtx->jInterp);
  CoAlgObj* aLoL = parseAllSymbols(aText);
  if (!aLoL) return;
  aCtx->process = newPair(aCtx->jInterp, aLoL, aCtx->process);
}
\stopCCode

\startCHeader
extern void prependListCtxProcess(
  ContextObj* aCtx,
  CoAlgObj* lolToPrepend
);
\stopCHeader

\startCCode
void prependListCtxProcess(
  ContextObj* aCtx,
  CoAlgObj* lolToPrepend
) {
  if (!aCtx) return;
  if (!lolToPrepend) return;

  // ensure lolToPrepend is a list
  if (!isPair(lolToPrepend)) {
    lolToPrepend = newPair(aCtx->jInterp, lolToPrepend, NULL);
    assert(lolToPrepend);
  }

  // find end of lolToPrepend
  CoAlgObj* lolList = lolToPrepend;
  while(asCdr(lolList) && isPair(asCdr(lolList))) {
    lolList = asCdr(lolList);
  }

  // ensure that if lolToPrepend ends in a non-pair we make it a pair
  if (asCdr(lolList) && !isPair(asCdr(lolList))) {
    asCdr(lolList) = newPair(aCtx->jInterp, asCdr(lolList), NULL);
    assert(asCdr(lolList));
  }

  // place existing process stack at end of lolToPrepend
  asCdr(lolList)  = aCtx->process;
  aCtx->process   = lolToPrepend;
}
\stopCCode

\startCHeader
CoAlgObj* popCtxProcess(ContextObj* aCtx);
\stopCHeader

\startCCode
CoAlgObj* popCtxProcess(ContextObj* aCtx) {
  if (!aCtx->process) return NULL;

  CoAlgObj* poppedLoL = asCar(aCtx->process);
  aCtx->process       = asCdr(aCtx->process);
  return poppedLoL;
}
\stopCCode

\startCHeader
Boolean extendJoyLoL(
  JoyLoLInterp* jInterp,
  Symbol* definedName,
  CFunction* aFunc
);
\stopCHeader

\startCCode
Boolean extendJoyLoL(
  JoyLoLInterp* jInterp,
  Symbol* definedName,
  CFunction* aFunc
) {
  assert(jInterp);
  DictObj* aSym =
    createSymbol(jInterp, definedName);
  aSym->value =
    (CoAlgObj*)newCFunction(jInterp, aFunc);

  return TRUE;
}
\stopCCode

\startCHeader
Boolean defineJoyLoL(
  JoyLoLInterp* jInterp,
  Symbol* definedName,
  CoAlgObj* aLoL
);
\stopCHeader

\startCCode
Boolean defineJoyLoL(
  JoyLoLInterp* jInterp,
  Symbol* definedName,
  CoAlgObj* aLoL
) {
  assert(jInterp);
  DictObj* aSym =
    createSymbol(jInterp, definedName);
  aSym->value = copyLoL(jInterp, aLoL);

  return TRUE;
}
\stopCCode

\starttyping
\startCHeader
Boolean defineContext(
  JoyLoLInterp* jInterp,
  Symbol* definedName,
  ContextObj* newCtx
);
\stopCHeader

\startCCode
Boolean defineContext(
  JoyLoLInterp* jInterp,
  Symbol* definedName,
  ContextObj* newCtx
) {
  DEBUG(FALSE, "defineContext %p [%s] %p\n",
        jInterp, definedName, newCtx);
  assert(jInterp);
  DictObj* aSym =
    createSymbol(jInterp, definedName);
  aSym->value   = newContext(jInterp, newCtx);

  return TRUE;
}
\stopCCode
\stoptyping