% A ConTeXt document [master document: contexts.tex]

\section[title=Context core code]

\startCHeader
extern void pushCtxData(
  ContextObj* aCtx,
  CoAlgObj* lolToPush
);
\stopCHeader

\startCCode
void pushCtxData(
  ContextObj* aCtx,
  CoAlgObj* lolToPush
) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->data = newPair(aCtx->jInterp, lolToPush, aCtx->data);
}
\stopCCode

\startCHeader
extern void pushNullCtxData(ContextObj* aCtx);
\stopCHeader

\startCCode
void pushNullCtxData(ContextObj* aCtx) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->data = newPair(aCtx->jInterp, NULL, aCtx->data);
}
\stopCCode

\startCHeader
extern void pushSymbolCtxData(
  ContextObj* aCtx,
  Symbol* aSymbol
);
\stopCHeader

\startCCode
void pushSymbolCtxData(
  ContextObj* aCtx,
  Symbol* aSymbol
) {
  if (!aCtx) return;
  if (!aSymbol) return;
  assert(aCtx->jInterp);

  CoAlgObj* aSymbolPA =
    getSymbol(aCtx->jInterp, aSymbol);
  if (!aSymbolPA) return;
  aCtx->data = newPair(aCtx->jInterp, aSymbolPA, aCtx->data);
}
\stopCCode

\startCHeader
extern void pushParsedArrayOfStringsCtxData(
  ContextObj* aCtx,
  Symbol* someStrings[]
);
\stopCHeader

\startCCode
void pushParsedArrayOfStringsCtxData(
  ContextObj* aCtx,
  Symbol* someStrings[]
) {
  if (!aCtx) return;
  if (!someStrings) return;
  TextObj* aText =
    createTextFromArrayOfStrings(aCtx->jInterp, someStrings);
  pushParsedTextCtxData(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
extern void pushParsedStringCtxData(
  ContextObj* aCtx,
  Symbol* aString
);
\stopCHeader

\startCCode
void pushParsedStringCtxData(
  ContextObj* aCtx,
  Symbol* aString
) {
  if (!aCtx) return;
  if (!aString) return;
  TextObj* aText =
    createTextFromString(aCtx->jInterp, aString);
  pushParsedTextCtxData(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
extern void pushParsedTextCtxData(
  ContextObj* aCtx,
  TextObj* aText
);
\stopCHeader

\startCCode
void pushParsedTextCtxData(
  ContextObj* aCtx,
  TextObj* aText
) {
  if (!aCtx) return;
  if (!aText) return;
  assert(aCtx->jInterp);
  CoAlgObj* aLoL = parseAllSymbols(aText);
  if (!aLoL) return;
  aCtx->data = newPair(aCtx->jInterp, aLoL, aCtx->data);
}
\stopCCode

\startCHeader
extern void prependListCtxData(
  ContextObj* aCtx,
  CoAlgObj* lolToPrepend
);
\stopCHeader

\startCCode
void prependListCtxData(
  ContextObj* aCtx,
  CoAlgObj* lolToPrepend
) {
  if (!aCtx) return;
  if (!lolToPrepend) return;

  // ensure lolToPrepend is a list
  if (!isPair(lolToPrepend)) {
    lolToPrepend = newPair(aCtx->jInterp, lolToPrepend, NULL);
    assert(lolToPrepend);
  }

  // find end of lolToPrepend
  CoAlgObj* lolList = lolToPrepend;
  while(asCdr(lolList) && isPair(asCdr(lolList))) {
    lolList = asCdr(lolList);
  }

  // ensure that if lolToPrepend ends in a non-pair we make it a pair
  if (asCdr(lolList) && !isPair(asCdr(lolList))) {
    asCdr(lolList) = newPair(aCtx->jInterp, asCdr(lolList), NULL);
    assert(asCdr(lolList));
  }

  // place existing data stack at end of lolToPrepend
  asCdr(lolList) = aCtx->data;
  aCtx->data     = lolToPrepend;
}
\stopCCode

\startCHeader
extern CoAlgObj* popCtxData(ContextObj* aCtx);
\stopCHeader

\startCCode
CoAlgObj* popCtxData(ContextObj* aCtx) {
  if (!aCtx) return NULL;
  if (!aCtx->data) return NULL;

  CoAlgObj* poppedLoL = asCar(aCtx->data);
  aCtx->data          = asCdr(aCtx->data);
  return poppedLoL;
}
\stopCCode

\starttyping
void pushCtxProcess(ContextObj* aCtx, CoAlgObj* lolToPush) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->process = newPair(aCtx->jInterp, lolToPush, aCtx->process);
}

void pushSymbolCtxProcess(ContextObj* aCtx, const char* aSymbol) {
  if (!aCtx) return;
  if (!aSymbol) return;
  assert(aCtx->jInterp);
  CoAlgebras* coAlgs = aCtx->jInterp;

  assert(coAlgs->symbols);
  assert(coAlgs->symbols->dictionary);

  CoAlgObj* aSymbolPA =
    getSymbol(coAlgs, coAlgs->symbols->dictionary, aSymbol);
  if (!aSymbolPA) return;
  aCtx->process = newPair(coAlgs, aSymbolPA, aCtx->process);
}

void pushParsedArrayOfStringsCtxProcess(ContextObj* aCtx, Symbol* someStrings[]) {
  if (!aCtx) return;
  if (!someStrings) return;
  Text* aText = createTextFromArrayOfStrings(aCtx->jInterp, someStrings);
  pushParsedTextCtxProcess(aCtx, aText);
  freeText(aText);
}

void pushParsedStringCtxProcess(ContextObj* aCtx, Symbol* aString) {
  if (!aCtx) return;
  if (!aString) return;
  Text* aText = createTextFromString(aCtx->jInterp, aString);
  pushParsedTextCtxProcess(aCtx, aText);
  freeText(aText);
}

void pushParsedTextCtxProcess(ContextObj* aCtx, Text* aText) {
  if (!aCtx) return;
  if (!aText) return;
  assert(aCtx->jInterp);
  CoAlgObj* aLoL = parseAllSymbols(aText);
  if (!aLoL) return;
  aCtx->process = newPair(aCtx->jInterp, aLoL, aCtx->process);
}

void prependListCtxProcess(ContextObj* aCtx, CoAlgObj* lolToPrepend) {
  if (!aCtx) return;
  if (!lolToPrepend) return;

  // ensure lolToPrepend is a list
  if (!isPair(lolToPrepend)) {
    lolToPrepend = newPair(aCtx->jInterp, lolToPrepend, NULL);
    assert(lolToPrepend);
  }

  // find end of lolToPrepend
  CoAlgObj* lolList = lolToPrepend;
  while(lolList->pair.cdr && isPair(lolList->pair.cdr)) {
    lolList = lolList->pair.cdr;
  }

  // ensure that if lolToPrepend ends in a non-pair we make it a pair
  if (lolList->pair.cdr && !isPair(lolList->pair.cdr)) {
    lolList->pair.cdr = newPair(aCtx->jInterp, lolList->pair.cdr, NULL);
    assert(lolList->pair.cdr);
  }

  // place existing process stack at end of lolToPrepend
  lolList->pair.cdr  = aCtx->process;
  aCtx->process = lolToPrepend;
}

CoAlgObj* popCtxProcess(ContextObj* aCtx) {
  if (!aCtx->process) return NULL;

  CoAlgObj* poppedLoL = aCtx->process->pair.car;
  aCtx->process       = aCtx->process->pair.cdr;
  return poppedLoL;
}

size_t extendJoyLoL(CoAlgebras* coAlgs,
                    Symbol* definedName,
                    JoyLoLFunction* aFunc) {
  assert(coAlgs);
  assert(coAlgs->symbols);
  assert(coAlgs->symbols->dictionary);
  AVLNode* aSym =
    createSymbol(coAlgs->symbols->dictionary, definedName);
  aSym->value = newJoyLoLFunc(coAlgs, aFunc);

  return TRUE;
}

size_t defineJoyLoL(CoAlgebras* coAlgs,
                    Symbol* definedName,
                    CoAlgObj* aLoL) {
  assert(coAlgs);
  assert(coAlgs->symbols);
  assert(coAlgs->symbols->dictionary);
  AVLNode* aSym =
    createSymbol(coAlgs->symbols->dictionary, definedName);
  aSym->value = copyLoL(coAlgs, aLoL);

  return TRUE;
}

size_t defineContext(CoAlgebras* coAlgs,
                     Symbol* definedName,
                     ContextObj* newCtx) {
  DEBUG(FALSE, "defineContext %p [%s] %p\n",
        coAlgs, definedName, newCtx);
  assert(coAlgs);
  assert(coAlgs->symbols);
  assert(coAlgs->symbols->dictionary);
  AVLNode* aSym =
    createSymbol(coAlgs->symbols->dictionary, definedName);
  aSym->value   = newContext(coAlgs, newCtx);

  return TRUE;
}
\stoptyping