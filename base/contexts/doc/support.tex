% A ConTeXt document [master document: contexts.tex]

\section[title=Supporting JoyLoL words]

\startCHeader
extern Boolean isContext(CoAlgObj *aLoL);
\stopCHeader

\startCCode
Boolean isContext(CoAlgObj *aLoL) {
  if (!aLoL) return FALSE;
  if (aLoL->tag == ContextsTag) return TRUE;
  return FALSE;
}
\stopCCode

\startCCode
static void isContextAP(ContextObj* aCtx) {
  assert(aCtx);
  popCtxDataInto(aCtx, top);
  CoAlgObj* result = NULL;
  if (isContext(top)) result = newBoolean(aCtx->jInterp, TRUE);
  else                result = newBoolean(aCtx->jInterp, FALSE);
  pushCtxData(aCtx, result);
}
\stopCCode

\startCCode
static void showStackOnAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->showStack = TRUE;
}
\stopCCode

\startCCode
static void showStackOffAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->showStack = FALSE;
}
\stopCCode

\startCCode
static void showStackAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->jInterp);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  StringBufferObj *aStrBuf =
    newStringBuffer(jInterp);
  strBufPrintf(jInterp, aStrBuf, "d>>");
  printLoL(jInterp, aStrBuf, aCtx->data);
  strBufPrintf(jInterp, aStrBuf, "\np>>");
  printLoL(jInterp, aStrBuf, aCtx->process);
  strBufPrintf(jInterp, aStrBuf, "\n");
  printf("%s", getCString(jInterp, aStrBuf));
  strBufClose(jInterp, aStrBuf);
}
\stopCCode

\startCCode
static void tracingOnAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->tracingOn = TRUE;
}
\stopCCode

\startCCode
static void tracingOffAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->tracingOn = FALSE;
}
\stopCCode

\startCCode
static void checkingOnAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->checkingOn = TRUE;
}
\stopCCode

\startCCode
static void checkingOffAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->checkingOn = FALSE;
}
\stopCCode

\startCCode
static void definitionsAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->jInterp);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  StringBufferObj *aStrBuf = 
    newStringBuffer(jInterp);
  listDefinitions(jInterp, aStrBuf);
  printf("%s", getCString(jInterp, aStrBuf));
  strBufClose(jInterp, aStrBuf);
}
\stopCCode

\starttyping
static void showLoadExtensionsAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->coAlgebras);
  assert(aCtx->coAlgebras->contexts);
  Loader* loader = aCtx->coAlgebras->contexts->loader;
  assert(loader);
  CoAlgObj* extensionList = loader->loadExtensions;
  while(extensionList) {
    CoAlgObj* anExtension = extensionList->pair.car;
    if (isSymbol(anExtension)) printf("%s\n", anExtension->symbol);
    extensionList = extensionList->pair.cdr;
  }
}

static void showLoadPathsAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->coAlgebras);
  assert(aCtx->coAlgebras->contexts);
  Loader* loader = aCtx->coAlgebras->contexts->loader;
  assert(loader);
  CoAlgObj* pathList = loader->loadPaths;
  while(pathList) {
    CoAlgObj* aPath = pathList->pair.car;
    if (isSymbol(aPath)) printf("%s\n", aPath->symbol);
    pathList = pathList->pair.cdr;
  }
}

static void showLoadFilesAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->coAlgebras);
  assert(aCtx->coAlgebras->contexts);
  Loader* loader = aCtx->coAlgebras->contexts->loader;
  assert(loader);
  CoAlgObj* fileList = loader->loadFiles;
  while(fileList) {
    CoAlgObj* aFile = fileList->pair.car;
    if (isSymbol(aFile)) printf("%s\n", aFile->symbol);
    fileList = fileList->pair.cdr;
  }
}

static void loadExtensionAP(ContextObj* aCtx) {
  assert(aCtx);
  popCtxDataInto(aCtx, top);
  if (!isSymbol(top)) return;
  pushLoadExtension(aCtx->coAlgebras, top->symbol);
}

static void loadPathAP(ContextObj* aCtx) {
  assert(aCtx);
  popCtxDataInto(aCtx, top);
  if (!isSymbol(top)) return;
  pushLoadPath(aCtx->coAlgebras, top->symbol);
}

static void loadFileAP(ContextObj* aCtx) {
  DEBUG(FALSE, "loadFileAP > %p\n", aCtx);
  assert(aCtx);
  popCtxDataInto(aCtx, top);
  int oldVerboseFlag = aCtx->verbose;
  aCtx->verbose = aCtx->showStack;
  loadFiles(aCtx, top);
  aCtx->verbose = oldVerboseFlag;
  DEBUG(FALSE, "loadFileAP < %p\n", aCtx);
}

static void lispLoadFileAP(ContextObj* aCtx) {
  DEBUG(FALSE, "listLoadFileAP > %p\n", aCtx);
  pushSymbolCtxProcess(aCtx, "lispInterpret");
  loadFileAP(aCtx);
  DEBUG(FALSE, "listLoadFileAP < %p\n", aCtx);
}
\stoptyping

\startCCode
static void commentAP(ContextObj* aCtx) {
  popCtxDataInto(aCtx, top);
}
\stopCCode

\startCHeader
extern void initContextsAPSupport(JoyLoLInterp *jInterp);
\stopCHeader

\startCCode
void initContextsAPSupport(JoyLoLInterp *jInterp) {
  extendJoyLoL(jInterp, "isContext",           isContextAP);
  extendJoyLoL(jInterp, "definitions",         definitionsAP);
//  extendJoyLoL(jInterp, "loadExtension",       loadExtensionAP);
//  extendJoyLoL(jInterp, "loadPath",            loadPathAP);
//  extendJoyLoL(jInterp, "load",                loadFileAP);
//  extendJoyLoL(jInterp, "lispLoad",            lispLoadFileAP);
  extendJoyLoL(jInterp, "comment",             commentAP);
  extendJoyLoL(jInterp, "---",                 commentAP);
//  extendJoyLoL(jInterp, "showLoadExtensions",  showLoadExtensionsAP);
//  extendJoyLoL(jInterp, "showLoadPaths",       showLoadPathsAP);
//  extendJoyLoL(jInterp, "showLoadFiles",       showLoadFilesAP);
  extendJoyLoL(jInterp, "showStack",           showStackAP);
  extendJoyLoL(jInterp, "showStackOn",         showStackOnAP);
  extendJoyLoL(jInterp, "showStackOff",        showStackOffAP);
  extendJoyLoL(jInterp, "tracingOn",           tracingOnAP);
  extendJoyLoL(jInterp, "tracingOff",          tracingOffAP);
  extendJoyLoL(jInterp, "checkingOn",          checkingOnAP);
  extendJoyLoL(jInterp, "checkingOff",         checkingOffAP);
}
\stopCCode