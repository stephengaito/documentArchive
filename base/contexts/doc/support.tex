% A ConTeXt document [master document: contexts.tex]

\section[title=Supporting JoyLoL words]

\startCHeader
#define isContext(aLoL)           \
  (                               \
    (                             \
      (aLoL) &&                   \
      (aLoL->tag == ContextsTag)  \
    ) ?                           \
      TRUE :                      \
      FALSE                       \
  )
\stopCHeader

\startCCode
static void isContextAP(ContextObj* aCtx) {
  assert(aCtx);
  popCtxDataInto(aCtx, top);
  JObj* result = NULL;
  if (isContext(top)) result = newBoolean(aCtx->jInterp, TRUE);
  else                result = newBoolean(aCtx->jInterp, FALSE);
  pushCtxData(aCtx, result);
}
\stopCCode

\startCCode
static void showStackOnAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->showStack = TRUE;
}
\stopCCode

\startCCode
static void showStackOffAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->showStack = FALSE;
}
\stopCCode

\startCCode
static void showStackAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->jInterp);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  StringBufferObj *aStrBuf =
    newStringBuffer(jInterp);
  strBufPrintf(jInterp, aStrBuf, "d>>");
  printLoL(jInterp, aStrBuf, aCtx->data);
  strBufPrintf(jInterp, aStrBuf, "\np>>");
  printLoL(jInterp, aStrBuf, aCtx->process);
  strBufPrintf(jInterp, aStrBuf, "\n");
  jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));
  strBufClose(jInterp, aStrBuf);
}
\stopCCode

\startCCode
static void tracingOnAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->tracingOn = TRUE;
}
\stopCCode

\startCCode
static void tracingOffAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->tracingOn = FALSE;
}
\stopCCode

\startCCode
static void debugOnAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->jInterp);
  aCtx->jInterp->debug = TRUE;
}
\stopCCode

\startCCode
static void debugOffAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->jInterp);
  aCtx->jInterp->debug = FALSE;
}
\stopCCode

\startCCode
static void verboseOnAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->jInterp);
  aCtx->verbose = TRUE;
  aCtx->jInterp->verbose = TRUE;
}
\stopCCode

\startCCode
static void verboseOffAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->jInterp);
  aCtx->verbose = FALSE;
  aCtx->jInterp->verbose = FALSE;
}
\stopCCode

\startCCode
static void checkingOnAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->checkingOn = TRUE;
}
\stopCCode

\startCCode
static void checkingOffAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->checkingOn = FALSE;
}
\stopCCode

\startCCode
static void definitionsAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->jInterp);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  listDefinitions(aCtx->dict, aStrBuf);
  jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));
  strBufClose(jInterp, aStrBuf);
}
\stopCCode

\startCCode
static void showLoadExtensionsAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  LoaderObj* loader = jInterp->loader;
  assert(loader);
  StringBufferObj *aStrBuf =
    newStringBuffer(jInterp);
  listLoadExtensions(loader, aStrBuf);
  jInterp->writeStdOut(jInterp,
    getCString(jInterp, aStrBuf)
  );
  strBufClose(jInterp, aStrBuf);
}
\stopCCode

\startCCode
static void showLoadPathsAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  LoaderObj* loader = jInterp->loader;
  assert(loader);
  StringBufferObj *aStrBuf =
    newStringBuffer(jInterp);
  listLoadPaths(loader, aStrBuf);
  jInterp->writeStdOut(jInterp,
    getCString(jInterp, aStrBuf)
  );
  strBufClose(jInterp, aStrBuf);  
}
\stopCCode

\startCCode
static void loadExtensionAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  LoaderObj *loader = jInterp->loader;
  assert(loader);
  popCtxDataInto(aCtx, top);
  if (!isSymbol(top)) {
    raiseException(aCtx,
      "loadExtension requires a symbol as top");
    return;
  }
  pushLoadExtension(loader, asSymbol(top));
}
\stopCCode

\startCCode
static void loadPathAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  LoaderObj *loader = jInterp->loader;
  assert(loader);
  popCtxDataInto(aCtx, top);
  if (!isSymbol(top)) {
    raiseException(aCtx,
      "loadPath requires a symbol as top");
    return;
  }
  pushLoadPath(loader, asSymbol(top));
}
\stopCCode

\startCCode
static void loadFileAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->jInterp);
  DEBUG(aCtx->jInterp, "loadFileAP > %p\n", aCtx);
  assert(aCtx);
  popCtxDataInto(aCtx, top);
  if (!isSymbol(top)) {
    raiseException(aCtx,
      "loadFile requires a symbol as top");
    return;
  }
  
  int oldVerboseFlag = aCtx->verbose;
  aCtx->verbose = aCtx->showStack;
  loadAFile(aCtx, asSymbol(top));
  aCtx->verbose = oldVerboseFlag;
  DEBUG(aCtx->jInterp, "loadFileAP < %p\n", aCtx);
}
\stopCCode

\startCCode
static void lispLoadFileAP(ContextObj* aCtx) {
  assert(aCtx);
  assert(aCtx->jInterp);
  DEBUG(aCtx->jInterp, "listLoadFileAP > %p\n", aCtx);
  pushSymbolCtxProcess(aCtx, "lispInterpret");
  loadFileAP(aCtx);
  DEBUG(aCtx->jInterp, "listLoadFileAP < %p\n", aCtx);
}
\stopCCode

\setCHeaderStream{private}
\startCHeader
extern void initContextsAPSupport(JoyLoLInterp *jInterp);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void initContextsAPSupport(JoyLoLInterp *jInterp) {
  extendJoyLoL(jInterp, "isContext",           isContextAP);
  extendJoyLoL(jInterp, "definitions",         definitionsAP);
  extendJoyLoL(jInterp, "loadExtension",       loadExtensionAP);
  extendJoyLoL(jInterp, "loadPath",            loadPathAP);
  extendJoyLoL(jInterp, "load",                loadFileAP);
  extendJoyLoL(jInterp, "lispLoad",            lispLoadFileAP);
  extendJoyLoL(jInterp, "showLoadExtensions",  showLoadExtensionsAP);
  extendJoyLoL(jInterp, "showLoadPaths",       showLoadPathsAP);
  extendJoyLoL(jInterp, "showStack",           showStackAP);
  extendJoyLoL(jInterp, "showStackOn",         showStackOnAP);
  extendJoyLoL(jInterp, "showStackOff",        showStackOffAP);
  extendJoyLoL(jInterp, "tracingOn",           tracingOnAP);
  extendJoyLoL(jInterp, "tracingOff",          tracingOffAP);
  extendJoyLoL(jInterp, "verboseOn",           verboseOnAP);
  extendJoyLoL(jInterp, "verboseOff",          verboseOffAP);
  extendJoyLoL(jInterp, "debugOn",             debugOnAP);
  extendJoyLoL(jInterp, "debugOff",            debugOffAP);
  extendJoyLoL(jInterp, "checkingOn",          checkingOnAP);
  extendJoyLoL(jInterp, "checkingOff",         checkingOffAP);
}
\stopCCode