% A ConTeXt document [master document: contexts.tex]

\section[title=Context control code]

\subsection[title=Operators]

\startCCode
static void failAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->data    = NULL;
  aCtx->process = NULL;
}
\stopCCode

\starttyping

\startWord[fail]

\preDataStack
  (
    dataStack
  )
\preProcessStack
  (
    processStack
  )
\preConditions
\stopPreStack

\postDataStack
  ( )
\postProcessStack
  ( )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\subsection[title=Combinators]

\startCCode
static void interpretAP(ContextObj* aCtx) {
  popCtxDataInto(aCtx, top);
  prependListCtxProcess(aCtx, top);
}
\stopCCode

\starttyping

\startWord[interpret]

\preDataStack
  (
    top : list
    dataStack
  )
\preProcessStack
  (
    processStack
  )
\preConditions
  (top isFinite)
\stopPreStack

\postDataStack
  (
    dataStack
  )
\postProcessStack
  (
    top (prepended)
    processStack
  )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\startCCode
static void forAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  popCtxProcessInto(aCtx, nextCommand);
  if (symbolIs(jInterp, nextCommand, "forDone")) {
    // this for loop is done
    DEBUG(jInterp, "forAP DONE%s\n", "");
  } else {
    DEBUG(jInterp, "forAP continue%s\n", "");
    pushSymbolCtxProcess(aCtx, "for");
    prependListCtxProcess(aCtx, nextCommand);
  }
}
\stopCCode

\starttyping

\startWord[for]
\preDataStack
  (
    dataStack
  )
\preProcessStack
  (
    nextCommand : aType
    processStack
  )
\preConditions
  (nextCommand isFinite)  >> if nextCommand == 'forDone' ok
                             if nextCommand isList then nextCommand isFinite
                             else ok <<
\stopPreStack

\postDataStack
  (
    dataStack
  )
\postProcessStack
  (nextCommand 'forDone' =symbol) -> (
    processStack
  )
  OR
  (else) -> (
    nextCommand (prepended)
    'for' : Symbol
    processStack
  )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\startCCode
static void forDoneAP(ContextObj* aCtx) {
  // ignore
}
\stopCCode

\starttyping

\startWord[forDone]

\preDataStack
  ( dataStack )
\preProcessStack
  ( processStack )
\preConditions
\stopPreStack

\postDataStack
  ( dataStack )
\postProcessStack
  ( processStack )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\startCCode
static void lispInterpretAP(ContextObj* aCtx) {
  popCtxDataInto(aCtx, top);
  if (!isPair(top)) {
    raiseException(aCtx,
      "listInterpret expected a pair as top");
    return;
  }
  JObj* operationName = asCar(top);
  JObj* operationBody = asCdr(top);
  pushCtxProcess(aCtx, operationName);
  pushCtxProcess(aCtx, operationBody);
}
\stopCCode

\starttyping

\startWord[lispInterpret]

\preDataStack
  (
    (
      operationName : list
      operationBody
    )
    dataStack 
  )
\preProcessStack
  (
    processStack
  )
\preConditions
\stopPreStack

\postDataStack
  ( dataStack )
\postProcessStack
  (
    operationBody : list <<< PREPEND?
    operationName : aType
    processStack
  )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\startCCode
static void lispForAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  popCtxProcessInto(aCtx, nextCommand);
  if (symbolIs(jInterp, nextCommand, "forDone")) {
    // this lisp for loop is done
    DEBUG(jInterp, "lispForAP DONE%s\n", "");
  } else {
    DEBUG(jInterp, "lispForAP continue%s\n", "");
    if (!isPair(nextCommand)) {
      raiseException(aCtx,
        "listFor (continue) expected a pair as nextCommand");
      return;
    }
    JObj* operationName = asCar(nextCommand);
    JObj* operationBody = asCdr(nextCommand);
    pushSymbolCtxProcess(aCtx, "lispFor");
    pushCtxProcess(aCtx, operationName);
    pushCtxProcess(aCtx, operationBody);
  }
}
\stopCCode

\startCCode
static void doneAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->process = NULL;
}
\stopCCode

\startCCode
static void clearContextAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->data    = NULL;
  aCtx->process = NULL;
}
\stopCCode

\startCCode
static void tryAP(ContextObj* aCtx) {
  popCtxDataInto(aCtx, handlerExp);
  popCtxDataInto(aCtx, tryExp);
  pushCtxProcess(aCtx, handlerExp);
  pushSymbolCtxProcess(aCtx, "tryHandler");
  prependListCtxProcess(aCtx, tryExp);
}
\stopCCode

\startCCode
static void raiseAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->exceptionRaised = TRUE;
  popCtxDataInto(aCtx, raiseExp);
  pushSymbolCtxProcess(aCtx, "findFirstTryHandler");
  prependListCtxProcess(aCtx, raiseExp);
}
\stopCCode

\startCCode
static void raiseIfFalseAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  popCtxDataInto(aCtx, condition);
  popCtxProcessInto(aCtx, raiseExp);
  if (isFalse(condition)) {
    pushSymbolCtxProcess(aCtx, "findFirstTryHandler");
    prependListCtxProcess(aCtx, raiseExp);
  }
}
\stopCCode

\startCCode
static void findFirstTryHandlerAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  if (aCtx->process) {
    popCtxProcessInto(aCtx, aCommand);
    if (symbolIs(jInterp, aCommand, "tryHandler")) {
      aCtx->exceptionRaised = FALSE;
      popCtxProcessInto(aCtx, handlerExp);
      prependListCtxProcess(aCtx, handlerExp);
      return;
    }
    pushSymbolCtxProcess(aCtx, "findFirstTryHandler");
  } else {
    if (aCtx->parent) {
      ContextObj* parentCtx = newContext(
        jInterp,
        "raiseFindFirstTryHander",
        aCtx->parent,
        aCtx->dict,
        NULL,
        NULL
      );
      pushSymbolCtxProcess(aCtx->parent, "raise");
      pushCtxProcess(aCtx, (JObj*)parentCtx);
    }
  }
}
\stopCCode

\startCCode
static void tryHandlerAP(ContextObj* aCtx) {
  popCtxProcessInto(aCtx, handlerExp);
}
\stopCCode

\startCHeader
typedef void (RaiseException)(
  ContextObj *aCtx,
  Symbol     *message
);

#define raiseException(aCtx, message)       \
  (                                         \
    assert(getContextsClass(aCtx->jInterp)  \
      ->raiseExceptionFunc),                \
    (getContextsClass(aCtx->jInterp)        \
      ->raiseExceptionFunc(aCtx, message))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
void raiseExceptionImpl(
  ContextObj *aCtx,
  Symbol     *message
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void raiseExceptionImpl(
  ContextObj *aCtx,
  Symbol     *message
) {
  assert(aCtx);
  pushSymbolCtxData(aCtx, message);
  pushSymbolCtxProcess(aCtx, "raise");
}
\stopCCode

\startCHeader
typedef Boolean (ReportException)(
  ContextObj* aCtx
);

#define reportException(aCtx)               \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->reportExceptionFunc),               \
    (getContextsClass(aCtx->jInterp)        \
      ->reportExceptionFunc(aCtx))          \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern Boolean reportExceptionImpl(
  ContextObj* aCtx
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean reportExceptionImpl(
  ContextObj* aCtx
) {
  assert(aCtx);
  if (!aCtx->exceptionRaised) return FALSE;
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  StringBufferObj *aStrBuf = 
    newStringBuffer(jInterp);
  strBufPrintf(jInterp, aStrBuf, "\nUNHANDLED EXCEPTION:\n");
  printLoL(jInterp, aStrBuf, aCtx->data);
  strBufPrintf(jInterp, aStrBuf, "\n");
  jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));
  strBufClose(jInterp, aStrBuf);
  aCtx->exceptionRaised = FALSE;
  return TRUE;
}
\stopCCode

\subsection[title=Support]

\startCCode
static void defineAP(ContextObj* aCtx) {
  assert(aCtx);
  popCtxDataInto(aCtx, name);
  popCtxDataInto(aCtx, naming);
  popCtxDataInto(aCtx, definition);
  if (!isSymbol(name)) {
    raiseException(aCtx,
      "define requires a symbol as top");
    return;
  }
  if (!isDictionary(naming)) {
    raiseException(aCtx,
      "define requires a dictionary as second");
    return;
  }
  defineJoyLoLIn(
    aCtx->jInterp,
    (DictObj*)naming,
    asSymbol(name),
    definition
  );
}
\stopCCode

\startCCode
static void defineContextAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  
  popCtxDataInto(aCtx, contextName);
  popCtxDataInto(aCtx, contextNaming);
  popCtxDataInto(aCtx, contextNamingScope);
  popCtxDataInto(aCtx, contextData);
  popCtxDataInto(aCtx, contextProcess);
  if (!isSymbol(contextName)) {
    raiseException(aCtx,
      "defineContext required a symbol as top");
    return;
  }
  if (!isDictionary(contextNaming)) {
    raiseException(aCtx,
      "defineContext required a dictionary as second");
    return;
  }
  if (!isDictionary(contextNamingScope)) {
    raiseException(aCtx,
      "defineContext required a dictionary as third");
    return;
  }
  ContextObj* newCtx = newContext(
    jInterp,
    asSymbol(contextName),
    aCtx,
    (DictObj*)contextNamingScope,
    contextData,
    contextProcess
  );
  assert(newCtx);
  defineContextIn(
    jInterp,
    (DictObj*)contextNaming,
    asSymbol(contextName),
    newCtx
  );
}
\stopCCode

\startCCode
static void newContextAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);

  popCtxDataInto(aCtx, contextNaming);
  popCtxDataInto(aCtx, contextData);
  popCtxDataInto(aCtx, contextProcess);
  if (!isDictionary(contextNaming)) {
    raiseException(aCtx,
      "newContext requires a dictionary as top");
    return;
  }
  ContextObj* newCtx = newContext(
    jInterp,
    "anonymous",
    aCtx,
    (DictObj*)contextNaming,
    contextData,
    contextProcess
  );
  assert(newCtx);
  pushCtxData(aCtx, (JObj*)newCtx);
}
\stopCCode

\startCCode
static void defineNamingAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  
  popCtxDataInto(aCtx, dictName);
  popCtxDataInto(aCtx, dictNaming);
  popCtxDataInto(aCtx, dictNamingScope);
  if (!isSymbol(dictName)) {
    raiseException(aCtx,
      "defineNaming required a symbol as top");
    return;
  }
  if (!isDictionary(dictNaming)) {
    raiseException(aCtx,
      "defineNaming requires a dictionary as second");
    return;
  }
  if (!isDictionary(dictNamingScope)) {
    raiseException(aCtx,
      "defineNaming requires a dictionary as third");
    return;
  }
  DictObj* newDict =
    newDictionary(
      jInterp,
      (DictObj*)dictNamingScope
    );
  assert(newDict);
  defineNamingIn(
    jInterp,
    (DictObj*)dictNaming,
    asSymbol(dictName),
    newDict
  );
}
\stopCCode

\startCCode
static void newNamingAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);

  popCtxDataInto(aCtx, dictNamingScope);
  if (!isDictionary(dictNamingScope)) {
    raiseException(aCtx,
      "defineNaming requires a dictionary as top");
    return;
  }

  DictObj* newDict =
    newDictionary(
      jInterp,
      (DictObj*)dictNamingScope
    );
  assert(newDict);
  pushCtxData(aCtx, (JObj*)newDict);
}
\stopCCode

\startCCode
void initContextsAPControl(JoyLoLInterp *jInterp) {
  extendJoyLoLInRoot(jInterp, "fail",                failAP);
  extendJoyLoLInRoot(jInterp, "i",                   interpretAP);
  extendJoyLoLInRoot(jInterp, "interpret",           interpretAP);
  extendJoyLoLInRoot(jInterp, "for",                 forAP);
  extendJoyLoLInRoot(jInterp, "forDone",             forDoneAP);
  extendJoyLoLInRoot(jInterp, "lispInterpret",       lispInterpretAP);
  extendJoyLoLInRoot(jInterp, "lispFor",             lispForAP);
  extendJoyLoLInRoot(jInterp, "define",              defineAP);
  extendJoyLoLInRoot(jInterp, "defineContext",       defineContextAP);
  extendJoyLoLInRoot(jInterp, "thisContext",         newContextAP);
  extendJoyLoLInRoot(jInterp, "newContext",          newContextAP);
  extendJoyLoLInRoot(jInterp, "defineNaming",        defineNamingAP);
  extendJoyLoLInRoot(jInterp, "newNaming",           newNamingAP);
  extendJoyLoLInRoot(jInterp, "done",                doneAP);
  extendJoyLoLInRoot(jInterp, "clear",               clearContextAP);
  extendJoyLoLInRoot(jInterp, "try",                 tryAP);
  extendJoyLoLInRoot(jInterp, "raise",               raiseAP);
  extendJoyLoLInRoot(jInterp, "raiseIfFalse",        raiseIfFalseAP);
  extendJoyLoLInRoot(jInterp, "findFirstTryHandler", findFirstTryHandlerAP);
  extendJoyLoLInRoot(jInterp, "tryHandler",          tryHandlerAP);
}
\stopCCode