% A ConTeXt document [master document: contexts.tex]

\section[title=Context control code]

\subsection[title=Operators]

\startCCode
static void failAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->data    = NULL;
  aCtx->process = NULL;
}
\stopCCode

\starttyping

\startWord[fail]

\preDataStack
  (
    dataStack
  )
\preProcessStack
  (
    processStack
  )
\preConditions
\stopPreStack

\postDataStack
  ( )
\postProcessStack
  ( )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\subsection[title=Combinators]

\startCCode
static void prependAP(ContextObj* aCtx) {
  popCtxDataIntoImpl(aCtx, top);
  popCtxDataIntoImpl(aCtx, second);
  JObj* result = concatLists(aCtx->jInterp, top, second);
  pushCtxDataImpl(aCtx, result);
}
\stopCCode

\startCCode
static void appendAP(ContextObj* aCtx) {
  popCtxDataIntoImpl(aCtx, top);
  popCtxDataIntoImpl(aCtx, second);
  JObj* result = concatLists(aCtx->jInterp, second, top);
  pushCtxDataImpl(aCtx, result);
}
\stopCCode

\startCCode
static void extractAP(ContextObj* aCtx) {
  popCtxDataIntoImpl(aCtx, top);
  prependListCtxData(aCtx, top);
}
\stopCCode

\starttyping

\startWord[extract]

\preDataStack
  (
    top : list
    dataStack
  )
\preProcessStack
  (
    processStack
  )
\preConditions
  (top isFinite)
\stopPreStack

\postDataStack
  (
    top (prepended)
    dataStack
  )
\postProcessStack
  (
    processStack
  )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\startCCode
static void interpretAP(ContextObj* aCtx) {
  popCtxDataIntoImpl(aCtx, top);
  prependListCtxProcess(aCtx, top);
}
\stopCCode

\starttyping

\startWord[interpret]

\preDataStack
  (
    top : list
    dataStack
  )
\preProcessStack
  (
    processStack
  )
\preConditions
  (top isFinite)
\stopPreStack

\postDataStack
  (
    dataStack
  )
\postProcessStack
  (
    top (prepended)
    processStack
  )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\startJoyLoLWord[ifte]

\startCCode
static void ifteAP(ContextObj* aCtx) {
  popCtxDataIntoImpl(aCtx, topElse);
  popCtxDataIntoImpl(aCtx, topThen);
  popCtxDataIntoImpl(aCtx, topIf);
  pushCtxProcessImpl(aCtx, topElse); // save for later
  pushCtxProcessImpl(aCtx, topThen); // save for later
  pushSymbolCtxProcess(aCtx, "ifteCont");
  prependListCtxProcess(aCtx, topIf); // execute the if condition
}
\stopCCode

\startImplementation[ansic]
  (
    (popData topElse)
    (popData topThen)
    (popData topIf)
    (pushProcess topElse)
    (pushProcess topThen)
    (pushSymbolProcess ifteCont)
    (prependProcess topIf)
  )
\stopImplementation

\startRule[ifte]
\preDataStack
  (
    topElse : list
    topThen : list
    topIf   : list
    dataStack
  )
\preProcessStack
  (
    processStack
  )
\preConditions
  (topIf isFinite)
\postDataStack
  (
    dataStack
  )
\postProcessStack
  (
    topIf (prepended)
    'ifteCont' : Symbol
    topThen    : list
    topElse    : list
    processStack
  )
\postConditions
\stopRule

\stopJoyLoLWord

\startJoyLoLWord[ifteCont]

\startCCode
static void ifteContAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  popCtxDataIntoImpl(aCtx, topIf);
  popCtxProcessIntoImpl(aCtx, topThen);
  popCtxProcessIntoImpl(aCtx, topElse);
  if (isTrue(topIf)) {
    prependListCtxProcess(aCtx, topThen);
  } else {
    prependListCtxProcess(aCtx, topElse);
  }
}
\stopCCode

\startImplementation[ansic]
  (
    (popData topIf)
    (popProcess topThen)
    (popProcess topElse)
    (doIfte topIf 
      (prependProcess topThen)
      (prependProcess topElse)
    )
  )
\stopImplementation

\startRule[ifteCont-true]
\preDataStack
  (
    topIf : Boolean
    dataStack
  )
\preProcessStack
  (
    topThen : list
    topElse : list
    processStack
  )
\preConditions
  (topThen isFinite)
\postDataStack
  (
    dataStack
  )
\postProcessStack
  (
    topThen (prepended)
    processStack
  )
\postConditions
\stopRule

\startRule[ifteCont-false]
\preDataStack
  (
    topIf : Boolean
    dataStack
  )
\preProcessStack
  (
    topThen : list
    topElse : list
    processStack
  )
\preConditions
  (topElse isFinite)
\postDataStack
  (
    dataStack
  )
\postProcessStack
  (
    topElse (prepended)
    processStack
  )
\postConditions
\stopRule

\stopJoyLoLWord

\startCCode
static void forAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  popCtxProcessIntoImpl(aCtx, nextCommand);
  if (symbolIs(jInterp, nextCommand, "forDone")) {
    // this for loop is done
    DEBUG(jInterp, "forAP DONE%s\n", "");
  } else {
    DEBUG(jInterp, "forAP continue%s\n", "");
    pushSymbolCtxProcess(aCtx, "for");
    prependListCtxProcess(aCtx, nextCommand);
  }
}
\stopCCode

\starttyping

\startWord[for]
\preDataStack
  (
    dataStack
  )
\preProcessStack
  (
    nextCommand : aType
    processStack
  )
\preConditions
  (nextCommand isFinite)  >> if nextCommand == 'forDone' ok
                             if nextCommand isList then nextCommand isFinite
                             else ok <<
\stopPreStack

\postDataStack
  (
    dataStack
  )
\postProcessStack
  (nextCommand 'forDone' =symbol) -> (
    processStack
  )
  OR
  (else) -> (
    nextCommand (prepended)
    'for' : Symbol
    processStack
  )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\startCCode
static void forDoneAP(ContextObj* aCtx) {
  // ignore
}
\stopCCode

\starttyping

\startWord[forDone]

\preDataStack
  ( dataStack )
\preProcessStack
  ( processStack )
\preConditions
\stopPreStack

\postDataStack
  ( dataStack )
\postProcessStack
  ( processStack )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\startCCode
static void lispInterpretAP(ContextObj* aCtx) {
  popCtxDataIntoImpl(aCtx, top);
  if (!isPair(top)) {
    raiseException(aCtx,
      "listInterpret expected a pair as top");
    return;
  }
  JObj* operationName = asCar(top);
  JObj* operationBody = asCdr(top);
  pushCtxProcessImpl(aCtx, operationName);
  pushCtxProcessImpl(aCtx, operationBody);
}
\stopCCode

\starttyping

\startWord[lispInterpret]

\preDataStack
  (
    (
      operationName : list
      operationBody
    )
    dataStack 
  )
\preProcessStack
  (
    processStack
  )
\preConditions
\stopPreStack

\postDataStack
  ( dataStack )
\postProcessStack
  (
    operationBody : list <<< PREPEND?
    operationName : aType
    processStack
  )
\postConditions
\stopPostStack

\stopWord

\stoptyping

\startCCode
static void lispForAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  popCtxProcessIntoImpl(aCtx, nextCommand);
  if (symbolIs(jInterp, nextCommand, "forDone")) {
    // this lisp for loop is done
    DEBUG(jInterp, "lispForAP DONE%s\n", "");
  } else {
    DEBUG(jInterp, "lispForAP continue%s\n", "");
    if (!isPair(nextCommand)) {
      raiseException(aCtx,
        "listFor (continue) expected a pair as nextCommand");
      return;
    }
    JObj* operationName = asCar(nextCommand);
    JObj* operationBody = asCdr(nextCommand);
    pushSymbolCtxProcess(aCtx, "lispFor");
    pushCtxProcessImpl(aCtx, operationName);
    pushCtxProcessImpl(aCtx, operationBody);
  }
}
\stopCCode

\startCCode
static void doneAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->process = NULL;
}
\stopCCode

\startCCode
static void clearContextAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->data    = NULL;
  aCtx->process = NULL;
}
\stopCCode

\startCCode
static void tryAP(ContextObj* aCtx) {
  popCtxDataIntoImpl(aCtx, handlerExp);
  popCtxDataIntoImpl(aCtx, tryExp);
  pushCtxProcessImpl(aCtx, handlerExp);
  pushSymbolCtxProcess(aCtx, "tryHandler");
  prependListCtxProcess(aCtx, tryExp);
}
\stopCCode

\startCCode
static void raiseAP(ContextObj* aCtx) {
  assert(aCtx);
  aCtx->exceptionRaised = TRUE;
  popCtxDataIntoImpl(aCtx, raiseExp);
  pushSymbolCtxProcess(aCtx, "findFirstTryHandler");
  prependListCtxProcess(aCtx, raiseExp);
}
\stopCCode

\startCCode
static void raiseIfFalseAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  popCtxDataIntoImpl(aCtx, condition);
  popCtxProcessIntoImpl(aCtx, raiseExp);
  if (isFalse(condition)) {
    pushSymbolCtxProcess(aCtx, "findFirstTryHandler");
    prependListCtxProcess(aCtx, raiseExp);
  }
}
\stopCCode

\startCCode
static void findFirstTryHandlerAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  if (aCtx->process) {
    popCtxProcessIntoImpl(aCtx, aCommand);
    if (symbolIs(jInterp, aCommand, "tryHandler")) {
      aCtx->exceptionRaised = FALSE;
      popCtxProcessIntoImpl(aCtx, handlerExp);
      prependListCtxProcess(aCtx, handlerExp);
      return;
    }
    pushSymbolCtxProcess(aCtx, "findFirstTryHandler");
  } else {
    if (aCtx->parent) {
      ContextObj* parentCtx = newContext(
        jInterp,
        "raiseFindFirstTryHander",
        aCtx->parent,
        aCtx->dict,
        NULL,
        NULL
      );
      pushSymbolCtxProcess(aCtx->parent, "raise");
      pushCtxProcessImpl(aCtx, (JObj*)parentCtx);
    }
  }
}
\stopCCode

\startCCode
static void tryHandlerAP(ContextObj* aCtx) {
  popCtxProcessIntoImpl(aCtx, handlerExp);
}
\stopCCode

\startCHeader
typedef void (RaiseException)(
  ContextObj *aCtx,
  Symbol     *message
);

#define raiseException(aCtx, message)       \
  (                                         \
    assert(getContextsClass(aCtx->jInterp)  \
      ->raiseExceptionFunc),                \
    (getContextsClass(aCtx->jInterp)        \
      ->raiseExceptionFunc(aCtx, message))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
void raiseExceptionImpl(
  ContextObj *aCtx,
  Symbol     *message
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void raiseExceptionImpl(
  ContextObj *aCtx,
  Symbol     *message
) {
  assert(aCtx);
  pushSymbolCtxData(aCtx, message);
  pushSymbolCtxProcess(aCtx, "raise");
}
\stopCCode

\startCHeader
typedef Boolean (ReportException)(
  ContextObj* aCtx
);

#define reportException(aCtx)               \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->reportExceptionFunc),               \
    (getContextsClass(aCtx->jInterp)        \
      ->reportExceptionFunc(aCtx))          \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern Boolean reportExceptionImpl(
  ContextObj* aCtx
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean reportExceptionImpl(
  ContextObj* aCtx
) {
  assert(aCtx);
  if (!aCtx->exceptionRaised) return FALSE;
  popCtxDataIntoImpl(aCtx, exceptionMsg);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  StringBufferObj *aStrBuf = 
    newStringBuffer(jInterp);
  strBufPrintf(jInterp, aStrBuf, "\nUNHANDLED EXCEPTION:\n");
  printLoL(jInterp, aStrBuf, exceptionMsg);
  strBufPrintf(jInterp, aStrBuf, "\n");
  jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));
  strBufClose(jInterp, aStrBuf);
  aCtx->exceptionRaised = FALSE;
  return TRUE;
}
\stopCCode

\subsection[title=Support]

\startCCode
static void defineAP(ContextObj* aCtx) {
  assert(aCtx);
  popCtxDataIntoImpl(aCtx, name);
  popCtxDataIntoImpl(aCtx, naming);
  popCtxDataIntoImpl(aCtx, definition);
  if (!isSymbol(name)) {
    raiseException(aCtx,
      "define requires a symbol as top");
    return;
  }
  if (!isDictionary(naming)) {
    raiseException(aCtx,
      "define requires a dictionary as second");
    return;
  }
  defineJoyLoLIn(
    aCtx->jInterp,
    (DictObj*)naming,
    asSymbol(name),
    definition
  );
}
\stopCCode

\startCCode
static void defineContextAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  
  popCtxDataIntoImpl(aCtx, contextName);
  popCtxDataIntoImpl(aCtx, contextNamedIn);
  popCtxDataIntoImpl(aCtx, contextNamingScope);
  popCtxDataIntoImpl(aCtx, contextData);
  popCtxDataIntoImpl(aCtx, contextProcess);
  if (!isSymbol(contextName)) {
    raiseException(aCtx,
      "defineContext required a symbol as top");
    return;
  }
  if (!isDictionary(contextNamedIn)) {
    raiseException(aCtx,
      "defineContext required a dictionary as second");
    return;
  }
  if (!isDictionary(contextNamingScope)) {
    raiseException(aCtx,
      "defineContext required a dictionary as third");
    return;
  }
  ContextObj* newCtx = newContext(
    jInterp,
    asSymbol(contextName),
    aCtx,
    (DictObj*)contextNamingScope,
    contextData,
    contextProcess
  );
  assert(newCtx);
  defineContextIn(
    jInterp,
    (DictObj*)contextNamedIn,
    asSymbol(contextName),
    newCtx
  );
}
\stopCCode

\startCCode
static void newContextAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);

  popCtxDataIntoImpl(aCtx, contextName);
  popCtxDataIntoImpl(aCtx, contextNamingScope);
  popCtxDataIntoImpl(aCtx, contextData);
  popCtxDataIntoImpl(aCtx, contextProcess);
  if (!isSymbol(contextName)) {
    raiseException(aCtx,
      "newContext requires a symbol as top");
    return;
  }
  if (!isDictionary(contextNamingScope)) {
    raiseException(aCtx,
      "newContext requires a dictionary as second");
    return;
  }
  ContextObj* newCtx = newContext(
    jInterp,
    asSymbol(contextName),
    aCtx,
    (DictObj*)contextNamingScope,
    contextData,
    contextProcess
  );
  assert(newCtx);
  pushCtxDataImpl(aCtx, (JObj*)newCtx);
}
\stopCCode

\startCCode
static void thisContextAP(ContextObj* aCtx) {
  assert(aCtx);
  DEBUG(aCtx->jInterp, "thisContextAP > %p\n", aCtx);
  pushCtxDataImpl(aCtx, (JObj*)aCtx);
  DEBUG(aCtx->jInterp, "thisContextAP < %p\n", aCtx);
}
\stopCCode

\startCCode
static ContextObj* switchCtxAP(ContextObj* aCtx) {
  assert(aCtx);

  popCtxDataIntoImpl(aCtx, newContext);
  popCtxDataIntoImpl(aCtx, oldContextTop);
  if (!isContext(newContext)) {
    raiseException(aCtx,
      "switchCtx required a context as top");
    return aCtx;
  }
  
  //
  // switch to newContext
  //
  DEBUG(aCtx->jInterp, "switchCtxAP -> switching origCtx: %s\n",
    aCtx->name);
  ContextObj* newCtx = (ContextObj*)newContext;
  assert(newCtx);

  pushCtxDataImpl(newCtx, oldContextTop);
  newCtx->tracingOn = aCtx->tracingOn;
  DEBUG(aCtx->jInterp, "switchCtxAP <- switching newCtx: %s\n",
            newCtx->name);
  //
  return newCtx;
}
\stopCCode

\startCCode
static void defineNamingAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  
  popCtxDataIntoImpl(aCtx, dictName);
  popCtxDataIntoImpl(aCtx, dictNamedIn);
  popCtxDataIntoImpl(aCtx, dictNamingScope);
  if (!isSymbol(dictName)) {
    raiseException(aCtx,
      "defineNaming required a symbol as top");
    return;
  }
  if (!isDictionary(dictNamedIn)) {
    raiseException(aCtx,
      "defineNaming requires a dictionary as second");
    return;
  }
  if (!isDictionary(dictNamingScope)) {
    raiseException(aCtx,
      "defineNaming requires a dictionary as third");
    return;
  }
  DictObj* newDict =
    newDictionary(
      jInterp,
      asSymbol(dictName),
      (DictObj*)dictNamingScope
    );
  assert(newDict);
  defineNamingIn(
    jInterp,
    (DictObj*)dictNamedIn,
    asSymbol(dictName),
    newDict
  );
}
\stopCCode

\startCCode
static void newNamingAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);

  popCtxDataIntoImpl(aCtx, dictName);
  popCtxDataIntoImpl(aCtx, dictNamingScope);
  if (!isSymbol(dictName)) {
    raiseException(aCtx,
      "defineNaming requires a symbol as top");
    return;
  }
  if (!isDictionary(dictNamingScope)) {
    raiseException(aCtx,
      "defineNaming requires a dictionary as second");
    return;
  }

  DictObj* newDict =
    newDictionary(
      jInterp,
      asSymbol(dictName),
      (DictObj*)dictNamingScope
    );
  assert(newDict);
  pushCtxDataImpl(aCtx, (JObj*)newDict);
}
\stopCCode

\startCCode
static void localizeNamingAP(ContextObj* aCtx) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  
  popCtxDataIntoImpl(aCtx, localNaming);
  if (!isSymbol(localNaming)){
    raiseException(aCtx,
      "localizeNaming requires a symbol as top");
    return;
  }
  
  DictObj* newDict = 
    newDictionary(
      jInterp,
      asSymbol(localNaming),
      aCtx->dict
    );
  assert(newDict);
  aCtx->dict = newDict;
}
\stopCCode

\startCCode
static void thisNamingAP(ContextObj* aCtx) {
  assert(aCtx);
  pushCtxDataImpl(aCtx, (JObj*)(aCtx->dict));
}
\stopCCode

\startCCode
static void undefineAP(ContextObj* aCtx) {
  assert(aCtx);
  
  popCtxDataIntoImpl(aCtx, name);
  if (!isSymbol(name)) {
    raiseException(aCtx,
      "undefine requires a symbol as top");
    return;
  }
  
  popCtxDataIntoImpl(aCtx, namingScope);
  if (!isDictionary(namingScope)) {
    raiseException(aCtx,
      "undelete requires a dictionary as second");
    return;
  }
  
  deleteSymbol(((DictObj*)namingScope), asSymbol(name));
  }
\stopCCode

\startCCode
void initContextsAPControl(JoyLoLInterp *jInterp) {
  extendJoyLoLInRoot(jInterp, "fail",                failAP);
  extendJoyLoLInRoot(jInterp, "prepend",             prependAP);
  extendJoyLoLInRoot(jInterp, "append",              appendAP);
  extendJoyLoLInRoot(jInterp, "extract",             extractAP);
  extendJoyLoLInRoot(jInterp, "i",                   interpretAP);
  extendJoyLoLInRoot(jInterp, "interpret",           interpretAP);
  extendJoyLoLInRoot(jInterp, "ifte",                ifteAP);
  extendJoyLoLInRoot(jInterp, "ifteCont",            ifteContAP);
  extendJoyLoLInRoot(jInterp, "for",                 forAP);
  extendJoyLoLInRoot(jInterp, "forDone",             forDoneAP);
  extendJoyLoLInRoot(jInterp, "lispInterpret",       lispInterpretAP);
  extendJoyLoLInRoot(jInterp, "lispFor",             lispForAP);
  extendJoyLoLInRoot(jInterp, "define",              defineAP);
  extendJoyLoLInRoot(jInterp, "defineContext",       defineContextAP);
  extendJoyLoLInRoot(jInterp, "newContext",          newContextAP);
  extendJoyLoLInRoot(jInterp, "thisContext",         thisContextAP);
  extendJoyLoLInRoot(jInterp, "defineNaming",        defineNamingAP);
  extendJoyLoLInRoot(jInterp, "newNaming",           newNamingAP);
  extendJoyLoLInRoot(jInterp, "localizeNaming",      localizeNamingAP);
  extendJoyLoLInRoot(jInterp, "thisNaming",          thisNamingAP);
  extendJoyLoLInRoot(jInterp, "undefine",            undefineAP);
  extendJoyLoLInRoot(jInterp, "done",                doneAP);
  extendJoyLoLInRoot(jInterp, "clear",               clearContextAP);
  extendJoyLoLInRoot(jInterp, "try",                 tryAP);
  extendJoyLoLInRoot(jInterp, "raise",               raiseAP);
  extendJoyLoLInRoot(jInterp, "raiseIfFalse",        raiseIfFalseAP);
  extendJoyLoLInRoot(jInterp, "findFirstTryHandler", findFirstTryHandlerAP);
  extendJoyLoLInRoot(jInterp, "tryHandler",          tryHandlerAP);
  
  extendCtxJoyLoLInRoot(jInterp, "switchCtx",        switchCtxAP);
}
\stopCCode