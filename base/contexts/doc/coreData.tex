% A ConTeXt document [master document: contexts.tex]

\section[title=Context core data code]
\setCHeaderStream{public}

\startJoyLoLFragment[pushData]

\startRule[pushData]
\arguments
  (
    aCtx
    lolToPush
  )
\preDataStack
  (
    dataStack
  )
\postDataStack
  (
    (something)
    dataStack
  )
\returns
  (
  )
\stopRule

\startFragment[ansic]
  {{aCtx}}->data =
    newPair({{aCtx}}->jInterp, {{lolToPush}}, {{aCtx}}->data);
\stopFragment

\stopJoyLoLFragment

\startCHeader
typedef void (ClearCtx)(
  ContextObj *aCtx
);

#define clearCtxData(aCtx)                  \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->clearCtxDataFunc),                  \
    (getContextsClass(aCtx->jInterp)        \
      ->clearCtxDataFunc(aCtx))             \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void clearCtxDataImpl(
  ContextObj *aCtx
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void clearCtxDataImpl(
  ContextObj *aCtx
) {
  if (!aCtx) return;
  aCtx->data = NULL;
}
\stopCCode

\startCHeader
typedef void (PushCtx)(
  ContextObj *aCtx,
  JObj   *lolToPush
);

#define pushCtxData(aCtx, lolToPush)        \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->pushCtxDataFunc),                   \
    (getContextsClass(aCtx->jInterp)        \
      ->pushCtxDataFunc(aCtx, lolToPush))   \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushCtxDataImpl(
  ContextObj* aCtx,
  JObj* lolToPush
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushCtxDataImpl(
  ContextObj* aCtx,
  JObj* lolToPush
) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->data = newPair(aCtx->jInterp, lolToPush, aCtx->data);
}
\stopCCode

\startCHeader
typedef void (PushNullCtx)(
  ContextObj *aCtx
);

#define pushNullCtxData(aCtx)               \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->pushNullCtxDataFunc),               \
    (getContextsClass(aCtx->jInterp)        \
      ->pushNullCtxDataFunc(aCtx))          \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushNullCtxDataImpl(
  ContextObj* aCtx
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushNullCtxDataImpl(
  ContextObj* aCtx
) {
  if (!aCtx) return;
  assert(aCtx->jInterp);
  aCtx->data = newPair(aCtx->jInterp, NULL, aCtx->data);
}
\stopCCode

\startCHeader
typedef void (PushBooleanCtx)(
  ContextObj *aCtx,
  Boolean     aBool
);

#define pushBooleanCtxData(aCtx, aBool)      \
  (                                          \
    assert(aCtx),                            \
    assert(getContextsClass(aCtx->jInterp)   \
      ->pushBooleanCtxDataFunc),             \
    (getContextsClass(aCtx->jInterp)         \
      ->pushBooleanCtxDataFunc(aCtx, aBool)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushBooleanCtxDataImpl(
  ContextObj *aCtx,
  Boolean     aBool
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushBooleanCtxDataImpl(
  ContextObj *aCtx,
  Boolean     aBool
) {
  if (!aCtx) return;
  assert(aCtx->jInterp);

  JObj* aBoolPA = newBoolean(aCtx->jInterp, aBool);
  if (!aBoolPA) return;
  aCtx->data = newPair(aCtx->jInterp, aBoolPA, aCtx->data);
}
\stopCCode

\startCHeader
typedef void (PushNaturalCtx)(
  ContextObj *aCtx,
  Symbol     *anNaturalStr
);

#define pushNaturalCtxData(aCtx, aNaturalStr)      \
  (                                                \
    assert(aCtx),                                  \
    assert(getContextsClass(aCtx->jInterp)         \
      ->pushNaturalCtxDataFunc),                   \
    (getContextsClass(aCtx->jInterp)               \
      ->pushNaturalCtxDataFunc(aCtx, aNaturalStr)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushNaturalCtxDataImpl(
  ContextObj *aCtx,
  Symbol     *aNaturalStr
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushNaturalCtxDataImpl(
  ContextObj *aCtx,
  Symbol     *aNaturalStr
) {
  if (!aCtx) return;
  assert(aCtx->jInterp);

  JObj* aNaturalPA = newNatural(aCtx->jInterp, aNaturalStr);
  if (!aNaturalPA) return;
  aCtx->data = newPair(aCtx->jInterp, aNaturalPA, aCtx->data);
}
\stopCCode

\startCHeader
typedef void (PushSymbolCtx)(
  ContextObj *aCtx,
  Symbol     *aSymbol
);

#define pushSymbolCtxData(aCtx, aSymbol)      \
  (                                           \
    assert(aCtx),                             \
    assert(getContextsClass(aCtx->jInterp)    \
      ->pushSymbolCtxDataFunc),               \
    (getContextsClass(aCtx->jInterp)          \
      ->pushSymbolCtxDataFunc(aCtx, aSymbol)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushSymbolCtxDataImpl(
  ContextObj* aCtx,
  Symbol* aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushSymbolCtxDataImpl(
  ContextObj* aCtx,
  Symbol* aSymbol
) {
  if (!aCtx) return;
  if (!aSymbol) return;
  assert(aCtx->jInterp);

  JObj* aSymbolPA =
    getSymbol(aCtx->jInterp->dict, aSymbol);
  if (!aSymbolPA) return;
  aCtx->data = newPair(aCtx->jInterp, aSymbolPA, aCtx->data);
}
\stopCCode

\startCHeader
typedef void (PushParsedArrayOfStringsCtx)(
  ContextObj *aCtx,
  Symbol     *someStrings[]
);

#define pushParsedArrayOfStringsCtxData(      \
  aCtx, someStrings)                          \
  (                                           \
    assert(aCtx),                             \
    assert(getContextsClass(aCtx->jInterp)    \
      ->pushParsedArrayOfStringsCtxDataFunc), \
    (getContextsClass(aCtx->jInterp)          \
      ->pushParsedArrayOfStringsCtxDataFunc(  \
        aCtx, someStrings))                   \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushParsedArrayOfStringsCtxDataImpl(
  ContextObj* aCtx,
  Symbol* someStrings[]
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushParsedArrayOfStringsCtxDataImpl(
  ContextObj* aCtx,
  Symbol* someStrings[]
) {
  if (!aCtx) return;
  if (!someStrings) return;
  TextObj* aText =
    createTextFromArrayOfStrings(aCtx->jInterp, someStrings);
  pushParsedTextCtxData(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
typedef void (PushParsedStringCtx)(
  ContextObj *aCtx,
  Symbol     *aString
);

#define pushParsedStringCtxData(aCtx, aString)      \
  (                                                 \
    assert(aCtx),                                   \
    assert(getContextsClass(aCtx->jInterp)          \
      ->pushParsedStringCtxDataFunc),               \
    (getContextsClass(aCtx->jInterp)                \
      ->pushParsedStringCtxDataFunc(aCtx, aString)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushParsedStringCtxDataImpl(
  ContextObj* aCtx,
  Symbol* aString
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushParsedStringCtxDataImpl(
  ContextObj* aCtx,
  Symbol* aString
) {
  if (!aCtx) return;
  if (!aString) return;
  TextObj* aText =
    createTextFromString(aCtx->jInterp, aString);
  pushParsedTextCtxData(aCtx, aText);
  freeText(aText);
}
\stopCCode

\startCHeader
typedef void (PushParsedTextCtx)(
  ContextObj *aCtx,
  TextObj    *aTex
);

#define pushParsedTextCtxData(aCtx, aText)      \
  (                                             \
    assert(aCtx),                               \
    assert(getContextsClass(aCtx->jInterp)      \
      ->pushParsedTextCtxDataFunc),             \
    (getContextsClass(aCtx->jInterp)            \
      ->pushParsedTextCtxDataFunc(aCtx, aText)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void pushParsedTextCtxDataImpl(
  ContextObj* aCtx,
  TextObj* aText
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void pushParsedTextCtxDataImpl(
  ContextObj* aCtx,
  TextObj* aText
) {
  if (!aCtx) return;
  if (!aText) return;
  assert(aCtx->jInterp);
  JObj* aLoL = parseAllSymbols(aText);
  if (!aLoL) return;
  aCtx->data = newPair(aCtx->jInterp, aLoL, aCtx->data);
}
\stopCCode

\startCHeader
typedef void (PrependListCtx)(
  ContextObj *aCtx,
  JObj   *lolToPrepend
);

#define prependListCtxData(aCtx, lolToPrepend)      \
  (                                                 \
    assert(aCtx),                                   \
    assert(getContextsClass(aCtx->jInterp)          \
      ->prependListCtxDataFunc),                    \
    (getContextsClass(aCtx->jInterp)                \
      ->prependListCtxDataFunc(aCtx, lolToPrepend)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void prependListCtxDataImpl(
  ContextObj* aCtx,
  JObj* lolToPrepend
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void prependListCtxDataImpl(
  ContextObj* aCtx,
  JObj* lolToPrepend
) {
  if (!aCtx) return;
  if (!lolToPrepend) return;

  // ensure lolToPrepend is a list
  if (!isPair(lolToPrepend)) {
    lolToPrepend = newPair(aCtx->jInterp, lolToPrepend, NULL);
    assert(lolToPrepend);
  }

  // find end of lolToPrepend
  JObj* lolList = lolToPrepend;
  while(asCdr(lolList) && isPair(asCdr(lolList))) {
    lolList = asCdr(lolList);
  }

  // ensure that if lolToPrepend ends in a non-pair we make it a pair
  if (asCdr(lolList) && !isPair(asCdr(lolList))) {
    asCdr(lolList) = newPair(aCtx->jInterp, asCdr(lolList), NULL);
    assert(asCdr(lolList));
  }

  // place existing data stack at end of lolToPrepend
  asCdr(lolList) = aCtx->data;
  aCtx->data     = lolToPrepend;
}
\stopCCode

\startCHeader
typedef JObj *(PopCtx)(
  ContextObj *aCtx
);

#define popCtxData(aCtx)                    \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->popCtxDataFunc),                    \
    (getContextsClass(aCtx->jInterp)        \
      ->popCtxDataFunc(aCtx))               \
  )

#define popCtxDataInto(aCtx, aVar)                              \
assert(aCtx);                                                   \
JObj* aVar = popCtxData(aCtx);                                  \
if (aCtx->tracingOn) {                                          \
  JoyLoLInterp *jInterp = aCtx->jInterp;                        \
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);          \
  strBufPrintf(jInterp, aStrBuf, "%s = ", #aVar);               \
  printLoL(jInterp, aStrBuf, aVar);                             \
  strBufPrintf(jInterp, aStrBuf, "\n");                         \
  jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));  \
  strBufClose(jInterp, aStrBuf);                                \
}
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern JObj* popCtxDataImpl(
  ContextObj* aCtx
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
JObj* popCtxDataImpl(
  ContextObj* aCtx
) {
  if (!aCtx) return NULL;
  if (!aCtx->data) return NULL;

  JObj* poppedLoL = asCar(aCtx->data);
  aCtx->data          = asCdr(aCtx->data);
  return poppedLoL;
}
\stopCCode

\startCHeader
#define showCtxData(aCtx, aStrBuf)              \
  assert(aCtx);                                 \
  printLoL(aCtx->jInterp, aStrBuf, aCtx->data); \
\stopCHeader

