% A ConTeXt document [master document: contexts.tex]

\section[title=Evaluation]

\startCCode
static void traceAction(
  JoyLoLInterp *jInterp,
  Symbol       *action,
  CoAlgObj     *aLoL,
  CoAlgObj     *command
) {
  assert(jInterp);
  StringBufferObj *aStrBuf =
    newStringBuffer(jInterp);
  strBufPrintf(jInterp, aStrBuf, "%s: ", action);
  printLoL(jInterp, aStrBuf, aLoL);
  if (command) {
    printLoL(jInterp, aStrBuf, command);
  }
  strBufPrintf(jInterp, aStrBuf, "\n");
  jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));
  strBufClose(jInterp, aStrBuf);
}
\stopCCode

\startCHeader
typedef void (EvalCommandInContext)(
  ContextObj *aCtx,
  CoAlgObj   *command
);

#define evalCommandInContext(aCtx, aCommand)      \
  (                                               \
    assert(aCtx),                                 \
    assert(getContextsClass(aCtx->jInterp)        \
      ->evalCommandInContextFunc),                \
    (getContextsClass(aCtx->jInterp)              \
      ->evalCommandInContextFunc(aCtx, aCommand)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
void evalCommandInContextImpl(
  ContextObj *aCtx,
  CoAlgObj   *command
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void evalCommandInContextImpl(
  ContextObj *aCtx,
  CoAlgObj   *command
) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);
  //
  // if there is no command... there is nothing to do
  //
  if (!command) return;
  //
  DEBUG(jInterp, "evalCommandInContext > %p %p\n", aCtx, command);
  //
  // push this command onto the top of the process stack
  //
  pushCtxProcess(aCtx, command);
  //
  while(aCtx->process) {
    if (aCtx->tracingOn) {
      StringBufferObj *aStrBuf = 
        newStringBuffer(jInterp);
      strBufPrintf(jInterp, aStrBuf, "\n ctx: %s\n", aCtx->name);
      jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));
      strBufClose(jInterp, aStrBuf);
    }
    //
    // pop the next command off the process stack
    //
    command = popCtxProcess(aCtx);
    aCtx->command = command;
    //
    if (isCFunction(command)) {
      //
      // if the command is a function.. call the function
      //
      if (aCtx->tracingOn) 
        traceAction(jInterp, "calling", command, NULL);
      (asCFunc(command))(aCtx);
      //
    } else if (isContext(command)) {
      //
      // if the command is a context... switch to this context
      //
      DEBUG(jInterp, "evalCommandInContext -> switching origCtx: %s\n",
            aCtx->name);
      if (aCtx->tracingOn)
        traceAction(jInterp, "switching", command, NULL);
      ContextObj* switchCtx = (ContextObj*)command;
      assert(switchCtx);

      popCtxDataInto(aCtx, oldCtxTop);
      pushCtxData(switchCtx, oldCtxTop);
      switchCtx->tracingOn = aCtx->tracingOn;
      aCtx = switchCtx;
      DEBUG(jInterp, "evalCommandInContext <- switching newCtx: %s\n",
            aCtx->name);
      //
    } else if (!isSymbol(command)) {
      //
      // if the command is not a Symbol ...
      //  ...  push it onto the top of the data stack
      //
      if (aCtx->tracingOn)
        traceAction(jInterp, "adding", command, NULL);
      pushCtxData(aCtx, command);
      //
    } else {
      //
      // if the command is a symbol ...
      //  ... look up the symbol's association in the dictionary
      //
      DictObj* assoc = findSymbol(jInterp, asSymbol(command));
      assert(assoc);
      //
      if (!assoc->value) {
        //
        // if the association is empty.. push this symbol onto the top
        // of the data stack (re-evaluating this symbol would lead to an
        // infinite loop)
        //
        if (aCtx->tracingOn)
          traceAction(jInterp, "adding", command, NULL);
        pushCtxData(aCtx, command);
        //
      } else if (isPair(assoc->value)) {
        //
        // if the association is a LoL.. push this LoL onto the top of the
        // process stack
        //
        if (aCtx->tracingOn)
          traceAction(jInterp, "evaluating", assoc->value, command);
        prependListCtxProcess(aCtx,
          copyLoL(jInterp, assoc->value));
        //
      } else if (isCFunction(assoc->value)) {
        //
        // if the association is a function.. call the function
        //
        if (aCtx->tracingOn)
          traceAction(jInterp, "calling", command, NULL);
        (asCFunc(assoc->value))(aCtx);
        //
      } else if (isContext(assoc->value)) {
        //
        // if the association is a context... switch to this contex
        //
        DEBUG(jInterp, "evalCommandInContext -> switching origCtx: %s\n",
              aCtx->name);
        if (aCtx->tracingOn)
          traceAction(jInterp, "switching", command, NULL);
        ContextObj* switchCtx = (ContextObj*)(assoc->value);
        assert(switchCtx);

        popCtxDataInto(aCtx, oldCtxTop);
        pushCtxData(switchCtx, oldCtxTop);
        switchCtx->tracingOn = aCtx->tracingOn;
        aCtx = switchCtx;
        DEBUG(jInterp, "evalCommandInContext <- switching newCtx: %s\n",
              aCtx->name);
        //
      } else {
        //
        // if the association is NOT a PairAtom or Function...
        // ... push this new ATOM onto the top of the process stack
        //
        if (aCtx->tracingOn)
          traceAction(jInterp, "evaluating", assoc->value, command);
        pushCtxProcess(aCtx, assoc->value);
        //
      }
    }
    if (aCtx->tracingOn) {
      DEBUG(jInterp, "evalCommandInContext -> tracing%s\n", "");
      StringBufferObj *aStrBuf = newStringBuffer(jInterp);
      strBufPrintf(jInterp, aStrBuf, "d>>");
      printLoL(jInterp, aStrBuf, aCtx->data);
      strBufPrintf(jInterp, aStrBuf, "\n");
      strBufPrintf(jInterp, aStrBuf, "p>>");
      printLoL(jInterp, aStrBuf, aCtx->process);
      strBufPrintf(jInterp, aStrBuf, "\n");
      jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));
      strBufClose(jInterp, aStrBuf);
      DEBUG(jInterp, "evalCommandInContext <- tracing%s\n", "");
    }
  } // aCtx->process is empty
  DEBUG(jInterp, "evalCommandInContext < %p %p\n", aCtx, command);
}
\stopCCode

\startCHeader
typedef void (EvalContext)(
  ContextObj *aCtx
);

#define evalContext(aCtx)                   \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->evalContextFunc),                   \
    (getContextsClass(aCtx->jInterp)        \
      ->evalContextFunc(aCtx))              \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
void evalContextImpl(
  ContextObj *aCtx
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void evalContextImpl(
  ContextObj *aCtx
) {
  popCtxProcessInto(aCtx, aCommand);
  evalCommandInContext(aCtx, aCommand);
}
\stopCCode

\startCHeader
typedef void (EvalTextInContext)(
  ContextObj *aCtx,
  TextObj    *aText
);

#define evalTextInContext(aCtx, aText)      \
  (                                         \
    assert(aCtx),                           \
    assert(getContextsClass(aCtx->jInterp)  \
      ->evalTextInContextFunc),             \
    (getContextsClass(aCtx->jInterp)        \
      ->evalTextInContextFunc(aCtx, aText)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void evalTextInContextImpl(
  ContextObj *aCtx,
  TextObj    *aText
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void evalTextInContextImpl(
  ContextObj *aCtx,
  TextObj    *aText
) {
  assert(aCtx);
  JoyLoLInterp *jInterp = aCtx->jInterp;
  assert(jInterp);

  DEBUG(jInterp, "evalTextInContext > %p %p\n", aCtx, aText);
  while(TRUE) {
    CoAlgObj* aLoL = parseOneSymbol(aText);
/**/    if (aCtx->showStack) {
      StringBufferObj *aStrBuf =
        newStringBuffer(jInterp);
      strBufPrintf(jInterp, aStrBuf, "<");
      printLoL(jInterp, aStrBuf, aLoL);
      strBufPrintf(jInterp, aStrBuf, "\n");
      jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));
      strBufClose(jInterp, aStrBuf);
    } /**/
    if (!aLoL) break;
    evalCommandInContext(aCtx, aLoL);
/**/    if (aCtx->showStack) {
      StringBufferObj *aStrBuf =
        newStringBuffer(jInterp);
      strBufPrintf(jInterp, aStrBuf, ">");
      printLoL(jInterp, aStrBuf, aCtx->data);
      strBufPrintf(jInterp, aStrBuf, "\n");
      jInterp->writeStdOut(jInterp, getCString(jInterp, aStrBuf));
      strBufClose(jInterp, aStrBuf);
    } /**/
    if (aCtx->exceptionRaised) break;
  }
  DEBUG(jInterp, "evalTextInContext < %p %p\n", aCtx, aText);
}
\stopCCode

\startCHeader
typedef void (EvalArrayOfStringsInContext)(
  ContextObj *aCtx,
  Symbol     *someStrings[]
);

#define evalArrayOfStringsInContext(aCtx, someStrings)      \
  (                                                         \
    assert(aCtx),                                           \
    assert(getContextsClass(aCtx->jInterp)                  \
      ->evalArrayOfStringsInContextFunc),                   \
    (getContextsClass(aCtx->jInterp)                        \
      ->evalArrayOfStringsInContextFunc(aCtx, someStrings)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void evalArrayOfStringsInContextImpl(
  ContextObj *aCtx,
  Symbol     *someStrings[]
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void evalArrayOfStringsInContextImpl(
  ContextObj *aCtx,
  Symbol     *someStrings[]
) {
  assert(aCtx);
  assert(aCtx->jInterp);
  DEBUG(aCtx->jInterp, "evalArrayOfStringsInContext > %p %p\n",
    aCtx, someStrings);
  assert(aCtx);
  TextObj* stringText =
    createTextFromArrayOfStrings(
      aCtx->jInterp,
      someStrings
    );
  evalTextInContext(aCtx, stringText);
  freeText(stringText);
  DEBUG(aCtx->jInterp, "evalArrayOfStringsInContext < %p %p\n",
    aCtx, someStrings);
}
\stopCCode

\startCHeader
typedef void (EvalStringInContext)(
  ContextObj *aCtx,
  Symbol     *aString
);

#define evalStringInContext(aCtx, aString)      \
  (                                             \
    assert(aCtx),                               \
    assert(getContextsClass(aCtx->jInterp)      \
      ->evalStringInContextFunc),               \
    (getContextsClass(aCtx->jInterp)            \
      ->evalStringInContextFunc(aCtx, aString)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void evalStringInContextImpl(
  ContextObj *aCtx,
  Symbol     *aString
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void evalStringInContextImpl(
  ContextObj *aCtx,
  Symbol     *aString
) {
  assert(aCtx);
  assert(aCtx->jInterp);
  DEBUG(aCtx->jInterp, "evalStringInContext > %p [%s]\n", aCtx, aString);
  assert(aCtx);
  TextObj* stringText =
    createTextFromString(
      aCtx->jInterp,
      aString
    );
  evalTextInContext(aCtx, stringText);
  freeText(stringText);
  DEBUG(aCtx->jInterp, "evalStringInContext < %p [%s]\n", aCtx, aString);
}
\stopCCode