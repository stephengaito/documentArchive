% A ConTeXt document [master document: contexts.tex]

\section[title=Code]

\dependsOn[jInterps]
\dependsOn[booleans]
\dependsOn[naturals]
\dependsOn[symbols]
\dependsOn[stringBuffers]
\dependsOn[cFunctions]
\dependsOn[pairs]
\dependsOn[texts]
\dependsOn[parsers]
\dependsOn[dictionaries]
\setCHeaderStream{public}

\startCHeader
typedef struct context_object_struct ContextObj;
typedef struct context_object_struct {
  CoAlgObj      super;
  JoyLoLInterp *jInterp;
  Symbol       *name;
  ContextObj   *parent;
  CoAlgObj     *data;
  CoAlgObj     *command;
  CoAlgObj     *process;
  CoAlgObj     *messages;
  CoAlgObj     *listeners;
  Boolean       exceptionRaised;
  Boolean       showSpecifications;
  Boolean       showStack;
  Boolean       tracingOn;
  Boolean       checkingOn;
  Boolean       verbose;
} ContextObj;
\stopCHeader

\startCHeader
typedef ContextObj *(NewContext)(
  JoyLoLInterp *jInterp,
  Symbol       *name,
  ContextObj   *parent,
  CoAlgObj     *dataLoL,
  CoAlgObj     *processLoL
);

#define newContext(jInterp, name, parent,     \
  dataLoL, processLoL)                        \
  (                                           \
    assert(getContextsClass(jInterp)          \
      ->newContextFunc),                      \
    (getContextsClass(jInterp)                \
      ->newContextFunc(jInterp, name, parent, \
        dataLoL, processLoL))                 \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern ContextObj* newContextImpl(
  JoyLoLInterp *jInterp,
  Symbol       *name,
  ContextObj   *parent,
  CoAlgObj     *dataLoL,
  CoAlgObj     *processLoL
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
ContextObj* newContextImpl(
  JoyLoLInterp *jInterp,
  Symbol       *name,
  ContextObj   *parent,
  CoAlgObj     *dataLoL,
  CoAlgObj     *processLoL
) {
  DEBUG(FALSE, "createContext %p [%s] %p %p %p\n",
    jInterp, name, parent, dataLoL, processLoL);
  assert(jInterp);

  ContextObj* context =
    (ContextObj*) newObject(jInterp, ContextsTag);
  assert(context);

  context->jInterp            = jInterp;
  context->name               = name;
  context->parent             = parent;
  context->data               = dataLoL;
  context->command            = NULL;
  context->process            = processLoL;
  context->messages           = NULL;
  context->listeners          = NULL;
  context->showSpecifications = TRUE;
  context->showStack          = TRUE;
  context->tracingOn          = FALSE;
  context->checkingOn         = FALSE;
  context->verbose            = FALSE;
  context->exceptionRaised    = FALSE;

  return context;
}

#define asName(aLoL)      (((ContextObj*)(aLoL))->name)
#define asData(aLoL)      (((ContextObj*)(aLoL))->data)
#define asCommand(aLoL)   (((ContextObj*)(aLoL))->command)
#define asProcess(aLoL)   (((ContextObj*)(aLoL))->process)
#define asMessages(aLoL)  (((ContextObj*)(aLoL))->messages)
#define asListeners(aLoL) (((ContextObj*)(aLoL))->listeners)
\stopCCode

\setCHeaderStream{private}
\startCHeader
extern Boolean equalityContextsCoAlg(
  CoAlgObj* lolA,
  CoAlgObj* lolB,
  Boolean debugFlag
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean equalityContextsCoAlg(
  CoAlgObj* lolA,
  CoAlgObj* lolB,
  Boolean debugFlag
) {
  DEBUG(debugFlag, "contextCoAlg->equal a:%p b:%p\n",
    lolA, lolB);
  if (!lolA && !lolB) return TRUE;
  if (!lolA && lolB)  return FALSE;
  if (lolA  && !lolB) return FALSE;
  if (asType(lolA) != asType(lolB)) return FALSE;
  if (!asType(lolA)) return FALSE;
  if (asTag(lolA) != ContextsTag) return FALSE;
  size_t areEqual = TRUE;
  lolEqual(areEqual, asData(lolA),      asData(lolB));
  lolEqual(areEqual, asCommand(lolA),   asCommand(lolB));
  lolEqual(areEqual, asProcess(lolA),   asProcess(lolB));
  lolEqual(areEqual, asMessages(lolA),  asMessages(lolB));
  lolEqual(areEqual, asListeners(lolA), asListeners(lolB));
  return areEqual;
}
\stopCCode

\setCHeaderStream{private}
\startCHeader
extern Boolean printContextsCoAlg(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  CoAlgObj        *aLoL
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean printContextsCoAlg(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  CoAlgObj        *aLoL
) {
  assert(jInterp);
  assert(aLoL);
  assert(asType(aLoL));
  assert(asTag(aLoL) == ContextsTag);

//  if (!(aLoL->tag & PRINT_MARKER)) return TRUE;
//  aLoL->tag = aLoL->tag & (~ PRINT_MARKER);

  size_t printedOk = TRUE;
  strBufPrintf(jInterp, aStrBuf, "\n[%s[ ", asName(aLoL));
  lolPrintStr(jInterp, printedOk, asData(aLoL),
              "d:( ", ") ", aStrBuf);
  lolPrintStr(jInterp, printedOk, asCommand(aLoL),
              "c:( ", ") ", aStrBuf);
  lolPrintStr(jInterp, printedOk, asProcess(aLoL),
              "p:( ", ") ", aStrBuf);
  lolPrintStr(jInterp, printedOk, asMessages(aLoL),
              "m:( ", ") ", aStrBuf);
  lolPrintStr(jInterp, printedOk, asListeners(aLoL),
              "l:( ", ") ", aStrBuf);
  strBufPrintf(jInterp, aStrBuf, " ]]\n");
  return printedOk;
}
\stopCCode

\startTestSuite[registerContexts]

\startCHeader
typedef struct contexts_class_struct {
  CoAlgClass      super;
  NewContext     *newContextFunc;
  PushCtx        *pushCtxDataFunc; 
  PushNullCtx    *pushNullCtxDataFunc;
  PushSymbolCtx  *pushSymbolCtxDataFunc;
  PushParsedArrayOfStringsCtx 
    *pushParsedArrayOfStringsCtxDataFunc;
  PushParsedStringCtx
    *pushParsedStringCtxDataFunc;
  PushParsedTextCtx
    *pushParsedTextCtxDataFunc;
  PrependListCtx *prependListCtxDataFunc;
  PopCtx         *popCtxDataFunc;
  PushCtx        *pushCtxProcessFunc;
  PushNullCtx    *pushNullCtxProcessFunc;
  PushSymbolCtx  *pushSymbolCtxProcessFunc;
  PushParsedArrayOfStringsCtx
    *pushParsedArrayOfStringsCtxProcessFunc;
  PushParsedStringCtx
    *pushParsedStringCtxProcessFunc;
  PushParsedTextCtx
    *pushParsedTextCtxProcessFunc;
  PrependListCtx *prependListCtxProcessFunc;
  PopCtx         *popCtxProcessFunc;
  ExtendJoyLoL   *extendJoyLoLFunc;
  DefineJoyLoL   *defineJoyLoLFunc;
} ContextsClass;
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern Boolean registerContexts(
  JoyLoLInterp *jInterp
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean registerContexts(
  JoyLoLInterp *jInterp
) {
  ContextsClass* theCoAlg    = 
    joyLoLCalloc(1, ContextsClass);
  theCoAlg->super.name             = ContextsName;
  theCoAlg->super.objectSize       = sizeof(ContextObj);
  theCoAlg->super.registerFunc     = registerContexts;
  theCoAlg->super.equalityFunc     = equalityContextsCoAlg;
  theCoAlg->super.printFunc        = printContextsCoAlg;
  theCoAlg->newContextFunc         = newContextImpl;
  
  theCoAlg->pushCtxDataFunc        = pushCtxDataImpl;
  theCoAlg->pushNullCtxDataFunc    = pushNullCtxDataImpl;
  theCoAlg->pushSymbolCtxDataFunc  = pushSymbolCtxDataImpl;
  theCoAlg->pushParsedArrayOfStringsCtxDataFunc =
    pushParsedArrayOfStringsCtxDataImpl;
  theCoAlg->pushParsedStringCtxDataFunc =
    pushParsedStringCtxDataImpl;
  theCoAlg->pushParsedTextCtxDataFunc =
    pushParsedTextCtxDataImpl;
  theCoAlg->prependListCtxDataFunc = prependListCtxDataImpl;
  theCoAlg->popCtxDataFunc         = popCtxDataImpl;
  
  theCoAlg->pushCtxProcessFunc     = pushCtxProcessImpl;
  theCoAlg->pushNullCtxProcessFunc = NULL;
  theCoAlg->pushSymbolCtxProcessFunc =
    pushSymbolCtxProcessImpl;
  theCoAlg->pushParsedArrayOfStringsCtxProcessFunc =
    pushParsedArrayOfStringsCtxProcessImpl;
  theCoAlg->pushParsedStringCtxProcessFunc =
    pushParsedStringCtxProcessImpl;
  theCoAlg->pushParsedTextCtxProcessFunc =
    pushParsedTextCtxProcessImpl;
  theCoAlg->prependListCtxProcessFunc =
    prependListCtxProcessImpl;
  theCoAlg->popCtxProcessFunc      = popCtxProcessImpl;
  
  theCoAlg->extendJoyLoLFunc       = extendJoyLoLImpl;
  theCoAlg->defineJoyLoLFunc       = defineJoyLoLImpl;
  
  size_t tag =
    registerCoAlgClass(jInterp, (CoAlgClass*)theCoAlg);

  // do a sanity check...
  assert(tag == ContextsTag);
  assert(jInterp->coAlgs[tag].sClass);
  
  registerContextWords(jInterp);
  
  return TRUE;
}
\stopCCode

\startTestCase[should register contexts]

\startCTest
  // CTestsSetup has already created a jInterp
  // and run registerContexts
  
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs);
  AssertPtrNotNull(getContextsClass(jInterp));
  ContextsClass *coAlg = getContextsClass(jInterp);
  AssertIntTrue(registerContexts(jInterp));
  AssertPtrNotNull(getContextsClass(jInterp));
  AssertPtrEquals(getContextsClass(jInterp), coAlg);
  AssertIntEquals(
    getContextsClass(jInterp)->super.objectSize,
    sizeof(ContextObj)
  )
\stopCTest

\stopTestCase
\stopTestSuite


\starttyping
/******

// TODO move to context


void ignoreTest_defineFactorial(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);
  Context* aCtx = createContext(anInterp);
  AssertPtrNotNull(aCtx);

  Text* factorialText = createTextFromArrayOfStrings(coAlgs, factorialStrs);
  AssertPtrNotNull(factorialText);

  CoAlgObj* factorialLoL = parseAllSymbols(factorialText);
  AssertPtrNotNull(factorialLoL);

  defineJoyLoL(anInterp->coAlgebras, "factorial", factorialLoL);
  freeText(factorialText);
}
******/
\stoptyping
