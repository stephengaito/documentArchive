% A ConTeXt document [master document: contexts.tex]

\section[title=Code]

\dependsOn[jInterps]
\dependsOn[naturals]
\dependsOn[symbols]
\dependsOn[pairs]
\dependsOn[texts]
\dependsOn[parsers]
\dependsOn[dictionaries]
\setCHeaderStream{public}

\startCHeader
typedef struct context_object_struct ContextObj;
typedef struct context_object_struct {
  CoAlgObj      super;
  JoyLoLInterp *jInterp;
  Symbol       *name;
  ContextObj   *parent;
  CoAlgObj     *data;
  CoAlgObj     *command;
  CoAlgObj     *process;
  CoAlgObj     *messages;
  CoAlgObj     *listeners;
  Boolean       exceptionRaised;
  Boolean       showSpecifications;
  Boolean       showStack;
  Boolean       tracingOn;
  Boolean       checkingOn;
  Boolean       verbose;
} ContextObj;
\stopCHeader

\startCHeader
extern ContextObj* newContext(JoyLoLInterp *jInterp,
                              Symbol       *name,
                              ContextObj   *parent,
                              CoAlgObj     *dataLoL,
                              CoAlgObj     *processLoL
);
\stopCHeader
\startCCode
ContextObj* newContext(JoyLoLInterp *jInterp,
                       Symbol       *name,
                       ContextObj   *parent,
                       CoAlgObj     *dataLoL,
                       CoAlgObj     *processLoL
) {
  DEBUG(FALSE, "createContext %p [%s] %p %p %p\n",
    jInterp, name, parent, dataLoL, processLoL);
  assert(jInterp);

  ContextObj* context =
    (ContextObj*) newObject(jInterp, ContextsTag);
  assert(context);

  context->jInterp            = jInterp;
  context->name               = name;
  context->parent             = parent;
  context->data               = dataLoL;
  context->command            = NULL;
  context->process            = processLoL;
  context->messages           = NULL;
  context->listeners          = NULL;
  context->showSpecifications = TRUE;
  context->showStack          = TRUE;
  context->tracingOn          = FALSE;
  context->checkingOn         = FALSE;
  context->verbose            = FALSE;
  context->exceptionRaised    = FALSE;

  return context;
}

#define asName(aLoL)      (((ContextObj*)(aLoL))->name)
#define asData(aLoL)      (((ContextObj*)(aLoL))->data)
#define asCommand(aLoL)   (((ContextObj*)(aLoL))->command)
#define asProcess(aLoL)   (((ContextObj*)(aLoL))->process)
#define asMessages(aLoL)  (((ContextObj*)(aLoL))->messages)
#define asListeners(aLoL) (((ContextObj*)(aLoL))->listeners)
\stopCCode

\starttyping
\startJoyLoLWord[eval]

\startJoyLoLCode

;; this is a comment
#| 
  This is a multi-line comment
  and another line
|#

(test () ())

\stopJoyLoLCode
\stoptyping

\setCHeaderStream{private}
\startCHeader
extern Boolean equalityContextsCoAlg(
  CoAlgObj* lolA,
  CoAlgObj* lolB,
  Boolean debugFlag
);
\stopCHeader

\startCCode
Boolean equalityContextsCoAlg(
  CoAlgObj* lolA,
  CoAlgObj* lolB,
  Boolean debugFlag
) {
  DEBUG(debugFlag, "contextCoAlg->equal a:%p b:%p\n",
    lolA, lolB);
  if (!lolA && !lolB) return TRUE;
  if (!lolA && lolB)  return FALSE;
  if (lolA  && !lolB) return FALSE;
  if (lolA->type != lolB->type) return FALSE;
  if (lolA->tag != ContextsTag) return FALSE;
  size_t areEqual = TRUE;
  lolEqual(areEqual, asData(lolA),      asData(lolB));
  lolEqual(areEqual, asCommand(lolA),   asCommand(lolB));
  lolEqual(areEqual, asProcess(lolA),   asProcess(lolB));
  lolEqual(areEqual, asMessages(lolA),  asMessages(lolB));
  lolEqual(areEqual, asListeners(lolA), asListeners(lolB));
  return areEqual;
}
\stopCCode

\startCHeader
extern Boolean printSizeContextsCoAlg(
  CoAlgObj* aLoL,
  Boolean debugFlag
);
\stopCHeader

\startCCode
Boolean printSizeContextsCoAlg(
  CoAlgObj* aLoL,
  Boolean debugFlag
) {
  DEBUG(debugFlag, "contextCoAlg->printSize: > %p\n", aLoL);
  assert(aLoL);
  assert(aLoL->type);
  assert(aLoL->tag == ContextsTag);

//  if ((aLoL->tag & PRINT_MARKER)) return 0;
//  aLoL->tag |= PRINT_MARKER;

  DEBUG(debugFlag, "contextCoAlg-printSize: %p {%p:%zu} d:%p c:%p p:%p m:%p l:%p\n",
    aLoL, aLoL->type, (size_t)(aLoL->flags),
    asData(aLoL), asCommand(aLoL), asProcess(aLoL),
    asMessages(aLoL), asListeners(aLoL));

  size_t lolSize = 12 + strlen(asName(aLoL)); // "\n[[ " and " ]]\n"

  lolPrintSize(lolSize, asData(aLoL), 6,
               "context", "data",      debugFlag);
  lolPrintSize(lolSize, asCommand(aLoL), 6,
               "context", "command",   debugFlag);
  lolPrintSize(lolSize, asProcess(aLoL), 6,
               "context", "process",   debugFlag);
  lolPrintSize(lolSize, asMessages(aLoL), 6,
               "context", "messages",  debugFlag);
  lolPrintSize(lolSize, asListeners(aLoL), 6,
               "context", "listeners", debugFlag);

  DEBUG(debugFlag, "contextCoAlg-printSize: < %zu %p\n", lolSize, aLoL);
  return lolSize;
}
\stopCCode

\startCHeader
extern Boolean printStrContextsCoAlg(
  CoAlgObj* aLoL,
  char* buffer,
  size_t bufferSize
);
\stopCHeader

\startCCode
Boolean printStrContextsCoAlg(
  CoAlgObj* aLoL,
  char* buffer,
  size_t bufferSize
) {
  assert(aLoL);
  assert(aLoL->type);
  assert(aLoL->tag == ContextsTag);

//  if (!(aLoL->tag & PRINT_MARKER)) return TRUE;
//  aLoL->tag = aLoL->tag & (~ PRINT_MARKER);

  size_t printedOk = TRUE;
  strcat(buffer, "\n[");
  strcat(buffer, asName(aLoL));
  strcat(buffer, "[ ");
  lolPrintStr(printedOk, asData(aLoL),
              "d:( ", ") ", buffer, bufferSize);
  lolPrintStr(printedOk, asCommand(aLoL),
              "c:( ", ") ", buffer, bufferSize);
  lolPrintStr(printedOk, asProcess(aLoL),
              "p:( ", ") ", buffer, bufferSize);
  lolPrintStr(printedOk, asMessages(aLoL),
              "m:( ", ") ", buffer, bufferSize);
  lolPrintStr(printedOk, asListeners(aLoL),
              "l:( ", ") ", buffer, bufferSize);
  strcat(buffer, " ]]\n");
  return printedOk;
}
\stopCCode

\startTestSuite[registerContexts]

\startCHeader
extern Boolean registerContexts(JoyLoLInterp *jInterp);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean registerContexts(JoyLoLInterp *jInterp) {
  CoAlgebra* theCoAlg    = (CoAlgebra*) calloc(1, sizeof(CoAlgebra));
  theCoAlg->name         = ContextsName;
  theCoAlg->objectSize   = sizeof(ContextObj);
  theCoAlg->registerFunc = registerContexts;
  theCoAlg->equalityFunc = equalityContextsCoAlg;
  theCoAlg->printSize    = printSizeContextsCoAlg;
  theCoAlg->printStr     = printStrContextsCoAlg;
  size_t tag = registerCoAlgebra(jInterp, theCoAlg);

  // do a sanity check...
  assert(tag == ContextsTag);
  assert(jInterp->coAlgs[tag].sClass);
  
  registerContextWords(jInterp);
  
  return TRUE;
}
\stopCCode

\startTestCase[should register contexts]

\startCTest
  // CTestsSetup has already created a jInterp
  // and run registerContexts
  
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs);
  AssertPtrNotNull(jInterp->coAlgs[ContextsTag].sClass);
  CoAlgebra *coAlg = jInterp->coAlgs[ContextsTag].sClass;
//  AssertIntTrue(registerContexts(jInterp));
  AssertPtrNotNull(jInterp->coAlgs[ContextsTag].sClass);
  AssertPtrEquals(jInterp->coAlgs[ContextsTag].sClass, coAlg);
  AssertIntEquals(
    jInterp->coAlgs[ContextsTag].sClass->objectSize,
    sizeof(ContextObj)
  )
\stopCTest

\stopTestCase
\stopTestSuite


\starttyping
/******

// TODO move to context


void ignoreTest_defineFactorial(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  AssertPtrNotNull(coAlgs);
  Context* aCtx = createContext(anInterp);
  AssertPtrNotNull(aCtx);

  Text* factorialText = createTextFromArrayOfStrings(coAlgs, factorialStrs);
  AssertPtrNotNull(factorialText);

  CoAlgObj* factorialLoL = parseAllSymbols(factorialText);
  AssertPtrNotNull(factorialLoL);

  defineJoyLoL(anInterp->coAlgebras, "factorial", factorialLoL);
  freeText(factorialText);
}
******/
\stoptyping
