% A ConTeXt document [master document: joyLoLMinus.tex ]

\section[title=Symbols]

\setCHeaderStream{public}
\startCHeader

\stopCHeader

\startCCode
static void traceAction(
  ContextObj *aCtx,
  Symbol     *action,
  JObj       *aLoL
) {
  assert(aCtx);
  DEBUG(aCtx, "traceAction: %p [%s] %s %p\n",
    aCtx, action, getJObjName(aLoL), aLoL);

  printf("%s: ", action);
  printJObj(aLoL, "", 20);
  printf("\n");
}



void evalCommandInContext(
  ContextObj *aCtx,
  JObj       *command
) {
  assert(aCtx);
  
  DEBUG(aCtx, "evalCommandInContext > %p [%s] %p\n",
    aCtx, aCtx->name, command);
  //
  // push this command onto the top of the process stack
  //
  pushCtxProcess(aCtx, command);
  //
  while(aCtx->process) {
    //
    // ensure we have the most recent dictionary
    //
    SymbolTableObj *symbolTable = aCtx->symbolTable;
    assert(symbolTable);
    
    if (aCtx->tracingOn) {
      printf(
        "\n----------------------------------------------------\n"
      );
      printf(
        "ctx: %s(%s)\n",
        aCtx->name, symbolTable->name
      );
    }
    //
    // pop the next command off the process stack
    //
    command = popCtxProcess(aCtx);
    aCtx->command = command;
    //assert(command);
    //
    if (isCFunctionObj(command)) {
      assert(asCFunction(command));
      //
      // this is a normal CFunction
      // (this ONLY makes changes to the data and process stacks)
      //
      if (aCtx->tracingOn)
        traceAction(aCtx, "calling(c)", command);
      (asCFunction(command))(aCtx);
      //
    } else if (isCtxCFunctionObj(command)) {
        assert(asCtxCFunction(command));
        //
        // this is a CTX CFunction
        // (we allow it to change the current context
        //  in addition to any changes of the data and process stacks
        //  of either the old or new contexts)
        //
        if (aCtx->tracingOn) 
          traceAction(aCtx, "calling(c-ctx)", command);
        aCtx = (asCtxCFunction(command))(aCtx);
        assert(aCtx);
        //    
//    } else if (isAssertion(command)) {
//      //
//      // this is an assertion ...
//      //   ... so assert it 
//      //
//      if (aCtx->tracingOn) 
//        traceAction(aCtx, "asserting", command);
//      //
//      if (!evalAssertionInContext(aCtx, (AssertionObj*)command)) {
//        //
//        // this assertion failed... 
//        //   ... so report it
//        //
//        pushNullCtxData(aCtx);
//        pushOnTopCtxData(aCtx, command);
//        raiseException(aCtx,
//          "assertion failed"
//        );
//      }
    } else if (!isSymbolObj(command)) {
      //
      // if the command is not a Symbol ...
      //  ...  push it onto the top of the data stack
      //
      if (aCtx->tracingOn)
        traceAction(aCtx, "adding(nonSym)", command);
      pushCtxData(aCtx, command);
      //
   } else {
      //
      // if the command is a symbol ...
      //  ... look up the symbol's association in the dictionary
      //
      JObj* assoc = findSymbol(symbolTable, asSymbol(command));
      //
      if (!assoc) {
        //
        // if the association is empty.. push this symbol onto the top
        // of the data stack (re-evaluating this symbol would lead to an
        // infinite loop)
        //
        if (aCtx->tracingOn)
          traceAction(aCtx, "adding(noValue)", command);
        pushCtxData(aCtx, command);
        //
      } else if (isPairObj(assoc)) {
        //
        // if the association is a LoL.. push this LoL onto the top of the
        // process stack
        //
        if (aCtx->tracingOn) {
          traceAction(aCtx, "calling(joylol)", command);
          traceAction(aCtx, "evaluating",      assoc);
        }
        prependListCtxProcess(aCtx, copyLoL(assoc));
        //
      } else if (isCFunctionObj(assoc)) {
        //
        // if the association is a function.. call the function
        //
        assert(asCFunction(assoc));
        //
        // this is a normal CFunction
        //
        if (aCtx->tracingOn)
          traceAction(aCtx, "calling(c)", command);
        (asCFunction(assoc))(aCtx);
        //
      } else if (isCtxCFunctionObj(assoc)) {
        assert(asCtxCFunction(assoc));
        //
        // this is a CTX CFunction
        //
        if (aCtx->tracingOn) 
          traceAction(aCtx, "calling(c-ctx)", command);
        aCtx = (asCtxCFunction(assoc))(aCtx);
        assert(aCtx);
        //
      } else {
        //
        // if the association is NOT a PairAtom or Function...
        // ... push this new ATOM onto the top of the process stack
        //
        if (aCtx->tracingOn) {
          traceAction(aCtx, "calling(joylol)", command);
          traceAction(aCtx, "evaluating",      assoc);
        }
        pushCtxProcess(aCtx, assoc);
        //
      }
    }
    if (aCtx->tracingOn) {
      DEBUG(aCtx, "evalCommandInContext -> tracing%s\n", "");
      showCtxData(aCtx);
      showCtxProcess(aCtx);
      DEBUG(aCtx, "evalCommandInContext <- tracing%s\n", "");
    }
  } // aCtx->process is empty
  DEBUG(aCtx, "evalCommandInContext < %p %p\n", aCtx, command);
}

\stopCCode