% A ConTeXt document [master document: dictionaries.tex]

\section[title=Insert]

\startTestSuite[insertSymbol]

\setCHeaderStream{private}
\startCHeader
extern DictObj* insertSymbolRecurse(JoyLoLInterp* jInterp,
                                    DictObj* anAVLNode,
                                    Symbol* aSymbol);
\stopCHeader
\setCHeaderStream{public}

\startCCode
DictObj* insertSymbolRecurse(JoyLoLInterp* jInterp,
                             DictObj* anAVLNode,
                             Symbol* aSymbol) {
  if (!anAVLNode) return newDict(jInterp, aSymbol);
  Boolean debugFlag = FALSE;

  assert(jInterp);
  StringBufferObj *aStrBuf = 
    (debugFlag ? newStringBuffer(jInterp) : NULL);

  DEBUG(debugFlag, "\ninsertSymbol %p <%s>[%s] %ld:%zu\n",
        anAVLNode, anAVLNode->symbol, aSymbol,
        anAVLNode->balance, anAVLNode->height);

  DEBUG(debugFlag, "insertSymbol strncmp %d\n",
        strcmp(aSymbol, anAVLNode->symbol));

  int aStrCmp = strcmp(aSymbol, anAVLNode->symbol);
  if (aStrCmp < 0) {
    // aSymbol < anAVLNode->symbol // insert in LEFT subtree
    if (debugFlag) {
      printDicInto(jInterp, aStrBuf, anAVLNode);
      DEBUG(debugFlag, ">-insert LEFT subtree %p [%s] %ld:%zu=%zu %s\n",
            anAVLNode, aSymbol, anAVLNode->balance,
            anAVLNode->height, deepCalculateAVLNodeHeight(anAVLNode),
            getCString(jInterp, aStrBuf));
      strBufClose(jInterp, aStrBuf);
    }
    DictObj* leftResult =
      insertSymbolRecurse(jInterp, anAVLNode->left, aSymbol);
    assert(leftResult);
    if (!anAVLNode->left) {
      // we have inserted a new node ...
      // ... insert this new node into the doubly linked list
      //
      DictObj* oldPrevious               = anAVLNode->previous;
      assert(jInterp->dict.firstSymbol);
      if (oldPrevious) oldPrevious->next = leftResult;
      else jInterp->dict.firstSymbol     = leftResult;
      leftResult->next                   = anAVLNode;
      leftResult->previous               = oldPrevious;
      anAVLNode->previous                = leftResult;
      //
    }
    anAVLNode->left = leftResult;
    reCalculateAVLNodeHeightBalance(anAVLNode);
    if (debugFlag) {
      printDicInto(jInterp, aStrBuf, anAVLNode);
      DEBUG(debugFlag, "<-insert LEFT subtree %p [%s] %ld:%zu=%zu %s\n",
          anAVLNode, aSymbol, anAVLNode->balance,
          anAVLNode->height, deepCalculateAVLNodeHeight(anAVLNode),
          getCString(jInterp, aStrBuf));
      strBufClose(jInterp, aStrBuf);
    }
    //
    if (2 < anAVLNode->balance) {
      assert(anAVLNode->left);
      if (strcmp(aSymbol, anAVLNode->left->symbol) < 0) {
        anAVLNode = rotateLeftLeft(jInterp, anAVLNode);
      } else {
        anAVLNode = rotateLeftRight(jInterp, anAVLNode);
      }
    }
  } else if (0 < aStrCmp) {
    // aSymbol > anAVLNode->symbol // insert in RIGHT subtree
    if (debugFlag) {
      printDicInto(jInterp, aStrBuf, anAVLNode);
      DEBUG(debugFlag, ">-insert RIGHT subtree %p [%s] %ld:%zu=%zu %s\n",
          anAVLNode, aSymbol, anAVLNode->balance,
          anAVLNode->height, deepCalculateAVLNodeHeight(anAVLNode),
          getCString(jInterp, aStrBuf));
      strBufClose(jInterp, aStrBuf);
    }
    DictObj* rightResult =
      insertSymbolRecurse(jInterp, anAVLNode->right, aSymbol);
    if (!anAVLNode->right) {
      // we have inserted a new node ...
      // ... insert this new node into the doubly linked list
      //
      DictObj* oldNext               = anAVLNode->next;
      if (oldNext) oldNext->previous = rightResult;
      rightResult->previous          = anAVLNode;
      rightResult->next              = oldNext;
      anAVLNode->next                = rightResult;
      //
    }
    anAVLNode->right = rightResult;
    reCalculateAVLNodeHeightBalance(anAVLNode);
    if (debugFlag) {
      printDicInto(jInterp, aStrBuf, anAVLNode);
      DEBUG(FALSE, "<-insert RIGHT subtree %p [%s] %ld:%zu=%zu %s\n",
          anAVLNode, aSymbol, anAVLNode->balance,
          anAVLNode->height, deepCalculateAVLNodeHeight(anAVLNode),
          getCString(jInterp, aStrBuf));
      strBufClose(jInterp, aStrBuf);
    }
    //
    if (anAVLNode->balance < -2) {
      assert(anAVLNode->right);
      if (strcmp(aSymbol, anAVLNode->right->symbol) > 0) {
        anAVLNode = rotateRightRight(jInterp, anAVLNode);
      } else {
        anAVLNode = rotateRightLeft(jInterp, anAVLNode);
      }
    }
  } else {
    // aSymbol == anAVLNode->symbol // nothing to do...
    DEBUG(debugFlag,"symols equal <%s>[%s]\n",
          anAVLNode->symbol, aSymbol);
  }

  reCalculateAVLNodeHeightBalance(anAVLNode);
  return anAVLNode;
}
\stopCCode

\startCHeader
extern DictObj* insertSymbol(JoyLoLInterp* jInterp, Symbol* aSymbol);
\stopCHeader

\startCCode
DictObj* insertSymbol(JoyLoLInterp* jInterp, Symbol* aSymbol) {
  assert(aSymbol);
  assert(jInterp);

  // lazy initialization
  if (!jInterp->dict.root) {
    DictObj* firstNode = newDict(jInterp, aSymbol);
    jInterp->dict.root        = firstNode;
    jInterp->dict.firstSymbol = firstNode;
    return firstNode;
  }

  return insertSymbolRecurse(jInterp, jInterp->dict.root, aSymbol);
}
\stopCCode

\startTestCase[should insert Symbol In Dictionary]
\startCTest
  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;
  
  DictObj* aSimpleDic = newDict(jInterp, "aNodeSymbol");
  DictObj* aNewDic = insertSymbolRecurse(jInterp, aSimpleDic, "aNodeSymbol");
  AssertPtrNotNull(aNewDic);
  AssertPtrEquals(aSimpleDic, aNewDic);
  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[aNodeSymbol] l:(  ) r:(  ) ");
  strBufClose(jInterp, aStrBuf);
  AssertPtrNull(aNewDic->next);
  AssertPtrNull(aNewDic->previous);
  AssertIntTrue(jInterp->dict.firstSymbol != aNewDic);
  AssertIntTrue(jInterp->dict.firstSymbol != aSimpleDic);
\stopCTest
\stopTestCase

\startTestCase[should insert Symbol Not In Dictionary]
\startCTest
  DEBUG(FALSE, "\n%s insert many symbols %s", "---------", "---------");

  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  AssertPtrNotNull(aStrBuf);
  
  DictObj* aSimpleDic = newDict(jInterp, "20");
  jInterp->dict.root        = aSimpleDic;
  jInterp->dict.firstSymbol = aSimpleDic;

  DictObj* aNewDic = insertSymbolRecurse(jInterp, aSimpleDic, "15");
  AssertPtrNotNull(aNewDic);
  AssertPtrEquals(aSimpleDic, aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[20] l:( [15] l:(  ) r:(  )  ) r:(  ) ");
  strBufClose(jInterp, aStrBuf);
  //
  // test insertion on the left into doubly linked list
  //
  AssertPtrNotNull(aNewDic->previous);
  AssertPtrNull(aNewDic->next);
  AssertPtrEquals(jInterp->dict.firstSymbol, aNewDic->previous);
  AssertPtrEquals(jInterp->dict.firstSymbol->next, aNewDic);
  AssertPtrNull(jInterp->dict.firstSymbol->previous);
  AssertPtrNull(aNewDic->next);

  // should invoke an LL
  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "10");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [20] l:(  ) r:(  )  ) ");
  strBufClose(jInterp, aStrBuf);
  //
  // test insertion on the right into doubly linked list
  // as well as a rotate right
  //
  AssertPtrNotNull(aNewDic->previous);
  AssertPtrNotNull(aNewDic->next);
  AssertPtrEquals(jInterp->dict.firstSymbol, aNewDic->previous);
  AssertPtrEquals(jInterp->dict.firstSymbol->next, aNewDic);
  AssertStrEquals(jInterp->dict.firstSymbol->symbol, "10");
  AssertStrEquals(aNewDic->next->symbol, "20");
  AssertPtrEquals(aNewDic->next->previous, aNewDic);
  AssertPtrNull(aNewDic->next->next);

  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "30");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [20] l:(  ) r:( [30] l:(  ) r:(  )  )  ) ");
  strBufClose(jInterp, aStrBuf);
  
  // should invoke an RR
  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "35");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [30] l:( [20] l:(  ) r:(  )  ) r:( [35] l:(  ) r:(  )  )  ) ");
  strBufClose(jInterp, aStrBuf);

  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "25");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [30] l:( [20] l:(  ) r:( [25] l:(  ) r:(  )  )  ) r:( [35] l:(  ) r:(  )  )  ) ");
  strBufClose(jInterp, aStrBuf);

  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "23");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [30] l:( [23] l:( [20] l:(  ) r:(  )  ) r:( [25] l:(  ) r:(  )  )  ) r:( [35] l:(  ) r:(  )  )  ) ");
  strBufClose(jInterp, aStrBuf);
  
  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "22");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[23] l:( [15] l:( [10] l:(  ) r:(  )  ) r:( [20] l:(  ) r:( [22] l:(  ) r:(  )  )  )  ) r:( [30] l:( [25] l:(  ) r:(  )  ) r:( [35] l:(  ) r:(  )  )  ) ");
  strBufClose(jInterp, aStrBuf);
  
  // now try and find all of the symbols...
  DictObj* aNode = findSymbolRecurse(jInterp, aNewDic, "15");
  AssertPtrNotNull(aNode);
  AssertStrEquals(aNode->symbol, "15");

  aNode = findSymbolRecurse(jInterp, aNewDic, "20");
  AssertPtrNotNull(aNode);
  AssertStrEquals(aNode->symbol, "20");

  aNode = findSymbolRecurse(jInterp, aNewDic, "23");
  AssertPtrNotNull(aNode);
  AssertStrEquals(aNode->symbol, "23");

  checkAVLNode(jInterp, aNewDic, FALSE);
\stopCTest
\stopTestCase


\startTestCase[should insert Symbol LL]
\startCTest
  DEBUG(FALSE, "\n%s should invoke an LL %s\n", "---------", "---------");

  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  StringBufferObj *aStrBuf = newStringBuffer(jInterp);
  AssertPtrNotNull(aStrBuf);
  
  DictObj* aSimpleDic = newDict(jInterp,"20");
  jInterp->dict.root        = aSimpleDic;
  jInterp->dict.firstSymbol = aSimpleDic;

  DictObj* aNewDic = insertSymbolRecurse(jInterp, aSimpleDic, "15");
  AssertPtrNotNull(aNewDic);
  AssertPtrEquals(aSimpleDic, aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[20] l:( [15] l:(  ) r:(  )  ) r:(  ) ");
  strBufClose(jInterp, aStrBuf);
  
  // should invoke an LL
  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "10");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [20] l:(  ) r:(  )  ) ");
  strBufClose(jInterp, aStrBuf);
\stopCTest
\stopTestCase

\startTestCase[should insert Symbol RR]
\startCTest
  DEBUG(FALSE, "\n%s should invoke an RR %s\n", "---------", "---------");

  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  StringBufferObj* aStrBuf = newStringBuffer(jInterp);
  AssertPtrNotNull(aStrBuf);
  
  DictObj* aSimpleDic = newDict(jInterp,"20");
  jInterp->dict.root        = aSimpleDic;
  jInterp->dict.firstSymbol = aSimpleDic;

  DictObj* aNewDic = insertSymbolRecurse(jInterp, aSimpleDic, "25");
  AssertPtrNotNull(aNewDic);
  AssertPtrEquals(aSimpleDic, aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[20] l:(  ) r:( [25] l:(  ) r:(  )  ) ");
  strBufClose(jInterp, aStrBuf);
  
  // should invoke an RR
  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "30");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[25] l:( [20] l:(  ) r:(  )  ) r:( [30] l:(  ) r:(  )  ) ");
  strBufClose(jInterp, aStrBuf);
  
  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "35");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[25] l:( [20] l:(  ) r:(  )  ) r:( [30] l:(  ) r:( [35] l:(  ) r:(  )  )  ) ");
  strBufClose(jInterp, aStrBuf);
\stopCTest
\stopTestCase

\startTestCase[should insert Symbol LR]
\startCTest
  DEBUG(FALSE, "\n%s should invoke an LR %s\n", "---------", "---------");

  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  StringBufferObj* aStrBuf = newStringBuffer(jInterp);
  AssertPtrNotNull(aStrBuf);
  
  DictObj* aSimpleDic = newDict(jInterp,"20");
  jInterp->dict.root        = aSimpleDic;
  jInterp->dict.firstSymbol = aSimpleDic;

  DictObj* aNewDic = insertSymbolRecurse(jInterp, aSimpleDic, "15");
  AssertPtrNotNull(aNewDic);
  AssertPtrEquals(aSimpleDic, aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[20] l:( [15] l:(  ) r:(  )  ) r:(  ) ");
  strBufClose(jInterp, aStrBuf);
  
  // should invoke an LR
  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "17");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[17] l:( [15] l:(  ) r:(  )  ) r:( [20] l:(  ) r:(  )  ) ");
  strBufClose(jInterp, aStrBuf);
\stopCTest
\stopTestCase


\startTestCase[should insert Symbol RL]
\startCTest
  DEBUG(FALSE, "\n%s should invoke an RL %s\n", "---------", "---------");

  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  StringBufferObj* aStrBuf = newStringBuffer(jInterp);
  AssertPtrNotNull(aStrBuf);
  
  DictObj* aSimpleDic = newDict(jInterp,"20");
  jInterp->dict.root        = aSimpleDic;
  jInterp->dict.firstSymbol = aSimpleDic;

  DictObj* aNewDic = insertSymbolRecurse(jInterp, aSimpleDic, "25");
  AssertPtrNotNull(aNewDic);
  AssertPtrEquals(aSimpleDic, aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[20] l:(  ) r:( [25] l:(  ) r:(  )  ) ");
  strBufClose(jInterp, aStrBuf);
  
  // should invoke an RL
  aNewDic = insertSymbolRecurse(jInterp, aNewDic, "22");
  AssertPtrNotNull(aNewDic);
  printDicInto(jInterp, aStrBuf, aNewDic);
  AssertStrEquals(getCString(jInterp, aStrBuf),
  "[22] l:( [20] l:(  ) r:(  )  ) r:( [25] l:(  ) r:(  )  ) ");
  strBufClose(jInterp, aStrBuf);
\stopCTest
\stopTestCase

\startTestCase[should insert Symbol randomly]
\startCTest

  srand(time(NULL));

  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  DictObj* avlDic = newDict(jInterp,"0");
  jInterp->dict.root        = avlDic;
  jInterp->dict.firstSymbol = avlDic;

  for (int i = 0; i < 1000; i++) {
    char itoa[100];
    sprintf(itoa, "%d", rand() % 100);
    avlDic = insertSymbolRecurse(jInterp, avlDic, itoa);
  }
  checkAVLNode(jInterp, avlDic, FALSE);

//  StringBufferObj* aStrBuf = newStringBuffer(jInterp);
//  printDictInto(aStrBuf, avlDic);
//  printf("%s\n", getCString(jInterp, aStrBuf));
//  printf("avl node height: %zu\n", deepCalculateAVLNodeHeight(avlDic));
//  printf("avl node height: %zu\n", avlDic->height);
//  printf("avl node balance: %d\n", avlDic->balance);
\stopCTest
\stopTestCase

\startTestCase[should insert Symbol linearly]
\startCTest
  AssertPtrNotNull(jInterp);
  // ensure the global dictionary is empty
  jInterp->dict.root        = NULL;
  jInterp->dict.firstSymbol = NULL;

  DictObj* avlDic = newDict(jInterp,"10");
  jInterp->dict.root        = avlDic;
  jInterp->dict.firstSymbol = avlDic;

  for (int i = 10; i < 100; i++) {
    char itoa[100];
    sprintf(itoa, "%d", i);
    avlDic = insertSymbolRecurse(jInterp, avlDic, itoa);
  }
  checkAVLNode(jInterp, avlDic, FALSE);

//  StringBufferObj* aStrBuf = newStringBuffer(jInterp);
//  printDictInto(aStrBuf, avlDic);
//  printf("%s\n", getCString(jInterp, aStrBuf));
//  printf("avl node height: %zu\n", deepCalculateAVLNodeHeight(avlDic));
//  printf("avl node height: %zu\n", avlDic->height);
//  printf("avl node balance: %d\n", avlDic->balance);

  AssertIntEquals(avlDic->height, deepCalculateAVLNodeHeight(avlDic));
  AssertIntEquals(avlDic->height, 8);
  AssertIntEquals(avlDic->balance, -2);
\stopCTest
\stopTestCase
\stopTestSuite