% A ConTeXt document [master document: dictionaries.tex]

\section[title=Code]
\setCHeaderStream{public}

\dependsOn[jInterps]

\startCHeader
typedef struct dictionaries_object_struct DictObj;

typedef struct dictionaries_object_struct {
  CoAlgObj  super;
  Symbol*   symbol;
  CoAlgObj* preObs;
  CoAlgObj* value;
  CoAlgObj* postObs;
  DictObj*  left;
  DictObj*  right;
  DictObj*  previous;
  DictObj*  next;
  size_t    height;
  long      balance;
} DictObj;
\stopCHeader

\startTestSuite[registerDictionaries]

\setCHeaderStream{private}
\startCHeader
Boolean registerDictionaries(JoyLoLInterp *jInterp);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean registerDictionaries(JoyLoLInterp *jInterp) {
  assert(jInterp);
  
  CoAlgebra* theCoAlg    = (CoAlgebra*) calloc(1, sizeof(CoAlgebra));
  assert(theCoAlg);
  
  theCoAlg->name         = "Dictionaries";
  theCoAlg->objectSize   = sizeof(DictObj);
  theCoAlg->registerFunc = registerDictionaries;
  theCoAlg->equalityFunc = NULL;
  theCoAlg->printFunc    = NULL;
  theCoAlg->coAlgData    = NULL;
  size_t tag = registerCoAlgebra(jInterp, theCoAlg);
  
  // do a sanity check...
  assert(tag == DictionariesTag);
  assert(jInterp->coAlgs[tag].sClass);
  
  registerDictionaryWords(jInterp);
  
  return TRUE;
}
\stopCCode

\startTestCase[should register the Dictionaries coAlg]

\startCTest
  // CTestsSetup has already created a jInterp
  // and run regiserDictionaries
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs[DictionariesTag].sClass);
  CoAlgebra *coAlg = jInterp->coAlgs[DictionariesTag].sClass;
  AssertIntTrue(registerDictionaries(jInterp));
  AssertPtrNotNull(jInterp->coAlgs[DictionariesTag].sClass);
  AssertPtrEquals(jInterp->coAlgs[DictionariesTag].sClass, coAlg);
  AssertIntEquals(
    jInterp->coAlgs[DictionariesTag].sClass->objectSize, 
    sizeof(DictObj)
  );
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[newDict]

\startCHeader
extern DictObj *newDict(JoyLoLInterp *jInterp, Symbol *aSym);
\stopCHeader

\setCHeaderStream{private}
\startCHeader
#define asSymbol(aNode)   ((DictObj*)(aNode))->symbol
#define asPreObs(aNode)   ((DictObj*)(aNode))->preObs
#define asValue(aNode)    ((DictObj*)(aNode))->value
#define asPostObs(aNode)  ((DictObj*)(aNode))->postObs
#define asLeft(aNode)     ((DictObj*)(aNode))->left
#define asRight(aNode)    ((DictObj*)(aNode))->right
#define asPrevious(aNode) ((DictObj*)(aNode))->previous
#define asNext(aNode)     ((DictObj*)(aNode))->next
#define asHeight(aNode)   ((DictObj*)(aNode))->height
#define asBalance(aNode)  ((DictObj*)(aNode))->balance
\stopCHeader
\setCHeaderStream{public}

\startCCode
// We implement our dictionary as an AVL binary tree using AVLNodes.
//
// Our implementation is inspired by:
// The Crazy Programmer's "Program for AVL Tree in C" (Neeraj Mishra)
// http://www.thecrazyprogrammer.com/2014/03/c-program-for-avl-tree-implementation.html
// and by:
// Jianye Hao's CSC2100B Tutorial 4 "Binary and AVL Trees in C"
// https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu4.pdf
//
// At the moment we only insert and search (we never delete).
//
// ANY AVLTree node can be the root of a new dictionary.
//

DictObj *newDict(JoyLoLInterp *jInterp, Symbol *aSym) {
  assert(jInterp);
  assert(jInterp->coAlgs);
  assert(DictionariesTag < jInterp->numCoAlgs);
  assert(jInterp->coAlgs[DictionariesTag].sClass);
  
  assert(aSym);
  
  DEBUG(FALSE, "newAVLNode [%s]\n", aSym);
  CoAlgObj* newNode   = newObject(jInterp, DictionariesTag);
  asSymbol(newNode)   = strdup(aSym);
  asPreObs(newNode)   = NULL;
  asValue(newNode)    = NULL;
  asPostObs(newNode)  = NULL;
  asLeft(newNode)     = NULL;
  asRight(newNode)    = NULL;
  asPrevious(newNode) = NULL;
  asNext(newNode)     = NULL;
  asHeight(newNode)   = 1;
  asBalance(newNode)  = 0;
  return (DictObj*)newNode;
}
\stopCCode

\startTestCase[should add a new dict object (AVL node)]

\startCTest
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs[DictionariesTag].sClass);

  DictObj* aNode = newDict(jInterp, "aNodeSymbol");
  AssertPtrNotNull(aNode);
  AssertPtrNotNull(asSymbol(aNode));
  AssertStrEquals(asSymbol(aNode), "aNodeSymbol");
  AssertPtrNull(asValue(aNode));
  AssertPtrNull(asLeft(aNode));
  AssertPtrNull(asRight(aNode));
  AssertPtrNull(asPrevious(aNode));
  AssertPtrNull(asNext(aNode));
  AssertIntEquals(asHeight(aNode), 1);
  AssertIntEquals(asBalance(aNode), 0);
\stopCTest
\stopTestCase
\stopTestSuite

\starttyping

extern AVLNode* findSymbol(Dictionary* aDic, const char* aSymbol);

extern AVLNode* findLUBSymbol(Dictionary* aDic, const char* aSymbol);

extern AVLNode* insertSymbol(Dictionary* aDic, const char* aSymbol);

extern AVLNode* createSymbol(Dictionary* aDic, const char* aSymbol);

extern PairAtom* createAtom(CoAlgebras* coAlgs, AVLNode* anAVLNode);

extern PairAtom* getSymbol(CoAlgebras* coAlgs,
                           Dictionary* aDic,
                           const char* aSymbol);

extern void listDefinitions(Dictionary* aDic, FILE* outFile);

#endif
\stoptyping

\starttyping
#ifndef JOYLOL_DICTIONARY_PRIVATE_H
#define JOYLOL_DICTIONARY_PRIVATE_H

extern AVLNode* findSymbolRecurse(Dictionary* aDic,
                                  AVLNode* anAVLNode,
                                  const char* aSymbol);

extern AVLNode* findLUBSymbolRecurse(Dictionary* aDic,
                                     AVLNode* anAVLNode,
                                     const char* aSymbol);

extern AVLNode* insertSymbolRecurse(Dictionary* aDic,
                                    AVLNode* anAVLNode,
                                    const char* aSymbol);


extern void reCalculateAVLNodeHeightBalance(AVLNode* avlNode);
extern size_t deepCalculateAVLNodeHeight(AVLNode* avlNode);

extern AVLNode* rotateLeft(AVLNode* anAVLNode);
extern AVLNode* rotateRight(AVLNode* anAVLNode);

extern AVLNode* rotateLeftLeft(AVLNode* anAVLNode);
extern AVLNode* rotateLeftRight(AVLNode* anAVLNode);
extern AVLNode* rotateRightLeft(AVLNode* anAVLNode);
extern AVLNode* rotateRightRight(AVLNode* anAVLNode);

extern size_t checkAVLNode(AVLNode* anAVLNode, size_t debugFlag);
extern char* printDictionary(AVLNode* anAVLNode);

#endif
\stoptyping

\starttyping
//dictionary.c
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/lists.h"
#include "joyLoL/dictionary.h"
#include "joyLoL/dictionary_private.h"
#include "joyLoL/printer.h"

AVLNode* createSymbol(Dictionary* aDic, const char* aSymbol) {
  assert(aDic);
  if (!aSymbol) return NULL;
  AVLNode* aSym = findSymbol(aDic, aSymbol);
  if (!aSym) {
    aDic->dicRoot = insertSymbol(aDic, aSymbol);
    aSym = findSymbol(aDic, aSymbol);
  }
  return aSym;
}

PairAtom* getSymbol(CoAlgebras* coAlgs,
                    Dictionary* aDic,
                    const char* aSymbol) {
  AVLNode* aSym = createSymbol(aDic, aSymbol);
  return createAtom(coAlgs, aSym);
}

PairAtom* createAtom(CoAlgebras* coAlgs, AVLNode* anAVLNode) {
  assert(anAVLNode);
  assert(coAlgs);
  return newSymbol(coAlgs, anAVLNode->symbol);
}

void reCalculateAVLNodeHeightBalance(AVLNode* anAVLNode) {
  if (!anAVLNode) return;

  if (!anAVLNode->left && !anAVLNode->right) {
    anAVLNode->height  = 1;
    anAVLNode->balance = 0;
  } else if (!anAVLNode->left) {
    anAVLNode->height  =  1 + anAVLNode->right->height;
    anAVLNode->balance = -1 - anAVLNode->right->height;
  } else if (!anAVLNode->right) {
    anAVLNode->height  = 1 + anAVLNode->left->height;
    anAVLNode->balance = 1 + anAVLNode->left->height;
  } else if (anAVLNode->left->height < anAVLNode->right->height) {
    anAVLNode->height  = 1 + anAVLNode->right->height;
    anAVLNode->balance = anAVLNode->left->height - anAVLNode->right->height;
  } else {
    anAVLNode->height  = 1 + anAVLNode->left->height;
    anAVLNode->balance = anAVLNode->left->height - anAVLNode->right->height;
  }
}

size_t deepCalculateAVLNodeHeight(AVLNode* anAVLNode) {
  if (!anAVLNode) return 0;

  size_t leftHeight = 1 + deepCalculateAVLNodeHeight(anAVLNode->left);
  size_t rightHeight = 1 + deepCalculateAVLNodeHeight(anAVLNode->right);

  if (leftHeight > rightHeight) return leftHeight;
  return rightHeight;
}

void listDefinitions(Dictionary* aDic, FILE* outFile) {
  AVLNode* curNode = aDic->firstSymbol;
  while(curNode) {
    if (curNode->value) {
      fprintf(outFile,"%s == %s\n",
              curNode->symbol, printLoL(curNode->value));
    }
    curNode = curNode->next;
  }
}

\stoptyping

\starttyping
//check
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/dictionary.h"
#include "joyLoL/dictionary_private.h"

// We implement our dictionary as an AVL binary tree using PairAtoms.
//
// Our implementation is inspired by:
// The Crazy Programmer's "Program for AVL Tree in C" (Neeraj Mishra)
// http://www.thecrazyprogrammer.com/2014/03/c-program-for-avl-tree-implementation.html
// and by:
// Jianye Hao's CSC2100B Tutorial 4 "Binary and AVL Trees in C"
// https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu4.pdf
//
// At the moment we only insert and search (we never delete).
//
// ANY AVLTree node can be the root of a new dictionary.
//

size_t checkAVLNode(AVLNode* anAVLNode, size_t debugFlag) {
  if (!anAVLNode) return TRUE;

  DEBUG(debugFlag, "checkAVLNode %p %ld:%zu=%zu %s\n",
        anAVLNode, anAVLNode->balance, anAVLNode->height,
        deepCalculateAVLNodeHeight(anAVLNode),
        printDictionary(anAVLNode));

  if (anAVLNode->left) {
    DEBUG(debugFlag, "car>-checkAVLNode %p\n", anAVLNode);
    checkAVLNode(anAVLNode->left, debugFlag);
    assert(0 < strcmp(anAVLNode->symbol,
                      anAVLNode->left->symbol));
    DEBUG(debugFlag, "car<-checkAVLNode %p\n", anAVLNode);
  }

  if (anAVLNode->right) {
    DEBUG(debugFlag, "cdr>-checkAVLNode %p\n", anAVLNode);
    checkAVLNode(anAVLNode->right, debugFlag);
    assert(strcmp(anAVLNode->symbol,
                  anAVLNode->right->symbol) < 0);
    DEBUG(debugFlag, "cdr<-checkAVLNode %p\n", anAVLNode);
  }

  assert(anAVLNode->height == deepCalculateAVLNodeHeight(anAVLNode));

  return TRUE;
}

size_t printDicSize(AVLNode* anAVLNode) {
  if (!anAVLNode) return 0;
  return printDicSize(anAVLNode->left)
    + printDicSize(anAVLNode->right)
    + strlen(anAVLNode->symbol) + 20;
}

void printDicInto(AVLNode* anAVLNode, char* buffer, size_t bufferSize) {
  if (!anAVLNode) return;
  strcat(buffer, "[");
  strcat(buffer, anAVLNode->symbol);
  strcat(buffer, "] l:( ");
  printDicInto(anAVLNode->left, buffer, bufferSize);
  strcat(buffer, " ) r:( ");
  printDicInto(anAVLNode->right, buffer, bufferSize);
  strcat(buffer, " ) ");
}

char* printDictionary(AVLNode* anAVLNode) {
  size_t bufferSize = printDicSize(anAVLNode) + 10;
  char* buffer = (char*) calloc(bufferSize, sizeof(char));
  assert(buffer);
  printDicInto(anAVLNode, buffer, bufferSize);
  buffer[strlen(buffer)-1] = 0;
  return buffer;
}
\stoptyping

\starttyping
// find.c
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/lists.h"
#include "joyLoL/dictionary.h"
#include "joyLoL/dictionary_private.h"

// We implement our dictionary as an AVL binary tree using PairAtoms.
//
// Our implementation is inspired by:
// The Crazy Programmer's "Program for AVL Tree in C" (Neeraj Mishra)
// http://www.thecrazyprogrammer.com/2014/03/c-program-for-avl-tree-implementation.html
// and by:
// Jianye Hao's CSC2100B Tutorial 4 "Binary and AVL Trees in C"
// https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu4.pdf
//
// At the moment we only insert and search (we never delete).
//
// ANY AVLTree node can be the root of a new dictionary.
//

AVLNode* findSymbolRecurse(Dictionary* aDic,
                           AVLNode* anAVLNode,
                           const char* aSymbol) {
  if (!anAVLNode) return NULL;
  int aStrCmp = strcmp(aSymbol, anAVLNode->symbol);
  if (aStrCmp < 0) {
    // aSymbol < anAVLNode->symbol // search the LEFT subtree
    return findSymbolRecurse(aDic, anAVLNode->left, aSymbol);
  } else if (0 < aStrCmp) {
    // aSymbol > anAVLNode->symbol // search the RIGHT subtree
    return findSymbolRecurse(aDic, anAVLNode->right, aSymbol);
  } else {
    // aSymbol == anAVLNode->symbol // return this association pair
    return anAVLNode;
  }
  return NULL;
}

AVLNode* findSymbol(Dictionary* aDic, const char* aSymbol) {
  if (!aSymbol) return NULL;
  assert(aDic);
  return findSymbolRecurse(aDic, aDic->dicRoot, aSymbol);
}

AVLNode* findLUBSymbolRecurse(Dictionary* aDic,
                              AVLNode* anAVLNode,
                              const char* aSymbol) {
  assert(aDic);
  if (!anAVLNode) return aDic->firstSymbol;

  DEBUG(FALSE, "findLUBSymbol %p {%s}[%s] %p %p\n",
        anAVLNode, anAVLNode->symbol, aSymbol,
        anAVLNode->left, anAVLNode->right);

  int aStrCmp = strcmp(aSymbol, anAVLNode->symbol);
  DEBUG(FALSE, "findLUBSymbol cmp: %d\n", aStrCmp);
  if (aStrCmp < 0) {
    // aSymbol < anAVLNode->symbol
    // the current anAVLNode->symbol is an upper bound
    // search the LEFT subtree for a smaller upper bound
    if (anAVLNode->left) {
      AVLNode* aNode = findLUBSymbolRecurse(aDic, anAVLNode->left, aSymbol);
      if (!aNode) {
        // there is nothing in the LEFT subtree which is an upper bound
        // so return this node.
        return anAVLNode;
      }
      // we have found a smaller upper bound... so return it
      return aNode;
    }
    // there is nothing less than this node so return this node
    return anAVLNode;
    //
  } else if (0 < aStrCmp) {
    // anAVLNode->symbol < symbol
    // the current anAVLNode->symbol is a lower bound
    // search the RIGHT subtree for any upper bounds
    if (anAVLNode->right) {
      return findLUBSymbolRecurse(aDic, anAVLNode->right, aSymbol);
    }
    // there is nothing greater than this node so return NULL to signal failure
    return NULL;
    //
  } else {
    // aSymbol == anAVLNode->symbol
    // the current anAVLNode->symbol is the lowest possible upper bound
    // return it
    return anAVLNode;
    //
  }
  return aDic->firstSymbol;
}

AVLNode* findLUBSymbol(Dictionary* aDic, const char* aSymbol) {
  assert(aDic);
  if (!aSymbol) return aDic->firstSymbol;
  return findLUBSymbolRecurse(aDic, aDic->dicRoot, aSymbol);
}

\stoptyping

\starttyping
//insert.c
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/lists.h"
#include "joyLoL/dictionary.h"
#include "joyLoL/dictionary_private.h"

// We implement our dictionary as an AVL binary tree using AVLNodes.
//
// Our implementation is inspired by:
// The Crazy Programmer's "Program for AVL Tree in C" (Neeraj Mishra)
// http://www.thecrazyprogrammer.com/2014/03/c-program-for-avl-tree-implementation.html
// and by:
// Jianye Hao's CSC2100B Tutorial 4 "Binary and AVL Trees in C"
// https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu4.pdf
//
// At the moment we only insert and search (we never delete).
//
// ANY AVLTree node can be the root of a new dictionary.
//

AVLNode* insertSymbolRecurse(Dictionary* aDic,
                             AVLNode* anAVLNode,
                             const char* aSymbol) {
  if (!anAVLNode) return newAVLNode(aSymbol);

  assert(aDic);

  DEBUG(FALSE, "\ninsertSymbol %p <%s>[%s] %ld:%zu\n",
        anAVLNode, anAVLNode->symbol, aSymbol,
        anAVLNode->balance, anAVLNode->height);

  DEBUG(FALSE, "insertSymbol strncmp %d\n",
        strcmp(aSymbol, anAVLNode->symbol));

  int aStrCmp = strcmp(aSymbol, anAVLNode->symbol);
  if (aStrCmp < 0) {
    // aSymbol < anAVLNode->symbol // insert in LEFT subtree
    DEBUG(FALSE, ">-insert LEFT subtree %p [%s] %ld:%zu=%zu %s\n",
          anAVLNode, aSymbol, anAVLNode->balance,
          anAVLNode->height, deepCalculateAVLNodeHeight(anAVLNode),
          printDictionary(anAVLNode));
    AVLNode* leftResult =
      insertSymbolRecurse(aDic, anAVLNode->left, aSymbol);
    assert(leftResult);
    if (!anAVLNode->left) {
      // we have inserted a new node ...
      // ... insert this new node into the doubly linked list
      //
      AVLNode* oldPrevious               = anAVLNode->previous;
      assert(aDic->firstSymbol);
      if (oldPrevious) oldPrevious->next = leftResult;
      else aDic->firstSymbol             = leftResult;
      leftResult->next                   = anAVLNode;
      leftResult->previous               = oldPrevious;
      anAVLNode->previous                = leftResult;
      //
    }
    anAVLNode->left = leftResult;
    reCalculateAVLNodeHeightBalance(anAVLNode);
    DEBUG(FALSE, "<-insert LEFT subtree %p [%s] %ld:%zu=%zu %s\n",
          anAVLNode, aSymbol, anAVLNode->balance,
          anAVLNode->height, deepCalculateAVLNodeHeight(anAVLNode),
          printDictionary(anAVLNode));
    //
    if (2 < anAVLNode->balance) {
      assert(anAVLNode->left);
      if (strcmp(aSymbol, anAVLNode->left->symbol) < 0) {
        anAVLNode = rotateLeftLeft(anAVLNode);
      } else {
        anAVLNode = rotateLeftRight(anAVLNode);
      }
    }
  } else if (0 < aStrCmp) {
    // aSymbol > anAVLNode->symbol // insert in RIGHT subtree
    DEBUG(FALSE, ">-insert RIGHT subtree %p [%s] %ld:%zu=%zu %s\n",
        anAVLNode, aSymbol, anAVLNode->balance,
        anAVLNode->height, deepCalculateAVLNodeHeight(anAVLNode),
        printDictionary(anAVLNode));
    AVLNode* rightResult =
      insertSymbolRecurse(aDic, anAVLNode->right, aSymbol);
    if (!anAVLNode->right) {
      // we have inserted a new node ...
      // ... insert this new node into the doubly linked list
      //
      AVLNode* oldNext               = anAVLNode->next;
      if (oldNext) oldNext->previous = rightResult;
      rightResult->previous          = anAVLNode;
      rightResult->next              = oldNext;
      anAVLNode->next                = rightResult;
      //
    }
    anAVLNode->right = rightResult;
    reCalculateAVLNodeHeightBalance(anAVLNode);
    DEBUG(FALSE, "<-insert RIGHT subtree %p [%s] %ld:%zu=%zu %s\n",
        anAVLNode, aSymbol, anAVLNode->balance,
        anAVLNode->height, deepCalculateAVLNodeHeight(anAVLNode),
        printDictionary(anAVLNode));
    //
    if (anAVLNode->balance < -2) {
      assert(anAVLNode->right);
      if (strcmp(aSymbol, anAVLNode->right->symbol) > 0) {
        anAVLNode = rotateRightRight(anAVLNode);
      } else {
        anAVLNode = rotateRightLeft(anAVLNode);
      }
    }
  } else {
    // aSymbol == anAVLNode->symbol // nothing to do...
    DEBUG(FALSE,"symols equal <%s>[%s]\n",
          anAVLNode->symbol, aSymbol);
  }

  reCalculateAVLNodeHeightBalance(anAVLNode);
  return anAVLNode;
}

AVLNode* insertSymbol(Dictionary* aDic, const char* aSymbol) {
  assert(aSymbol);
  assert(aDic);

  // lazy initialization
  if (!aDic->dicRoot) {
    AVLNode* firstNode = newAVLNode(aSymbol);
    aDic->dicRoot     = firstNode;
    aDic->firstSymbol = firstNode;
    return firstNode;
  }

  return insertSymbolRecurse(aDic, aDic->dicRoot, aSymbol);
}

\stoptyping

\starttyping
//rotate.c
#include <assert.h>

#include "joyLoL/macros.h"
#include "joyLoL/dictionary.h"
#include "joyLoL/dictionary_private.h"

// We implement our dictionary as an AVL binary tree using AVLNodes.
//
// Our implementation is inspired by:
// The Crazy Programmer's "Program for AVL Tree in C" (Neeraj Mishra)
// http://www.thecrazyprogrammer.com/2014/03/c-program-for-avl-tree-implementation.html
// and by:
// Jianye Hao's CSC2100B Tutorial 4 "Binary and AVL Trees in C"
// https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu4.pdf
//
// At the moment we only insert and search (we never delete).
//
// ANY AVLTree node can be the root of a new dictionary.
//

AVLNode* rotateLeft(AVLNode* anAVLNode) {
  DEBUG(FALSE, ">-rotateLeft %p %ld:%zu=%zu %s\n",
        anAVLNode, anAVLNode->balance, anAVLNode->height,
        deepCalculateAVLNodeHeight(anAVLNode),
        printDictionary(anAVLNode));
  assert(anAVLNode->right);

  AVLNode* newRoot = anAVLNode->right;
  anAVLNode->right = newRoot->left;
  newRoot->left    = anAVLNode;

  reCalculateAVLNodeHeightBalance(anAVLNode);
  reCalculateAVLNodeHeightBalance(newRoot);

  DEBUG(FALSE, "<o-rotateLeft %p %ld:%zu=%zu %s\n",
        anAVLNode, anAVLNode->balance, anAVLNode->height,
        deepCalculateAVLNodeHeight(anAVLNode),
        printDictionary(anAVLNode));
  DEBUG(FALSE, "<n-rotateLeft %p %ld:%zu=%zu %s\n",
        newRoot, newRoot->balance, newRoot->height,
        deepCalculateAVLNodeHeight(newRoot),
        printDictionary(newRoot));
  assert(anAVLNode->height == deepCalculateAVLNodeHeight(anAVLNode));
  assert(newRoot->height == deepCalculateAVLNodeHeight(newRoot));
  return newRoot;
}

AVLNode* rotateRight(AVLNode* anAVLNode) {
  DEBUG(FALSE, ">-rotateRight %p %ld:%zu=%zu %s\n",
        anAVLNode, anAVLNode->balance, anAVLNode->height,
        deepCalculateAVLNodeHeight(anAVLNode),
        printDictionary(anAVLNode));
  assert(anAVLNode->left);

  AVLNode* newRoot = anAVLNode->left;
  anAVLNode->left = newRoot->right;
  newRoot->right  = anAVLNode;

  reCalculateAVLNodeHeightBalance(anAVLNode);
  reCalculateAVLNodeHeightBalance(newRoot);

  DEBUG(FALSE, "<o-rotateRight %p %ld:%zu=%zu %s\n",
        anAVLNode, anAVLNode->balance, anAVLNode->height,
        deepCalculateAVLNodeHeight(anAVLNode),
        printDictionary(anAVLNode));
  DEBUG(FALSE, "<n-rotateRight %p %ld:%zu=%zu %s\n",
        newRoot, newRoot->balance, newRoot->height,
        deepCalculateAVLNodeHeight(newRoot),
        printDictionary(newRoot));
  assert(anAVLNode->height == deepCalculateAVLNodeHeight(anAVLNode));
  assert(newRoot->height == deepCalculateAVLNodeHeight(newRoot));
  return newRoot;
}

AVLNode* rotateLeftLeft(AVLNode* anAVLNode) {
  DEBUG(FALSE, "LL %p %s\n", anAVLNode, printDictionary(anAVLNode));
  return rotateRight(anAVLNode);
}

AVLNode* rotateLeftRight(AVLNode* anAVLNode) {
  DEBUG(FALSE, "0-LR %p %s\n", anAVLNode, printDictionary(anAVLNode));
  anAVLNode->left = rotateLeft(anAVLNode->left);
  DEBUG(FALSE, "1-LR %p %s\n", anAVLNode, printDictionary(anAVLNode));
  return rotateRight(anAVLNode);
}

AVLNode* rotateRightLeft(AVLNode* anAVLNode) {
  DEBUG(FALSE, "0-RL %p %s\n", anAVLNode, printDictionary(anAVLNode));
  anAVLNode->right = rotateRight(anAVLNode->right);
  DEBUG(FALSE, "1-RL %p %s\n", anAVLNode, printDictionary(anAVLNode));
  return rotateLeft(anAVLNode);
}

AVLNode* rotateRightRight(AVLNode* anAVLNode) {
  DEBUG(FALSE, "RR %p %s\n", anAVLNode, printDictionary(anAVLNode));
  return rotateLeft(anAVLNode);
}

\stoptyping

\starttyping
// specs
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "CuTest.h"

#include "joyLoL/macros.h"
#include "joyLoL/coAlg/coAlgs.h"
#include "joyLoL/lists.h"
#include "joyLoL/dictionary.h"
#include "joyLoL/dictionary_private.h"
#include "joyLoL/printer.h"

// suiteName: - Dictionary tests -

void Test_findSymbolInEmptyDictionary(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  CuAssertPtrNull(tc, findSymbolRecurse(aDic, NULL, "aSymbol"));
}

void Test_findSymbolInNonEmptyDictionary(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  AVLNode* aNode = newAVLNode("aNodeSymbol");
  CuAssertPtrNotNull(tc, aNode);
  AVLNode* foundAPair = findSymbolRecurse(aDic, aNode, "aNodeSymbol");
  CuAssertPtrNotNull(tc, foundAPair);
  CuAssertStrEquals(tc, foundAPair->symbol, "aNodeSymbol");
}

void Test_findSymbolNotInDictionary(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  AVLNode* aSimpleDic = newAVLNode("aNodeSymbol");
  CuAssertPtrNotNull(tc, aSimpleDic);
  CuAssertPtrNull(tc, findSymbolRecurse(aDic, aSimpleDic, "aSymbol"));
}

void Test_AVLNodeHeight(CuTest* tc) {
  AVLNode* aNode = newAVLNode("20");
  CuAssertPtrNotNull(tc, aNode);
  CuAssertStrEquals(tc, printDictionary(aNode),
  "[20] l:(  ) r:(  )");

  CuAssertIntEquals(tc, aNode->height, 1);
  reCalculateAVLNodeHeightBalance(aNode);
  CuAssertIntEquals(tc, aNode->height, 1);
  CuAssertIntEquals(tc, aNode->balance, 0);

  aNode->left = newAVLNode("15");
  CuAssertStrEquals(tc, printDictionary(aNode),
  "[20] l:( [15] l:(  ) r:(  )  ) r:(  )");
  reCalculateAVLNodeHeightBalance(aNode);
  CuAssertIntEquals(tc, aNode->height, 2);
  CuAssertIntEquals(tc, aNode->balance, 2);

  aNode->right = newAVLNode("25");
  CuAssertStrEquals(tc, printDictionary(aNode),
  "[20] l:( [15] l:(  ) r:(  )  ) r:( [25] l:(  ) r:(  )  )");
  reCalculateAVLNodeHeightBalance(aNode);
  CuAssertIntEquals(tc, aNode->height, 2);
  CuAssertIntEquals(tc, aNode->balance, 0);
}

void Test_insertSymbolInDictionary(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  AVLNode* aSimpleDic = newAVLNode("aNodeSymbol");
  AVLNode* aNewDic = insertSymbolRecurse(aDic, aSimpleDic, "aNodeSymbol");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertPtrEquals(tc, aSimpleDic, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[aNodeSymbol] l:(  ) r:(  )");
  CuAssertPtrNull(tc, aNewDic->next);
  CuAssertPtrNull(tc, aNewDic->previous);
  CuAssertTrue(tc, aDic->firstSymbol != aNewDic);
  CuAssertTrue(tc, aDic->firstSymbol != aSimpleDic);
}

void Test_insertSymbolNotInDictionary(CuTest* tc) {
  DEBUG(FALSE, "\n%s insert many symbols %s", "---------", "---------");

  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  AVLNode* aSimpleDic = newAVLNode("20");
  aDic->dicRoot     = aSimpleDic;
  aDic->firstSymbol = aSimpleDic;

  AVLNode* aNewDic = insertSymbolRecurse(aDic, aSimpleDic, "15");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertPtrEquals(tc, aSimpleDic, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[20] l:( [15] l:(  ) r:(  )  ) r:(  )");
  //
  // test insertion on the left into doubly linked list
  //
  CuAssertPtrNotNull(tc, aNewDic->previous);
  CuAssertPtrNull(tc, aNewDic->next);
  CuAssertPtrEquals(tc, aDic->firstSymbol, aNewDic->previous);
  CuAssertPtrEquals(tc, aDic->firstSymbol->next, aNewDic);
  CuAssertPtrNull(tc, aDic->firstSymbol->previous);
  CuAssertPtrNull(tc, aNewDic->next);

  // should invoke an LL
  aNewDic = insertSymbolRecurse(aDic, aNewDic, "10");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [20] l:(  ) r:(  )  )");
  //
  // test insertion on the right into doubly linked list
  // as well as a rotate right
  //
  CuAssertPtrNotNull(tc, aNewDic->previous);
  CuAssertPtrNotNull(tc, aNewDic->next);
  CuAssertPtrEquals(tc, aDic->firstSymbol, aNewDic->previous);
  CuAssertPtrEquals(tc, aDic->firstSymbol->next, aNewDic);
  CuAssertStrEquals(tc, aDic->firstSymbol->symbol, "10");
  CuAssertStrEquals(tc, aNewDic->next->symbol, "20");
  CuAssertPtrEquals(tc, aNewDic->next->previous, aNewDic);
  CuAssertPtrNull(tc, aNewDic->next->next);

  aNewDic = insertSymbolRecurse(aDic, aNewDic, "30");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [20] l:(  ) r:( [30] l:(  ) r:(  )  )  )");

  // should invoke an RR
  aNewDic = insertSymbolRecurse(aDic, aNewDic, "35");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [30] l:( [20] l:(  ) r:(  )  ) r:( [35] l:(  ) r:(  )  )  )");

  aNewDic = insertSymbolRecurse(aDic, aNewDic, "25");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [30] l:( [20] l:(  ) r:( [25] l:(  ) r:(  )  )  ) r:( [35] l:(  ) r:(  )  )  )");

  aNewDic = insertSymbolRecurse(aDic, aNewDic, "23");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [30] l:( [23] l:( [20] l:(  ) r:(  )  ) r:( [25] l:(  ) r:(  )  )  ) r:( [35] l:(  ) r:(  )  )  )");

  aNewDic = insertSymbolRecurse(aDic, aNewDic, "22");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[23] l:( [15] l:( [10] l:(  ) r:(  )  ) r:( [20] l:(  ) r:( [22] l:(  ) r:(  )  )  )  ) r:( [30] l:( [25] l:(  ) r:(  )  ) r:( [35] l:(  ) r:(  )  )  )");

  // now try and find all of the symbols...
  AVLNode* aNode = findSymbolRecurse(aDic, aNewDic, "15");
  CuAssertPtrNotNull(tc, aNode);
  CuAssertStrEquals(tc, aNode->symbol, "15");

  aNode = findSymbolRecurse(aDic, aNewDic, "20");
  CuAssertPtrNotNull(tc, aNode);
  CuAssertStrEquals(tc, aNode->symbol, "20");

  aNode = findSymbolRecurse(aDic, aNewDic, "23");
  CuAssertPtrNotNull(tc, aNode);
  CuAssertStrEquals(tc, aNode->symbol, "23");

  checkAVLNode(aNewDic, FALSE);
}

void Test_insertSymbol_LL(CuTest* tc) {
  DEBUG(FALSE, "\n%s should invoke an LL %s\n", "---------", "---------");

  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  AVLNode* aSimpleDic = newAVLNode("20");
  aDic->dicRoot     = aSimpleDic;
  aDic->firstSymbol = aSimpleDic;

  AVLNode* aNewDic = insertSymbolRecurse(aDic, aSimpleDic, "15");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertPtrEquals(tc, aSimpleDic, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[20] l:( [15] l:(  ) r:(  )  ) r:(  )");

  // should invoke an LL
  aNewDic = insertSymbolRecurse(aDic, aNewDic, "10");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[15] l:( [10] l:(  ) r:(  )  ) r:( [20] l:(  ) r:(  )  )");
}

void Test_insertSymbol_RR(CuTest* tc) {
  DEBUG(FALSE, "\n%s should invoke an RR %s\n", "---------", "---------");

  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  AVLNode* aSimpleDic = newAVLNode("20");
  aDic->dicRoot     = aSimpleDic;
  aDic->firstSymbol = aSimpleDic;

  AVLNode* aNewDic = insertSymbolRecurse(aDic, aSimpleDic, "25");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertPtrEquals(tc, aSimpleDic, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[20] l:(  ) r:( [25] l:(  ) r:(  )  )");

  // should invoke an RR
  aNewDic = insertSymbolRecurse(aDic, aNewDic, "30");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[25] l:( [20] l:(  ) r:(  )  ) r:( [30] l:(  ) r:(  )  )");

  aNewDic = insertSymbolRecurse(aDic, aNewDic, "35");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[25] l:( [20] l:(  ) r:(  )  ) r:( [30] l:(  ) r:( [35] l:(  ) r:(  )  )  )");
}

void Test_insertSymbol_LR(CuTest* tc) {
  DEBUG(FALSE, "\n%s should invoke an LR %s\n", "---------", "---------");

  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  AVLNode* aSimpleDic = newAVLNode("20");
  aDic->dicRoot     = aSimpleDic;
  aDic->firstSymbol = aSimpleDic;

  AVLNode* aNewDic = insertSymbolRecurse(aDic, aSimpleDic, "15");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertPtrEquals(tc, aSimpleDic, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[20] l:( [15] l:(  ) r:(  )  ) r:(  )");

  // should invoke an LR
  aNewDic = insertSymbolRecurse(aDic, aNewDic, "17");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[17] l:( [15] l:(  ) r:(  )  ) r:( [20] l:(  ) r:(  )  )");
}

void Test_insertSymbol_RL(CuTest* tc) {
  DEBUG(FALSE, "\n%s should invoke an RL %s\n", "---------", "---------");

  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  AVLNode* aSimpleDic = newAVLNode("20");
  aDic->dicRoot     = aSimpleDic;
  aDic->firstSymbol = aSimpleDic;

  AVLNode* aNewDic = insertSymbolRecurse(aDic, aSimpleDic, "25");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertPtrEquals(tc, aSimpleDic, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[20] l:(  ) r:( [25] l:(  ) r:(  )  )");

  // should invoke an RL
  aNewDic = insertSymbolRecurse(aDic, aNewDic, "22");
  CuAssertPtrNotNull(tc, aNewDic);
  CuAssertStrEquals(tc, printDictionary(aNewDic),
  "[22] l:( [20] l:(  ) r:(  )  ) r:( [25] l:(  ) r:(  )  )");
}

void Test_insertSymbol_random(CuTest* tc) {

  srand(time(NULL));

  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  AVLNode* avlDic = newAVLNode("0");
  aDic->dicRoot     = avlDic;
  aDic->firstSymbol = avlDic;

  for (int i = 0; i < 1000; i++) {
    char itoa[100];
    sprintf(itoa, "%d", rand() % 100);
    avlDic = insertSymbolRecurse(aDic, avlDic, itoa);
  }
  checkAVLNode(avlDic, FALSE);

//  printf("%s\n", printDictionary(avlDic));
//  printf("avl node height: %zu\n", deepCalculateAVLNodeHeight(avlDic));
//  printf("avl node height: %zu\n", avlDic->height);
//  printf("avl node balance: %d\n", avlDic->balance);
}


void Test_insertSymbol_linear(CuTest* tc) {
  CoAlgebras* coAlgs = createCoAlgebras();
  CuAssertPtrNotNull(tc, coAlgs);
  Symbols* symbols = coAlgs->symbols;
  CuAssertPtrNotNull(tc, symbols);
  Dictionary* aDic = symbols->dictionary;
  CuAssertPtrNotNull(tc, aDic);

  AVLNode* avlDic = newAVLNode("10");
  aDic->dicRoot     = avlDic;
  aDic->firstSymbol = avlDic;

  for (int i = 10; i < 100; i++) {
    char itoa[100];
    sprintf(itoa, "%d", i);
    avlDic = insertSymbolRecurse(aDic, avlDic, itoa);
  }
  checkAVLNode(avlDic, FALSE);

//  printf("%s\n", printDictionary(avlDic));
//  printf("avl node height: %zu\n", deepCalculateAVLNodeHeight(avlDic));
//  printf("avl node height: %zu\n", avlDic->height);
//  printf("avl node balance: %d\n", avlDic->balance);

  CuAssertIntEquals(tc, avlDic->height, deepCalculateAVLNodeHeight(avlDic));
  CuAssertIntEquals(tc, avlDic->height, 8);
  CuAssertIntEquals(tc, avlDic->balance, -2);
}

\stoptyping