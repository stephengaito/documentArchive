% A ConTeXt document [master document: dictionaries.tex]

\section[title=Code]
\setCHeaderStream{public}

\dependsOn[jInterps]
\dependsOn[symbols]
\dependsOn[stringBuffers]

\startCHeader
typedef struct dictionaries_object_struct DictObj;

typedef struct dictionaries_object_struct {
  JObj  super;
  Symbol*   symbol;
  JObj* preObs;
  JObj* value;
  JObj* postObs;
  DictObj*  left;
  DictObj*  right;
  DictObj*  previous;
  DictObj*  next;
  size_t    height;
  long      balance;
} DictObj;
\stopCHeader

\startTestSuite[newDict]

\startCHeader
typedef DictObj *(NewDict)(
  JoyLoLInterp *jInterp,
  Symbol       *aSym
);

#define newDict(jInterp, aSym)            \
  (                                       \
    assert(getDictionariesClass(jInterp)  \
      ->newDictFunc),                     \
    (getDictionariesClass(jInterp)        \
      ->newDictFunc(jInterp, aSym))       \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern DictObj *newDictImpl(
  JoyLoLInterp *jInterp,
  Symbol *aSym
);

#define dictAsSymbol(aNode)   ((DictObj*)(aNode))->symbol
#define dictAsPreObs(aNode)   ((DictObj*)(aNode))->preObs
#define dictAsValue(aNode)    ((DictObj*)(aNode))->value
#define dictAsPostObs(aNode)  ((DictObj*)(aNode))->postObs
#define dictAsLeft(aNode)     ((DictObj*)(aNode))->left
#define dictAsRight(aNode)    ((DictObj*)(aNode))->right
#define dictAsPrevious(aNode) ((DictObj*)(aNode))->previous
#define dictAsNext(aNode)     ((DictObj*)(aNode))->next
#define dictAsHeight(aNode)   ((DictObj*)(aNode))->height
#define dictAsBalance(aNode)  ((DictObj*)(aNode))->balance
\stopCHeader
\setCHeaderStream{public}

\startCCode
// We implement our dictionary as an AVL binary tree using AVLNodes.
//
// Our implementation is inspired by:
// The Crazy Programmer's "Program for AVL Tree in C" (Neeraj Mishra)
// http://www.thecrazyprogrammer.com/2014/03/c-program-for-avl-tree-implementation.html
// and by:
// Jianye Hao's CSC2100B Tutorial 4 "Binary and AVL Trees in C"
// https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu4.pdf
//
// At the moment we only insert and search (we never delete).
//
// ANY AVLTree node can be the root of a new dictionary.
//

DictObj *newDictImpl(
  JoyLoLInterp *jInterp,
  Symbol *aSym
) {
  assert(jInterp);
  assert(jInterp->coAlgs);
  assert(DictionariesTag < jInterp->numCoAlgs);
  assert(jInterp->coAlgs[DictionariesTag].sClass);
  
  assert(aSym);
  
  DEBUG(jInterp, "newAVLNode [%s]\n", aSym);
  JObj* newNode   = newObject(jInterp, DictionariesTag);
  dictAsSymbol(newNode)   = strdup(aSym);
  dictAsPreObs(newNode)   = NULL;
  dictAsValue(newNode)    = NULL;
  dictAsPostObs(newNode)  = NULL;
  dictAsLeft(newNode)     = NULL;
  dictAsRight(newNode)    = NULL;
  dictAsPrevious(newNode) = NULL;
  dictAsNext(newNode)     = NULL;
  dictAsHeight(newNode)   = 1;
  dictAsBalance(newNode)  = 0;
  return (DictObj*)newNode;
}
\stopCCode

\startTestCase[should add a new dict object (AVL node)]

\startCTest
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(jInterp->coAlgs[DictionariesTag].sClass);

  DictObj* aNode = newDict(jInterp, "aNodeSymbol");
  AssertPtrNotNull(aNode);
  AssertPtrNotNull(asType(aNode));
  AssertIntEquals(asTag(aNode), DictionariesTag)
  AssertPtrNotNull(dictAsSymbol(aNode));
  AssertStrEquals(dictAsSymbol(aNode), "aNodeSymbol");
  AssertPtrNull(dictAsValue(aNode));
  AssertPtrNull(dictAsLeft(aNode));
  AssertPtrNull(dictAsRight(aNode));
  AssertPtrNull(dictAsPrevious(aNode));
  AssertPtrNull(dictAsNext(aNode));
  AssertIntEquals(dictAsHeight(aNode), 1);
  AssertIntEquals(dictAsBalance(aNode), 0);
\stopCTest
\stopTestCase
\stopTestSuite

\startTestSuite[createSymbol]

\startCHeader
typedef DictObj *(CreateSymbol)(
  JoyLoLInterp *jInterp,
  Symbol       *aSymbol
);

#define createSymbol(jInterp, aSymbol)      \
  (                                         \
    assert(getDictionariesClass(jInterp)    \
      ->createSymbolFunc),                  \
    (getDictionariesClass(jInterp)          \
      ->createSymbolFunc(jInterp, aSymbol)) \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern DictObj* createSymbolImpl(
  JoyLoLInterp *jInterp,
  Symbol       *aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
DictObj* createSymbolImpl(
  JoyLoLInterp *jInterp,
  Symbol       *aSymbol
) {
  assert(jInterp);
  if (!aSymbol) return NULL;
  DictObj* aSym = findSymbol(jInterp, aSymbol);
  if (!aSym) {
    jInterp->dict.root = insertSymbol(jInterp, aSymbol);
    aSym = findSymbol(jInterp, aSymbol);
  }
  return aSym;
}
\stopCCode
\stopTestSuite

\startCHeader
typedef JObj *(GetSymbol)(
  JoyLoLInterp *jInterp,
  Symbol       *aSymbol
);

#define getSymbol(jInterp, aSymbol)       \
  (                                       \
    assert(getDictionariesClass(jInterp)  \
      ->getSymbolFunc),                   \
    (getDictionariesClass(jInterp)        \
      ->getSymbolFunc(jInterp, aSymbol))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern JObj* getSymbolImpl(
  JoyLoLInterp* jInterp,
  Symbol* aSymbol
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
JObj* getSymbolImpl(
  JoyLoLInterp* jInterp,
  Symbol* aSymbol
) {
  DictObj* aSym = createSymbol(jInterp, aSymbol);
  return newSymbol(jInterp, aSym->symbol);
}
\stopCCode

\startCHeader
typedef void (ListDefinitions)(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf
);

#define listDefinitions(jInterp, aStrBuf)       \
  (                                             \
    assert(getDictionariesClass(jInterp)        \
      ->listDefinitionsFunc),                   \
    (getDictionariesClass(jInterp)              \
      ->listDefinitionsFunc(jInterp, aStrBuf))  \
  )
\stopCHeader

\setCHeaderStream{private}
\startCHeader
extern void listDefinitionsImpl(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void listDefinitionsImpl(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf
) {
  DictObj* curNode = jInterp->dict.firstSymbol;
  while(curNode) {
    if (curNode->value) {
      strBufPrintf(jInterp, aStrBuf,"%s == ", curNode->symbol);
      printLoL(jInterp, aStrBuf, curNode->value);
      strBufPrintf(jInterp, aStrBuf,"\n");
    }
    curNode = curNode->next;
  }
}
\stopCCode

\setCHeaderStream{private}
\startCHeader
extern Boolean printDicionaryJObjInto(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  JObj        *anAVLNode
);
extern Boolean printDicInto(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  DictObj         *anAVLNode
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean printDictionaryJObjInto(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  JObj        *anAVLNode
) {
  if (!anAVLNode) return FALSE;
  if (asTag(anAVLNode) != DictionariesTag) return FALSE;
  return printDicInto(jInterp, aStrBuf, (DictObj*)anAVLNode);
}

Boolean printDicInto(
  JoyLoLInterp    *jInterp,
  StringBufferObj *aStrBuf,
  DictObj         *anAVLNode
) {
  if (!anAVLNode) return TRUE;
  strBufPrintf(jInterp, aStrBuf, "[%s] l:( ", anAVLNode->symbol);
  printDicInto(jInterp, aStrBuf, anAVLNode->left);
  strBufPrintf(jInterp, aStrBuf, " ) r:( ");
  printDicInto(jInterp, aStrBuf, anAVLNode->right);
  strBufPrintf(jInterp, aStrBuf, " ) ");
  return TRUE;
}
\stopCCode

\startTestSuite[registerDictionaries]

\startCHeader
typedef struct dictionaries_class_struct {
  CoAlgClass super;
  NewDict         *newDictFunc;
  CreateSymbol    *createSymbolFunc;
  GetSymbol       *getSymbolFunc;
  FindSymbol      *findSymbolFunc;
  FindLUBSymbol   *findLUBSymbolFunc;
  ListDefinitions *listDefinitionsFunc;
} DictionariesClass;
\stopCHeader

\startCCode
static Boolean initializeDictionaries(
  JoyLoLInterp *jInterp,
  CoAlgClass   *aCoAlgClass
) {
  assert(jInterp);
  assert(aCoAlgClass);
  registerDictionaryWords(jInterp);
  return TRUE;
}
\stopCCode

\setCHeaderStream{private}
\startCHeader
extern Boolean registerDictionaries(JoyLoLInterp *jInterp);
\stopCHeader
\setCHeaderStream{public}

\startCCode
Boolean registerDictionaries(JoyLoLInterp *jInterp) {
  assert(jInterp);
  
  DictionariesClass* theCoAlg =
    joyLoLCalloc(1, DictionariesClass);
  assert(theCoAlg);
  
  theCoAlg->super.name            = DictionariesName;
  theCoAlg->super.objectSize      = sizeof(DictObj);
  theCoAlg->super.initializeFunc  = initializeDictionaries;
  theCoAlg->super.equalityFunc    = NULL;
  theCoAlg->super.printFunc       = printDictionaryJObjInto;
  theCoAlg->newDictFunc           = newDictImpl;
  theCoAlg->createSymbolFunc      = createSymbolImpl;
  theCoAlg->getSymbolFunc         = getSymbolImpl;
  theCoAlg->findSymbolFunc        = findSymbolImpl;
  theCoAlg->findLUBSymbolFunc     = findLUBSymbolImpl;
  theCoAlg->listDefinitionsFunc   = listDefinitionsImpl;
  size_t tag =
    registerCoAlgClass(jInterp, (CoAlgClass*)theCoAlg);
  
  // do a sanity check...
  assert(tag == DictionariesTag);
  assert(jInterp->coAlgs[tag].sClass);
    
  return TRUE;
}
\stopCCode

\startTestCase[should register the Dictionaries coAlg]

\startCTest
  // CTestsSetup has already created a jInterp
  // and run regiserDictionaries
  AssertPtrNotNull(jInterp);
  AssertPtrNotNull(getDictionariesClass(jInterp));
  DictionariesClass *coAlg =
    getDictionariesClass(jInterp);
  AssertIntTrue(registerDictionaries(jInterp));
  AssertPtrNotNull(getDictionariesClass(jInterp));
  AssertPtrEquals(getDictionariesClass(jInterp), coAlg);
  AssertIntEquals(
    getDictionariesClass(jInterp)->super.objectSize, 
    sizeof(DictObj)
  );
\stopCTest
\stopTestCase
\stopTestSuite

\setCHeaderStream{public}
