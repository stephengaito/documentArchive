% building Plato's engine

As every self respecting Computer Scientist knows, Plato's universe does not
consist of a collection of ``Sets'' but rather a ``collection'' of Lists of
Lists.

``Before the Set, was the List''

\begin{bnf*}
 \bnfProd{List}{ ( \bnfSP ) }
 \bnfAlt{ ( \bnfSP \bnfPN{List} \bnfSP \bnfTD{.} \bnfSP \bnfPN{List} \bnfSP )}
\end{bnf*}

Alternatively in Kleene star format as essentially used in Lisp/Scheme:

\begin{bnf*}
 \bnfProd{List}{ ( \bnfSP \bnfKS{ \bnfPN{List} }{*} \bnfSP ) }
\end{bnf*}

%\begin{racket}
%(println "Hello from Plato's engine!")
%\end{racket}


\begin{cTikzPicture}

\fill[orange!20!white] (0,0) -- (4,0) -- (4,4) -- (0,4)
  -- (0,3) -- (3,3) -- (3,1) -- (0,1) -- (0,0);

\path (0,0) edge (4,0);
\path (0,0) edge (0,4);
\path (4,0) edge (4,4);
\path (0,4) edge (4,4);

\path (0,1) edge (3,1);
\path (3,1) edge (3,2);
\path (0,2) edge (3,2);

\path (0,3) edge (3,3);
\path (3,2) edge (3,3);

\path (3,1.5) edge[dashed] (4,1.5);

\node at (1.5,1.5) {L-expression};
\node at (1.5,2.5) {M-expression};
\node at (2,3.7)   {Interpreter - Process};
\node at (2,3.25)  {(Co-algebra)};
\node at (2,0.7)   {Interpreter - Memory};
\node at (2,0.25)  {(Algebra)};

\end{cTikzPicture}

The processor part of the interpreter, could be a human, a computer, or a Lisp
machine. The memory part of the interpreter, could be sand, paper, an abacus,
computer RAM, or Lisp machine list memory.

An L-expression is that subset of all Lisp S-exrepssions which have no atoms
other than NIL, and hence are pure Lists of Lists.

Our objective is to build an interpreter, like John McCarthy's original Lisp
programming language, \cite{mcCarthy1960lisp,
mcCarthyAbrahamsEdwardsHartLevin1965lispManual}. We will use ideas from the two
excellent texts teaching Programming Language Design using the PLT Racket
dialect of Lisp,
\cite{krishnamurthi2007programmingLanguagesApplicationInterpretation,
krishnamurthi2012programmingLanguagesApplicationInterpretation,
friedmanWand2008essentialsProgrammingLanguages, racket2016racket}, as well as
the Graph Programming Language (GP), pioneered by Detlef Plump's group at the
University of York, \cite{steinert2007graphProgramming,
manningPlump2008yorkMachine, plump2009graphProgramming,
plumpSteinert2010semanticsGraphProgramming, plump2012graphProgramming}.

Our interpreter is based upon the York Abstract Machine (YAM),
\cite{manningPlump2008yorkMachine}. While the YAM is a bytecode interpreter, we
will simply interpret to either Racket/Lisp or Haskell. We will implement
Prolog/Haskell style pattern matching by implementing a unification subsystem,
\cite[section
30.5.1]{krishnamurthi2007programmingLanguagesApplicationInterpretation}, as well
as Prolog backtracking search,
\cite[34.1.1]{krishnamurthi2007programmingLanguagesApplicationInterpretation}.

We will also provide proof of correctness of all computation using Denotational,
Operational, Axiomatic and Weakest Precondition based semantics,
\cite{gunter1992semainticProgrammingLanguages,
winskel1993formalSemanticsProgrammingLanguages, gries1981scienceProgramming,
scott1970theoryComputation, plotkin1981structuralOperationalSemantics,
hoare1969axiomaticSemantics, dijkstra1975guardedCommandsFormalDerivation}. More
specifically these ideas have been worked out for Graph Programming 1by Detlef
Plump's group, \cite{steinert2007graphProgramming,
plumpSteinert2010semanticsGraphProgramming, poskittPlump2010hoareLogic,
poskittPlump2010hoareCalculus}.

\section{Syntax}

We begin by providing the syntax of our diSimplex proof language following the
standard set by \cite{friedmanWand2008essentialsProgrammingLanguages}.

\newcommand{\IExp}[1]{& \textnormal{IExp:} & #1 \\}
\newcommand{\Denotation}[1]{& \textnormal{Den:} & #1 \\}
\newcommand{\Operational}[1]{& \textnormal{Oper:} & #1 \\}
\newcommand{\Axiomatic}[1]{& \textnormal{Axiom:} & \begin{minipage}{4cm} \begin{prooftree} #1 \end{prooftree} \end{minipage} \\}

\begin{bnf*}
 \bnfProd{Proof}{ \bnfTD{Begin} \bnfSP \bnfPN{Expression} \bnfSP \bnfTD{End} }
 \IExp{( \bnfSP \bnfTD{proof} \bnfSP \bnfTD{exp1} \bnfSP )}
 \Denotation{something}
 \Operational{something}
 \Axiomatic{
  \AxiomC{}
  \RightLabel{empty-ctx}
  \UnaryInfC{\cJudgement{\cdot}}
 }
\end{bnf*}

\begin{bnf*}
 \bnfProd{Expression}{\bnfPN{List}}
 \IExp{( \bnfSP \bnfTD{list} \bnfSP \bnfTD{list1} \bnfSP )}
 \Denotation{something}
 \Operational{something}
% \Axiomatic{something}
\end{bnf*}

\begin{bnf*}
 \bnfProd{Expression}{ \bnfTD{cons} \bnfSP \bnfPN{List} \bnfSP \bnfPN{List} }
 \IExp{( \bnfSP \bnfTD{cons} \bnfSP \bnfTD{list1} \bnfSP \bnfTD{list2} \bnfSP )}
 \Denotation{something}
 \Operational{something}
% \Axiomatic{something}
\end{bnf*}

\begin{bnf*}
 \bnfProd{Expression}{ \bnfTD{car} \bnfSP \bnfPN{List} }
 \IExp{( \bnfSP \bnfTD{car} \bnfSP \bnfTD{list1} \bnfSP )}
 \Denotation{something}
 \Operational{something}
% \Axiomatic{something}
\end{bnf*}

\begin{bnf*}
 \bnfProd{Expression}{ \bnfTD{cdr} \bnfSP \bnfPN{List} }
 \IExp{( \bnfSP \bnfTD{cdr} \bnfSP \bnfTD{list1} \bnfSP )}
 \Denotation{something}
 \Operational{something}
% \Axiomatic{something}
\end{bnf*}

\begin{bnf*}
 \bnfProd{Expression}{ \bnfTD{null?} \bnfSP \bnfPN{List} }
 \IExp{( \bnfSP \bnfTD{null?} \bnfSP \bnfTD{list1} \bnfSP )}
 \Denotation{something}
 \Operational{something}
% \Axiomatic{something}
\end{bnf*}

\begin{bnf*}
 \bnfProd{Expression}{ \bnfTD{if}   \bnfSP \bnfPN{Expression} \bnfSP
                       \bnfTD{then} \bnfSP \bnfPN{Expression} \bnfSP
                       \bnfTD{else} \bnfSP \bnfPN{Expression} }
 \IExp{( \bnfSP \bnfTD{if} \bnfSP \bnfTD{exp1} \bnfSP \bnfTD{exp2} \bnfSP \bnfTD{exp3} \bnfSP )}
 \Denotation{something}
 \Operational{something}
% \Axiomatic{something}
\end{bnf*}

\begin{bnf*}
 \bnfProd{Expression}{ \bnfPN{Identifier} }
 \IExp{( \bnfSP \bnfTD{var} \bnfSP \bnfTD{var1} \bnfSP )}
 \Denotation{something}
 \Operational{something}
% \Axiomatic{something}
\end{bnf*}

\begin{bnf*}
 \bnfProd{Expression}{ \bnfTD{let} \bnfSP \bnfPN{Identifier} \bnfSP
                       \bnfTD{=}   \bnfSP \bnfPN{Expression} }
 \IExp{( \bnfSP \bnfTD{let} \bnfSP \bnfTD{var1} \bnfSP \bnfTD{exp1} \bnfSP )}
 \Denotation{something}
 \Operational{something}
% \Axiomatic{something}
\end{bnf*}

\begin{bnf*}
 \bnfProd{List}{ \bnfTD{(} \bnfSP \bnfTD{)}}
 \IExp{( \bnfSP \bnfTD{null} \bnfSP )}
 \Denotation{something}
 \Operational{something}
% \Axiomatic{something}
\end{bnf*}

