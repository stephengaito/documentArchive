% The Story so far

At the moment we do not consider foundational issues surrounding the concept of Category.

\paragraph{1}

There are numerous equivalent `computational' universes which each consist of a
dual pair of categories. This multiplicity corresponds to equivalent but
distinctly different base structures.

The current best recognized universe is a superset of the category of Set where
the including dual category is the category of Anti-foundational Sets.
Admittedly, at the moment, Set is not considered `computational'.

The most obvious `computational' universe is the category of maps from the
Ordinals into the set \set{0, 1, \textvisiblespace}.\footnote{This is the
transfinite generalization of Turing's countable tapes.} In this universe, a
Turing machine is a \emph{finite} comonad.

Each computational device be it `physical' or just defined in software on some
`physical' device, defines its own `computational' universe. More specifically
the theoretical model of each computational device defines its own
`computational' universe.

However for our purposes the most `useful' `computational' universe is the List of Lists.

\paragraph{2}

Each universe consists of a dual pair of universes: one which captures the
algebraic `syntax' and which captures the co-algebraic `behaviour'. There are
two ways to consider this dual pair. Firstly, and our primary method, is to see
the algebraic part as the initial object in the category of (sub) co-algebraic
comonads associated with a given behaviour. Alternatively the co-algebraic part
is the finial object in the category 0f (sub) algebraic monads associate with a
given syntax.

\paragraph{3}

A computation is a path.

A formally proven computation is a path whose boundary objects are defined.

A specification is a specified collection of boundary objects.

An algorithm for a given specification is a (sub) co-algebraic structure whose
boundary is the given specification.

An implementation of a given algorithm for a given specification is a
(functorial) model in a given `computational' universe.

\paragraph{4}

The statement of a theorem is a specification.

The proof of a theorem is a formally proven computation.

A definition is... ? Is it a (sub) `computational' universe?

\paragraph{5}

Fundamental to the study of computational universes is a given universe's
complexity measure. This is a mapping from an object or arrow (objects plus
`mapping') into a representation of the collection of ordinals in the given
universe.

This complexity measure is (sub?) additive with respect to composition of
arrows.

Note that the complexity of an object is the complexity of its arrow from the
final object to the given object.

Question: how is this measure of complexity related to entropy or an imprecise
measure?

We \emph{want} to find a collection of smallest arrows from which all other
arrows can be built... this is the programming language.

Question: how is this related to a variational definition of physics?

This measure of complexity is `like' the topological version of entropy, while
an impreceise measure (of complexity?) is `like' the measure theoretic version
of entropy.