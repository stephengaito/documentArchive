% A ConTeXt document [master document: joylolTests.tex]

\section[title=Words]
\setJoylolTracingOff\setJoylolVerboseOff


\startJoylolCode
( 
  "running ALL TESTS"
  writeOutNL
  interpret
  "finished ALL TESTS"
  writeOutNL
)
globals
runAllTests
define

(
  "defined tests setup"
  writeOutNL
  pop1D
)
globals
defineTestsSetup
define

(
  "defined tests teardown"
  writeOutNL
  pop1D
)
globals
defineTestsTeardown
define

(
  "running test suite"
  writeOutNL
  interpret
)
globals
runTestSuite
define

(
  "-------------------------------------"
  writeOutNL
  "jTS:"
  prepend
  100
  swap12D
  printLoL
  writeOutNL
)
globals
recordTestSuiteDetails
define

(
  "defined test suite setup"
  writeOutNL
  pop1D
)
globals
defineTestSuiteSetup
define

(
  "defined test suite teardown"
  writeOutNL
  pop1D
)
globals
defineTestSuiteTeardown
define

(
  "running test case"
  writeOutNL
  interpret
)
globals
runTestCase
define

(
  "  jTC:"
  prepend
  100
  swap12D
  printLoL
  writeOutNL
)
globals
recordTestCaseDetails
define

;; a comment

\stopJoylolCode

\starttyping
\startTestSuite[tests and assert naming scopes]

We start by defining a naming scope to contain all of the Joylol test 
associated words. This naming space is denoted \quote{tests} in the 
\quote{globals} naming scope. The \quote{tests} naming scope's parent 
naming scope is also \quote{globals}. 

\startJoylolCode
;; create a tests naming scope
globals      ;; parent naming scope
globals      ;; defining naming scope
tests        ;; defined name of this new naming scope
defineNaming ;; make the definition
\stopJoylolCode

We also create a naming scope to contain all of the assertion related 
words. 

\startJoylolCode
;; create an assert naming scope
tests        ;; parent naming scope
globals      ;; defining naming scope
assert       ;; defined name of this new naming scope
defineNaming ;; make the definition
\stopJoylolCode
\stopTestSuite

\startTestSuite[runTestCase]

Our next task, over the next following code fragments, is to define the 
runTestCase word. This word takes a test case, as a list of the words to 
be tested intermingled with assertions, and creates the testMonitor and 
testRunner contexts which together run the test case provided. To be 
completely re-entrant, the testMonitor and testRunner contexts are stored 
in the running context's localized naming scope. 

The following figure is a summary of the word/switch pattern of 
\type{runTestCase} word: 

\externalfigure[runJoylolTestCase.pdf][width=10cm]

\startJoylolCode
(               ;; start of the runTestCase word
\stopJoylolCode

We start by localizing the running context's naming scope and then 
defining the testRunnerNS and testMonitorNS naming scopes in the localized 
naming scope. 

\startJoylolCode
  ;; localize the naming scope of the current context
  locals
  localizeNaming
\stopJoylolCode

\startJoylolCode
  ;; create the testRunnerNS
  globals      ;; parent naming scope
  thisNaming   ;; define in localized naming scope
  testRunnerNS ;; name of the new naming scope
  defineNaming ;; create a new naming scope
               ;; to be used as the testRunner's naming scope
\stopJoylolCode

\startJoylolCode
  ;; create the testMonitorNS
  globals       ;; parent naming scope
  thisNaming    ;; define in the localized naming scope
  testMonitorNS ;; name of the new naming scope
  defineNaming  ;; create a new naming scope
                ;; to be used as the testMonitor's naming scope
\stopJoylolCode

At this point the test case's list of words and assertions are back on the 
top of the stack. This list will be used as the testRunner's initial 
process stack. We can now add the initial data stack for the testRunner 
context, and then setup the new context's naming scope, the defining 
naming scope and finally the name of the new context.

\startJoylolCode
  ;; define the testRunner context
                ;; testRunner process (uses provided list of words)
  ( 
  )             ;; testRunner data
  testRunnerNS  ;; the naming scope of the new context
  thisNaming    ;; define in the localized naming scope
  testRunner    ;; name of the new context
  defineContext ;; create and define the context
\stopJoylolCode

Now we create a testMonitor context which will keep track of the test 
results. The testMonitor's initial process stack should contain the three 
words, \type{interpret}, the current context, and \type{switchCtx} in this 
order. When an assertion switches from the testRunner's context to the 
testMonitor context the top of the testRunner's stack is place onto the 
top of the testMonitor's data stack. The \type{interpret} word will then 
place the words on the top of the testMonitor's data stack onto the 
testMonitor's process stack to be interpreted. The assertion being 
interpreted \emph{should} ensure it re-places the \type{interpret} word 
back on the testMonitor's process stack for use by the next assertion. 

The last two words, the current context and \type{switchCtx}, as used by the 
textMonitor interpreting the \type{results} word to know which context to 
switch to with the summary results. 

Since the \type{thisContext} word has to be interpreted in the calling 
context, we have to \type{append} the result of interpreting the 
\type{thisContext} word rather than just placing the \type{thisContext} 
word directly on the testMonitor's process stack. Once the 

\startJoylolCode
  ;; define the testMonitor context
  ( interpret ) ;; begin the testMonitor process stack
  thisContext   ;; interpret thisContext 
  append        ;; append the result of interpreting thisContext
  ( switchCtx ) ;; 
  append        ;; append the word switch to the
                ;; testMonitor's initial process stack
  
  ( 
    0           ;; number of attempted tests
    0           ;; number of failed tests
    ()          ;; list of failure reports
  )             ;; testMonitor data

  testMonitorNS ;; the naming scope of the new context
  thisNaming    ;; defining naming scope
  testMonitor   ;; defined name of this new context
  defineContext ;; create and define the context
\stopJoylolCode

Finally we switch to the testRunner context.

\startJoylolCode
  ;; switch to the testRunner context and run the tests
  testRunner ;; place the testRunner context on the stack
  switchCtx  ;; switch to the testRunner context
  
)            ;; end of the runTestCase definition

tests        ;; define the new word in this naming scope
runTestCase  ;; the name of the new word
define       ;; define the new runTestCase word
\stopJoylolCode
\stopTestSuite

\startTestSuite[assert.reportAssertion]

In this section we develop the \type{reportAssertion} word in the 
\type{assert} naming scope. This word takes the result of an individual 
assertion, switches to the \type{testMonitor} context and records it 
before switching back to the \type{testRunner} context. 

The \type{reportAssertion} word assumes that any previous assertion has 
left an assertion result list on the top of the testRunner's data stack. 
This assertion result list consists of true/false followed by a failure 
report list (only if the assertion failed). 

\startJoylolCode
(               ;; start of the reportAssertion word
                ;; the assertion report is assumed to be on top
  (
    assert.recordAssertion  ;; the task to be done
    testRunner  ;; return to testRunner
    switchCtx   ;; perform the switch/return
    interpret   ;; leave an initial interpret for the next switch/call
  )
  append
  testMonitor   ;; place the testMonitor context on top of stack
  switchCtx     ;; switch to the testMonitor context
                ;; (the testMonitor context will interpret to
                ;;  current top of the stack)
)               ;; end of the reportAssertion word
assert          ;;define the new word in the assert naming scope
reportAssertion ;; the name of the new word
define          ;; define the reportAssertion word
\stopJoylolCode
\stopTestSuite

\startTestSuite[assert.recordAssertion]

The \type{recordAssertion} word is run on the testMonitor context. It 
assumes that the top of the data stack is a true/false depending upon the 
success/failure of the previous assertion. If the top of the stack is 
false, then the \type{recordAssertion} word also expects a list containing 
the assertion failure reasons as the second item on the stack. The 
subsequent item on the stack is then the context to which to return so 
that any further assertions can be run. Finally the last item on the stack 
is the testMonitor's record of assertion results. 

\startJoylolCode
(
  (
    isTrue
  )  ;; test
  (
    ;; the top of the stack is the testMonitor's
    ;; record of assertion results
    extract
    ;; the top of the stack is the number of attempts value
    1 + ;; add one to the top of the stack
    prepend
    prepend
    ;; the top of the stack is the
    ;; updated record of assertion results
  )  ;; then action ;; just update the number of attempted tests 
  (
    ;; the top of the stack is an assertion failure report list
    ;; then comes the testMonitor's record of assertion results
    append
    extract
    ;; top    comes the number of attempts value
    ;; second comes the number of failures value
    ;; third  comes the collection of failure reports
    ;; fourth comes the assertion failure report list
    1 + ;; add one to the number of attempted
    swap12D
    1 + ;; add one to the number of failed
    append
    rollupD ;; put current record third
    append  ;; append the assertion failure report to list or failures
    append  ;; complete the record of assertion results
    ;; top comes the updated record of assertion results
  )  ;; else action ;; update everything
  ifte
)
assert
recordAssertion
define
\stopJoylolCode
\stopTestSuite
\stoptyping

\starttyping
\startTestSuite[start/stop joylol test suite]

\startJoylolCode
  (
  )
  startTestSuite
  define
  
  (
  )
  stopTestSuite
  define
\stopJoylolCode

\stopTestSuite
\stoptyping

\starttyping
\startTestSuite[start/stop/skip/run a joylol test case]


\stopTestSuite
\stoptyping

\startTestSuite[assertShouldFail]

\starttyping
\startJoylolCode

(
  
)
assert
shouldFail
define
\stopJoylolCode

\startTestCase[assert should fail]
\startJoylolTest
"this is a test"
doSomeThing
\stopJoylolTest
\stopTestCase
\stopTestSuite
\stoptyping

\startTestSuite[assertFail]

\starttyping
\startJoylolCode
(
  fail
  assert.reportAssertion
)
assert
fail
define
\stopJoylolCode
\stoptyping

\startTestCase[assertFail should fail]
\startJoylolTest
  ;;assert.fail
\stopJoylolTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertSucceed]
\starttyping
\startJoylolCode
(
  succeed
  assert.reportAssertion
)
assert
succeed
define
\stopJoylolCode
\stoptyping

\startTestCase[assert.succeed should succeed]
\startJoylolTest
  ;;assert.succeed
\stopJoylolTest
\stopTestCase
\stopTestSuite

\startTestSuite[assert.isBoolean]
\starttyping
\startJoylolCode
(
  isBoolean
  assert.reportAssertion
)
assert
isBoolean
define
\stopJoylolCode
\stoptyping

\startTestCase[should succeed if an object is a boolean ]
\startJoylolTest
  ;;true
  ;;assert.isBoolean
\stopJoylolTest
\stopTestCase

\startTestCase[should fail if an object is not a boolean]
\startJoylolTest
  ;;notABoolean
  ;;assert.isBoolean
\stopJoylolTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertTrue]

\stopTestSuite

\startTestSuite[assertFalse]

\stopTestSuite

\startTestSuite[assertNil]

\stopTestSuite

\startTestSuite[assertNotNil]

\stopTestSuite

\startTestSuite[assertAtom]

\stopTestSuite

\startTestSuite[assertPair]

\stopTestSuite

\startTestSuite[assertNatural]

\stopTestSuite

\startTestSuite[assertSymbol]

\stopTestSuite

\startTestSuite[assertContext]

\stopTestSuite

\startTestSuite[assertDictionary]

\stopTestSuite

\startTestSuite[assertDictNode]

\stopTestSuite


\setCHeaderStream{private}
\startCHeader
extern void registerJoylolTestWords(
  JoyLoLInterp* jInterp
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void registerJoylolTestWords(
  JoyLoLInterp* jInterp
) {
  assert(jInterp);

}
\stopCCode