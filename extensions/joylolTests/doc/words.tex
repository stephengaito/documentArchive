% A ConTeXt document [master document: joylolTests.tex]

\section[title=Words]
\setJoylolTracingOff\setJoylolVerboseOff

\startTestSuite[tests and assert naming scopes]

We start by defining a naming scope to contain all of the Joylol test 
associated words. This naming space is denoted \quote{tests} in the 
\quote{globals} naming scope. The \quote{tests} naming scope's parent 
naming scope is also \quote{globals}. 

\startJoylolCode
;; create a tests naming scope
globals      ;; parent naming scope
globals      ;; defining naming scope
tests        ;; defined name of this new naming scope
defineNaming ;; make the definition
\stopJoylolCode

We also create a naming scope to contain all of the assertion related 
words. 

\startJoylolCode
;; create an assert naming scope
tests        ;; parent naming scope
globals      ;; defining naming scope
assert       ;; defined name of this new naming scope
defineNaming ;; make the definition
\stopJoylolCode
\stopTestSuite

\startTestSuite[running all tests]

The following figure is a summary of the word/switch pattern of 
\type{runAllTests} word: 

\externalfigure[runJoylolTestAll.pdf][width=10cm]

\startJoylolCode
(                     ;; start of the runAllTests word
  "running ALL TESTS" ;;
  writeOutNL          ;; announce our presence
\stopJoylolCode

We start by localizing the running context's naming scope and then 
defining the testsRunnerNS and testsMonitorNS naming scopes in the 
localized naming scope. 

\startJoylolCode
  ;; localize the naming scope of the current context
  allTestsLocals  ;; name of the localized naming scope
  localizeNaming  ;; localize the naming scope
\stopJoylolCode

\startJoylolCode
  ;; create the testsRunnerNS
  thisNaming    ;; define the parent's naming scope
  thisNaming    ;; define in the localized naming scope
  testsRunnerNS ;; name of the new naming scope
  defineNaming  ;; create the new naming scope
                ;; to be used as the testsRunner's naming scope
\stopJoylolCode

\startJoylolCode
  ;; create the testsMonitorNS
  thisNaming    ;; define the parent's naming scope
  thisNaming    ;; define in the localized naming scope
  testsMonitorNS;; name of the new naming scope
  defineNaming  ;; create the new naming scope
                ;; to be used as the testsMonitor's naming scope
\stopJoylolCode

We now want to define default tests setup and teardown words in the 
testsRunnerNS. 

\startJoylolCode
  ()            ;; empty default setup actions
  testsRunnerNS ;; define in the testRunnerNS
  testsSetup    ;; name of the new word
  define        ;; define the testsSetup word
\stopJoylolCode

\startJoylolCode
  ()            ;; empty default teardown actions
  testsRunnerNS ;; define in the testRunnerNS
  testsTeardown ;; name of the new word
  define        ;; define the testsTeardown word
\stopJoylolCode

We now create the testsRunner context.

\startJoylolCode
  ;; define the testsRunner context
                ;; testsRunner process (uses provided list of words)
  ()            ;; testsRunner data
  testsRunnerNS ;; naming scope of the new context
  thisNaming    ;; defined in the localized naming scope
  testsRunner   ;; name of the new context
  defineContext ;; define the new context
\stopJoylolCode

We now create the testsMonitor context.

\startJoylolCode
  ;; define the testsMonitor context
  ( interpret )   ;; begin the testsMonitor process stack
  thisContext     ;; interpret thisContext onto data stack
  append          ;; append the result
  ( switchCtx )   ;;
  append          ;; append the word switchCtx to the
                  ;; testsMonitor's initial process stack
  
  (
    0             ;; number of attempted suites
    0             ;; number of failed suites
    ()            ;; list of failure reports
  )               ;; testsMonitor data
  
  testsMonitorNS  ;; naming scope of the new context
  thisNaming      ;; defining naming scope
  testsMonitor    ;; defined name of the new context
  defineContext   ;; define the context
\stopJoylolCode

Finally we want to switch to the testsRunner context, however, we also 
want to specify what actions to take when the testsMonitor context 
switches context back to this context. We do this by placing our context 
switch to testsRunner and any subsequent actions into a list and then we 
interpret this list. 

\startJoylolCode
  ;; switch to the testsRunner context and run all of the tests
  (
    ;; switch to the testsRunner context
    testsRunner ;; place the testsRunner context on the stack
    switchCtx   ;; switch to the testsRunner context
    
    ;; when we are re-activated
    "finished ALL TESTS"  ;;
    writeOutNL            ;; say we are done
  )
  interpret     ;; place this list of actions onto
                ;; our process stack and do them
)
tests
runAllTests
define
\stopJoylolCode

We now define the \type{defineTestsSetup} and \type{defineTestsTeardown} 
words. While defined in the tests naming scope, they will be run in the 
testsRunner and its associated testsRunnerNS. 

\startJoylolCode
(
  "defined tests setup"
  writeOutNL  ;; tell everyone we have been run
  
              ;; we use the provided definition
  thisNaming  ;; defining naming scope
  setupTests  ;; name of the new word
  define
)
tests
defineTestsSetup
define
\stopJoylolCode

\startJoylolCode
(
  "defined tests teardown"
  writeOutNL    ;; tell everyone we have been run
  
                ;; we use the provided definition
  thisNaming    ;; defining naming scope
  teardownTests ;; name of the new word
  define
)
tests
defineTestsTeardown
define
\stopJoylolCode

\stopTestSuite


\startTestSuite[running a test suite]

The following figure is a summary of the word/switch pattern of 
\type{runTestSuite} word: 

\externalfigure[runJoylolTestSuite.pdf][width=10cm]

\startJoylolCode
(                       ;; start of the runTestSuite word
  "running test suite"  ;;
  writeOutNL            ;; announce our presence
\stopJoylolCode

We are running in the testsRunner context so we already have a 
\quote{localized} naming scope. So for the \type{runTestSuite} word we 
only need to create the suiteRunnerNS and suiteMonitorNS naming scopes. 

\startJoylolCode
  ;; create the suiteRunnerNS
  thisNaming    ;; define the parent's naming scope
  thisNaming    ;; define in the localized naming scope
  suiteRunnerNS ;; name of the new naming scope
  defineNaming  ;; create the new naming scope
                ;; to be used as the suiteRunner's naming scope
\stopJoylolCode

\startJoylolCode
  ;; create the suiteMonitorNS
  thisNaming      ;; define the parent's naming scope
  thisNaming      ;; define in the localized naming scope
  suiteMonitorNS  ;; name of the new naming scope
  defineNaming    ;; create the new naming scope
                  ;; to be used as the suiteMonitor's naming scope
\stopJoylolCode

We now want to define the default suite setup and teardown words in the 
suiteRunnerNS. 

\startJoylolCode
  ()            ;; empty default setup actions
  suiteRunnerNS ;; define in the suiteRunnerNS
  suiteSetup    ;; name of the new word
  define        ;; define the suiteSetup word
\stopJoylolCode

\startJoylolCode
  ()            ;; empty default teardown actions
  suiteRunnerNS ;; define in the suiteRunnerNS
  suiteTeardown ;; name of the new word
  define        ;; define the suiteTeardown word
\stopJoylolCode

We now create the suiteRunner context.

\startJoylolCode
  ;; define the suiteRunner context
                ;; suiteRunner process (uses provided list of words)
  ()            ;; suiteRunner data
  suiteRunnerNS ;; naming scope of the new context
  thisNaming    ;; defined in the localized naming scope
  suiteRunner   ;; name of the new context
  defineContext ;; define the new context
\stopJoylolCode

We now create the suiteMonitor context.

\startJoylolCode
  ;; define the suiteMonitor context
  ( interpret )   ;; begin the suiteMonitor process stack
  thisContext     ;; interpret thisContext onto data stack
  append          ;; append the result
  ( switchCtx )   ;;
  append          ;; append the word switchCtx to the 
                  ;; suiteMonitor's initial process stack
  
  (
    0             ;; number of attempted cases
    0             ;; number of failed cases
    ()            ;; list of failure reports
  )               ;; suiteMonitor data
  
  suiteMonitorNS  ;; naming scope of the new context
  thisNaming      ;; defining naming scope
  suiteMonitor    ;; name of the new context
  defineContext   ;; define the context
\stopJoylolCode

Finally we want to switch to the suiteRunner context, however, again, we 
also want to specify what actions to take when the suiteMonitor context 
switches back to this context. We do this by placing our context switch to 
suiteRunner and any subsequent actions into a list and then we interpret 
this list. 

\startJoylolCode
  ;; switch to the suiteRunner context and run the suite
  (
    ;; switch to the suiteRunner context
    suiteRunner ;; place the suiteRunner context on the stack
    switchCtx   ;; switch to the suiteRunner context
    
    ;; when we are re-activated
    ;; ... HOW DO WE SWITCH BACK???!!
  )
  interpret
)
tests
runTestSuite
define
\stopJoylolCode

We now define the \type{recordTestSutieDetails}, 
\type{defineTestSuiteSetup}, and \type{defineTestSuiteTeardown} words. 

\startJoylolCode
(
  (
    newLine
    "-------------------------------------"
    newLine
    "jTS:"
  )           ;; format a sign that we are running
              ;; the test suite
  prepend     ;; prepend this sign to the name of the suite
  100         ;; limit the printLoL
  swap12D     ;; put the lol and the depth limit 
              ;; in the correct order
  printLoL    ;; print it to a string
  writeOutNL  ;; write out the string
)
tests
recordTestSuiteDetails
define
\stopJoylolCode

\startJoylolCode
(
  "defined test suite setup"
  writeOutNL  ;; tell everyone we have been run

              ;; we use the provided definition
  thisNaming  ;; defining naming scope
  setupSuite  ;; name of the new word
  define
)
tests
defineTestSuiteSetup
define
\stopJoylolCode

\startJoylolCode
(
  "defined test suite teardown"
  writeOutNL    ;; tell everyone we have been run

                ;; we use the provided definition
  thisNaming    ;; defining naming scope
  teardownSuite ;; name of the new word
  define
)
tests
defineTestSuiteTeardown
define
\stopJoylolCode

\stopTestSuite

\startTestSuite[runTestCase]

Our next task, over the next following code fragments, is to define the 
runTestCase word. This word takes a test case, as a list of the words to 
be tested intermingled with assertions, and creates the testMonitor and 
testRunner contexts which together run the test case provided. To be 
completely re-entrant, the testMonitor and testRunner contexts are stored 
in the running context's localized naming scope. 

The following figure is a summary of the word/switch pattern of 
\type{runTestCase} word: 

\externalfigure[runJoylolTestCase.pdf][width=10cm]

\startJoylolCode
(               ;; start of the runTestCase word
\stopJoylolCode

We are running in the suiteRunner context so we already have a 
\quote{localized} naming scope. So for the \type{runTestCase} word we only 
need to create the testRunnerNS and testMonitorNS naming scopes. 

\startJoylolCode
  ;; create the caseRunnerNS
  thisNaming   ;; parent naming scope
  thisNaming   ;; define in localized naming scope
  caseRunnerNS ;; name of the new naming scope
  defineNaming ;; create a new naming scope
               ;; to be used as the caseRunner's naming scope
\stopJoylolCode

\startJoylolCode
  ;; create the caseMonitorNS
  thisNaming    ;; parent naming scope
  thisNaming    ;; define in the localized naming scope
  caseMonitorNS ;; name of the new naming scope
  defineNaming  ;; create a new naming scope
                ;; to be used as the caseMonitor's naming scope
\stopJoylolCode

At this point the test case's list of words and assertions are back on the 
top of the stack. This list will be used as the testRunner's initial 
process stack. We can now add the initial data stack for the testRunner 
context, and then setup the new context's naming scope, the defining 
naming scope and finally the name of the new context.

\startJoylolCode
  ;; define the caseRunner context
                ;; caseRunner process (uses provided list of words)
  ()            ;; caseRunner data
  caseRunnerNS  ;; the naming scope of the new context
  thisNaming    ;; define in the localized naming scope
  caseRunner    ;; name of the new context
  defineContext ;; create and define the context
\stopJoylolCode

Now we create a caseMonitor context which will keep track of the test 
results. The testMonitor's initial process stack should contain the three 
words, \type{interpret}, the current context, and \type{switchCtx} in this 
order. When an assertion switches from the testRunner's context to the 
testMonitor context the top of the testRunner's stack is place onto the 
top of the testMonitor's data stack. The \type{interpret} word will then 
place the words on the top of the testMonitor's data stack onto the 
testMonitor's process stack to be interpreted. The assertion being 
interpreted \emph{should} ensure it re-places the \type{interpret} word 
back on the testMonitor's process stack for use by the next assertion. 

The last two words, the current context and \type{switchCtx}, as used by the 
textMonitor interpreting the \type{results} word to know which context to 
switch to with the summary results. 

Since the \type{thisContext} word has to be interpreted in the calling 
context, we have to \type{append} the result of interpreting the 
\type{thisContext} word rather than just placing the \type{thisContext} 
word directly on the testMonitor's process stack. Once the 

\startJoylolCode
  ;; define the caseMonitor context
  ( interpret ) ;; begin the caseMonitor process stack
  thisContext   ;; interpret thisContext 
  append        ;; append the result of interpreting thisContext
  ( switchCtx ) ;; 
  append        ;; append the word switch to the
                ;; caseMonitor's initial process stack
  
  ( 
    0           ;; number of attempted assertions
    0           ;; number of failed assertions
    ()          ;; list of failure reports
  )             ;; caseMonitor data

  caseMonitorNS ;; the naming scope of the new context
  thisNaming    ;; defining naming scope
  caseMonitor   ;; defined name of this new context
  defineContext ;; create and define the context
\stopJoylolCode

Finally we switch to the testRunner context.

\startJoylolCode
  ;; switch to the caseRunner context and run the assertions
  caseRunner ;; place the caseRunner context on the stack
  switchCtx  ;; switch to the caseRunner context
  
)            ;; end of the runTestCase definition

tests        ;; define the new word in this naming scope
runTestCase  ;; the name of the new word
define       ;; define the new runTestCase word
\stopJoylolCode

We now define the \type{recordTestCaseDetails} word.

\startJoylolCode
(
  "  jTC:"    ;; format a sign that we are running
              ;; the test case
  prepend     ;; prepend this sign to the name of the case
  100         ;; limit the printLoL
  swap12D     ;; put the lol and the depth limit
              ;; in the correct order
  printLoL    ;; print it to string
  writeOutNL  ;; write out the string
)
tests
recordTestCaseDetails
define
\stopJoylolCode
\stopTestSuite

\startTestSuite[assert.reportAssertion]

In this section we develop the \type{reportAssertion} word in the 
\type{assert} naming scope. This word takes the result of an individual 
assertion, switches to the \type{testMonitor} context and records it 
before switching back to the \type{testRunner} context. 

The \type{reportAssertion} word assumes that any previous assertion has 
left an assertion result list on the top of the testRunner's data stack. 
This assertion result list consists of true/false followed by a failure 
report list (only if the assertion failed). 

\startJoylolCode
(               ;; start of the reportAssertion word
                ;; the assertion report is assumed to be on top
  (
    assert.recordAssertion  ;; the task to be done
    testRunner  ;; return to testRunner
    switchCtx   ;; perform the switch/return
    interpret   ;; leave an initial interpret for the next switch/call
  )
  append
  testMonitor   ;; place the testMonitor context on top of stack
  switchCtx     ;; switch to the testMonitor context
                ;; (the testMonitor context will interpret to
                ;;  current top of the stack)
)               ;; end of the reportAssertion word
assert          ;;define the new word in the assert naming scope
reportAssertion ;; the name of the new word
define          ;; define the reportAssertion word
\stopJoylolCode
\stopTestSuite

\startTestSuite[assert.recordAssertion]

The \type{recordAssertion} word is run on the testMonitor context. It 
assumes that the top of the data stack is a true/false depending upon the 
success/failure of the previous assertion. If the top of the stack is 
false, then the \type{recordAssertion} word also expects a list containing 
the assertion failure reasons as the second item on the stack. The 
subsequent item on the stack is then the context to which to return so 
that any further assertions can be run. Finally the last item on the stack 
is the testMonitor's record of assertion results. 

\startJoylolCode
(
  (
    isTrue
  )  ;; test
  (
    ;; the top of the stack is the testMonitor's
    ;; record of assertion results
    extract
    ;; the top of the stack is the number of attempts value
    1 + ;; add one to the top of the stack
    prepend
    prepend
    ;; the top of the stack is the
    ;; updated record of assertion results
  )  ;; then action ;; just update the number of attempted tests 
  (
    ;; the top of the stack is an assertion failure report list
    ;; then comes the testMonitor's record of assertion results
    append
    extract
    ;; top    comes the number of attempts value
    ;; second comes the number of failures value
    ;; third  comes the collection of failure reports
    ;; fourth comes the assertion failure report list
    1 + ;; add one to the number of attempted
    swap12D
    1 + ;; add one to the number of failed
    append
    rollupD ;; put current record third
    append  ;; append the assertion failure report to list or failures
    append  ;; complete the record of assertion results
    ;; top comes the updated record of assertion results
  )  ;; else action ;; update everything
  ifte
)
assert
recordAssertion
define
\stopJoylolCode
\stopTestSuite

\startTestSuite[start/stop joylol test suite]

\startJoylolCode
  (
  )
  startTestSuite
  define
  
  (
  )
  stopTestSuite
  define
\stopJoylolCode

\stopTestSuite

\startTestSuite[start/stop/skip/run a joylol test case]


\stopTestSuite

\startTestSuite[assertShouldFail]

\startJoylolCode

(
  
)
assert
shouldFail
define
\stopJoylolCode

\startTestCase[assert should fail]
\startJoylolTest
"this is a test"
doSomeThing
\stopJoylolTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertFail]

\startJoylolCode
(
  fail
  assert.reportAssertion
)
assert
fail
define
\stopJoylolCode

\startTestCase[assertFail should fail]
\startJoylolTest
  ;;assert.fail
\stopJoylolTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertSucceed]
\startJoylolCode
(
  succeed
  assert.reportAssertion
)
assert
succeed
define
\stopJoylolCode

\startTestCase[assert.succeed should succeed]
\startJoylolTest
  ;;assert.succeed
\stopJoylolTest
\stopTestCase
\stopTestSuite

\startTestSuite[assert.isBoolean]
\startJoylolCode
(
  isBoolean
  assert.reportAssertion
)
assert
isBoolean
define
\stopJoylolCode

\startTestCase[should succeed if an object is a boolean ]
\startJoylolTest
  ;;true
  ;;assert.isBoolean
\stopJoylolTest
\stopTestCase

\startTestCase[should fail if an object is not a boolean]
\startJoylolTest
  ;;notABoolean
  ;;assert.isBoolean
\stopJoylolTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertTrue]

\stopTestSuite

\startTestSuite[assertFalse]

\stopTestSuite

\startTestSuite[assertNil]

\stopTestSuite

\startTestSuite[assertNotNil]

\stopTestSuite

\startTestSuite[assertAtom]

\stopTestSuite

\startTestSuite[assertPair]

\stopTestSuite

\startTestSuite[assertNatural]

\stopTestSuite

\startTestSuite[assertSymbol]

\stopTestSuite

\startTestSuite[assertContext]

\stopTestSuite

\startTestSuite[assertDictionary]

\stopTestSuite

\startTestSuite[assertDictNode]

\stopTestSuite


\setCHeaderStream{private}
\startCHeader
extern void registerJoylolTestWords(
  JoyLoLInterp* jInterp
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void registerJoylolTestWords(
  JoyLoLInterp* jInterp
) {
  assert(jInterp);

}
\stopCCode