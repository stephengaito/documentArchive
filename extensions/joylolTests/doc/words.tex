% A ConTeXt document [master document: joylolTests.tex]

\section[title=Words]

\startTestSuite[start/stop joylol all tests]

\setJoylolTracingOff\setJoylolVerboseOff

We start by defining a naming scope to contain all of the Joylol test 
associated words. This naming space is denoted \quote{tests} in the 
\quote{globals} naming scope. The \quote{tests} naming scope's parent 
naming scope is also \quote{globals}. 

\startJoylolCode
;; create a tests naming scope
globals      ;; parent naming scope
globals      ;; defining naming scope
tests        ;; defined name of this new naming scope
defineNaming ;; make the definition
\stopJoylolCode

We also create a naming scope to contain all of the asertion related 
words. 

\startJoylolCode
;; create an assert naming scope
tests        ;; parent naming scope
globals      ;; defining naming scope
assert       ;; defined name of this new naming scope
defineNaming ;; make the definition
\stopJoylolCode

Our next task, over the next couple of code fragments, is to define the 
runTestCase word. This word takes a test case, as a list of the words to 
be tested intermingled with assertions, and creates the testMonitor and 
testRunner contexts which together run the test case provided. To be 
completely re-entrant, the testMonitor and testRunner contexts are not 
stored in any naming scope, they only exist on various stacks as they are 
used. 

First we create a context which will run the test case provide. The list 
of test words is located on the top of the joylol-main context and are 
used by the newContext word as the initial process stack for the 
testRunner context. 

PROBLEM: I need to define the contexts in each \emph{other's} naming 
scope. Which means, to inhibit infinite cycles of definitions, I need to 
predefine the two naming scopes and use them "twice", once as the 
context's naming scope and once as the naming scope in which the context 
is defined. To do this I could place them in a \quote{local} naming scope 
of the testFactory, or I could keep them on the stack, but I will need to 
duplicate them and at some point swap them. 

\startJoylolCode

                 ;; testRunner process (uses provided list of words)
( 
)                ;; testRunner data

(
  (
    globals      ;; parent naming scope
    testRunnerNS ;; name of the new naming scope
    newNaming    ;; create a new naming scope
  ) interpret    ;; place the testRunner naming scope on stack
                 ;; to be used as the new context's naming scope

  dup            ;; make a second copy of the testRunnerNS 
                 ;; for use later to lookup testMonitorNS
  
  globals        ;; parent naming scope
  swap           ;; make testRunnerNS the defining naming scope
  testMonitorNS  ;; name of the new naming scope
  defineNaming   ;; create a new naming scope
) interpret      ;; place the testMonitor naming scope on stack
                 ;; to be used as the new context's naming scope
                 
  testMonitorNS  ;; use the dup'ed copy of testRunnerNS
  lookup         ;; to lookup testMonitorNS
  
testRunner       ;; defined name of this new context
defineContext    ;; create and define the context
\stopJoylolCode

Now we create a context which will keep track of the test results. 

\startJoylolCode
( interpret ) ;; testMonitor process

( 
  0           ;; number of attempted tests
  0           ;; number of failed tests
  ()          ;; list of failure reports
)             ;; testMonitor data


???           ;; defining naming scope
testMonitor   ;; defined name of this new context
defineContext ;; create and define the context
\stopJoylolCode



\stopTestSuite

\starttyping
\startTestSuite[start/stop joylol test suite]

\startJoylolCode
  (
  )
  startTestSuite
  define
  
  (
  )
  stopTestSuite
  define
\stopJoylolCode

\stopTestSuite
\stoptyping

\startTestSuite[start/stop/skip/run a joylol test case]

\startJoylolCode
(
  ( interpret ) ;; process
  (
    true ;; test case successful
    false ;; test case should fail
  ) ;; data
  tests
  curTestCase
  defineContext
)
tests
runTestCase
define
\stopJoylolCode

\stopTestSuite

\startTestSuite[reportTestResult]

\startJoylolCode
  (
  )
  reportTestResult
  define
\stopJoylolCode

\stopTestSuite

\startTestSuite[assertShouldFail]

\startJoylolCode

(
  
)
tests
assertShouldFail
define
\stopJoylolCode

\startTestCase[assert should fail]
\startJoylolTest
"this is a test"
doSomeThing
\stopJoylolTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertFail]

\startJoylolCode
(
)
tests
assertFail
define
\stopJoylolCode

\startTestCase[assertFail should fail]
\startJoylolTest
assertFail
\stopJoylolTest
\stopTestCase
\stopTestSuite

\startTestSuite[assertSucceed]

\stopTestSuite

\startTestSuite[assertTrue]

\stopTestSuite

\startTestSuite[assertFalse]

\stopTestSuite

\startTestSuite[assertNil]

\stopTestSuite

\startTestSuite[assertNotNil]

\stopTestSuite

\startTestSuite[assertAtom]

\stopTestSuite

\startTestSuite[assertPair]

\stopTestSuite

\startTestSuite[assertNatural]

\stopTestSuite

\startTestSuite[assertSymbol]

\stopTestSuite

\startTestSuite[assertContext]

\stopTestSuite

\startTestSuite[assertDictionary]

\stopTestSuite

\startTestSuite[assertDictNode]

\stopTestSuite


\setCHeaderStream{private}
\startCHeader
extern void registerJoylolTestWords(
  JoyLoLInterp* jInterp
);
\stopCHeader
\setCHeaderStream{public}

\startCCode
void registerJoylolTestWords(
  JoyLoLInterp* jInterp
) {
  assert(jInterp);

}
\stopCCode