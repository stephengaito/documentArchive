% A ConTeXt document [master document: joyLoL.tex]

\startcomponent overview

\startchapter[title=Overview]

\startsection[title=Implementation]

\startsubsection[title=Bridging the semantic gap]

JoyLoL \emph{is explicitly defined to be} a fixed point of the formal 
semantic functor, making JoyLoL its own formal semantic definition. 
However there is, currently, no existing computational device which 
\emph{implements} the JoyLoL language. That is, there is no computational 
device which \quote{runs} JoyLoL code natively. 

The objective of this document is to provide an implementation of JoyLoL 
in as transparently correct way as possible. As discussed in, 
\cite[gaito2017joyLoLDefinition], the formal definition of any 
computational language has two distinct components: one \emph{deductive} 
and the other \emph{inductive}. While we can rigorously check any 
deductive proofs of correctness, we can only ever hope to falsify any 
inductive tests of correctness. Any formally correct implementation of a 
computational language needs to be explicitly clear where the line between 
the deductively provable and the inductively testable is located.

The desired goal of any rigorous implementation is to keep as much as 
possible of the code deductively provable. Conversely any rigorous 
implementation needs to keep any code which is only inductively testable 
as clear and simple as possible. However how and were we draw the line 
between the deductively provable and the merely inductively testable 
implementation, will have profound impact upon the \emph{performance} of 
all resulting JoyLoL computations run using this implementation. Provable 
correctness \emph{and} performance are \emph{both} critically important. 

To obtain the correct balance of correctness, (potential) performance, and 
simplicity, JoyLoL has been designed as a \quote{trampolining} 
interpreter, written in ANSI-C, but meta-compiled from Literate sources 
written in ConTeXt/LuaTeX which are transcribed into ANSI-C source before 
being compiled to an executable on a given platform by an appropriately 
chosen ANSI-C compiler. 

The literate sources, provide human readable documentation and 
justifications for each JoyLoL Co-Algebraic extension, complete with 
formal semantic definitions of each axiomatic word in JoyLoL. 

\stopsubsection 

\startsubsection[title=ANSI-C system code]

We build the lowest level system code for JoyLoL using ANSI-C with a few 
\quotation{standard} POSIX extension libraries. We have chosen ANSI-C for 
its: 

\startitemize

\item {\bf portability}: There are a large number of ANSI-C compatible C 
compilers which target almost \emph{all} computers currently in existence. 

\item {\bf inter-working}: There are a large number of code libraries 
implementing useful algorithms which can be \quote{loaded} into the 
runtime image of an ANSI-C compiled program.

\item {\bf performance}: \emph{If} desired, the overall JoyLoL interpreter 
can be compiled using any of the modern ANSI-C compilers' optimization 
modes. Since ANSI-C is so heavily used, the optimizing modes of most 
compilers are realatively well \quote{understood}, tested and stable. 

\item {\bf transparency}: The semantic gap between ANSI-C and the 
\quote{assembler} / \quote{machine-code} of almost any computer is small 
enough that a \emph{large number} of skilled programmers could, if needed, 
hand code any C code directly into a given machine-code. For our needs, 
this means that there is no obscure mapping between the short pieces of 
JoyLoL implementation code and a given CPU's machine-code. This ensures 
that what JoyLoL does when running is \quote{relatively} easy to 
understand for most programmers. 

\item {\bf familiarity}: While programmers are only a small part of our 
target audience, given we are explicitly dealing with the mathematics of 
computation, the programming community is an important part of the 
audience. More importantly \quote{most} programmers have a \quote{working} 
familiarity with the subset of ANSI-C used to implement the lowest levels 
of JoyLoL. 

\stopitemize

\stopsubsection

\startsubsection[title=Interpreter structure]

We use a \quote{trampolining} interpreter as the main \quote{eval} loop 
for JoyLoL. Since all JoyLoL words explicitly manage the context's data 
and process stacks, there is no need for the ANSI-C call stack. In the 
best of all worlds we could implement JoyLoL's lowest levels using a 
systems programming language with native Tail Calls. However no such 
language currently exists. While the functional languages such as Haskell, 
and Scheme have native Tail Calls, they do not map sufficiently cleanly 
onto the underlying Assembler of a give computer's CPU. All C-like 
languages who do typically map reasonably cleanly onto a given CPU's 
architecture, do not have a Tail Call friendly call structure. 

Trampolining interpreters are discussed in, \cite[right={, Section 
5.2)}][friedmanWand2008essentialsProgrammingLanguages] 

JoyLoL is a Forth-like language which manipulates \quote{stacks}. Almost 
all existing general purpose computational devices are \quote{register 
based}. Cleanly and performantly implementing stack based languages on a 
register based computational device has been previously explored in Ertl's 
thesis, \cite[ertl1996implementationStackLanguages]. 

has been previously explored in Probst's thesis, 
\cite[probst2001tailRecursionC]. 

\stopsubsection

\stopsection

\stopchapter

\stopcomponent