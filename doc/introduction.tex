% A ConTeXt document [master document: hilbertsProgram.tex]

\chapter[title=Introduction]

\section[title=Goals]

Every long term researcher should have a silly question, if only to keep 
them focused upon whole problems amidst all of the unending detail. Your 
ultimate destination, whether or not you get there, influences how you 
plan to get there. The problem for any researcher, is that the research 
\quote{space} is infinite dimensional. From the dazzle of choices, you 
must make \quote{one} sequence of choices which, one hopes, ultimately 
leads to your answer(s). The vantage point provided by your ultimate goal, 
influences the questions asked and hence the answers found. The choice of 
where you want to get to, does have a profound influence on how you choose 
to get there. 

My silly question is:

\startalignment[center] Why do babies babble?\stopalignment

\blank[big]

There are (at least) two aspects to this question:

\startitemize[n]

\item How do organic naive \quote{brains} build models of reality. Too 
much of classical artificial intelligence focuses on the incremental 
learning based upon the capabilities of \quote{adult} learners. However 
this misses the point of learning models of Reality \emph{ab initio}. 

\item Equally important, is the question of what constitutes an efficient 
model. Animal brains must keenly balance energy use with the 
comprehensiveness of a given model. Any animal that gets this wrong too 
much of the time, becomes someone else's lunch. 

\stopitemize 

So put simply, my objective, as a \emph{mathematician}, is to build 
efficient and mathematically rigorous models Reality. However, if you are 
going to build a mathematically rigorous theory of Reality, you must first 
provide a mathematically rigorous theory of Mathematics itself. This 
document is devoted to providing just such a rigorous foundation for 
Mathematics. 

Since the ancient Greeks, western influenced Philosophical, Scientific, 
Mathematical practice has been to equate rigour with proofs of 
\quote{Truth}. Euclid's \quote{Elements} has, for just over two millennia, 
provided the pre-eminent example of this paradigm of rigorous proof. 
However, G\"odel's two Incompleteness theorems, show that classical proofs 
through logic are unable to provide the rigorous foundations we require. 
This is the failure of Hilbert's \emph{logical} Program. 

Essentially, G\"odel's work around the early 1930's represent the first 
contributions to the theory of computation. G\"odel's theorems from this 
period concern themselves with our ability to compute \quote{Truth}, and 
the fact that such computation of \quote{Truth}, is only partially 
recursive, rather than totally recursive.

Instead of computing \quote{Truth}, is there a more useful computation 
which might provide a foundation of Mathematics? By exploring Hilbert's 
Program within a \emph{computational} framework, the objective of this 
document is to show that the answer to this question is yes. 

\section[title=Some philosophy]

In Western philosophy, since at least the time of the ancient Greeks, 
there have been a wide range of Philosophical theories of the 
\quote{Reality} of \quote{Reality}. Our objective in building a rigorous 
Mathematical theory of Reality is not to prove any of these Philosophical 
theories (in)correct. Instead our objective, and really the only one 
available \emph{Mathematically}, is to explore what a finite computational 
device, \emph{\quote{a wee beastie}}, can learn about Reality. 

\subsection[title=Hume's problem]

Ignoring Hume's \quote{Problem of Induction} for the moment, as a 
Scientist and Engineer, like any young child, I live in the belief that I 
can both learn about and, more importantly, \emph{interact} with Reality. 
To bastardize Descartes, \emph{from moment to moment, I can see that I 
have made marks in the sand, therefore I am}. 

It is naive to assert that finite beings, such as ourselves, can not learn 
to predict at least some of the future. Russell's farmyard birds, given 
their limited cognitive abilities, \emph{are rational} to expect to be 
feed daily\footnote{See chapter VI, \quote{On Induction}, in Russell's 
\quote{The Problems of Philosophy}, \cite{russell1912problemsOfPhilosophy} 
near page 98}. However, for any \emph{finite} being, there will always be 
events, some highly critical events, which are outside of that being's 
ability to know about and hence predict. This is emphatically the 
\emph{\quote{wee}} in my understanding of a \emph{\quote{wee beastie}}. 
For any finte being, there is always a more capable being, we might just 
not yet found these more capable beings. Understanding the limits of being 
finite, is the true import of Hume's Problem. 

It is equally naive to assert that a finite being can not interact with 
their environment. I \emph{can} communicate with you over both distance 
and time. We \emph{can} build (finite) computational devices. I am writing 
this document using one such device, you are no doubt reading this 
document using at least one other. So it is at least potentially 
reasonable to expect that \emph{finitist} Mathematics could be founded 
computationally. 

\TODO{What does it mean to \emph{exist} mathematically?}

\subsection[title=What is a thing?]

\blank[big]\startblockquote

From the range of the basic questions of metaphysics we shall here ask 
this one question: “What is a thing?” The question is quite old. What 
remains ever new about it is merely that it must be asked again and 
again.\footnote{Martin Heidegger, page 1, first paragraph, in 
\cite{heidegger1967whatIsAThing}, as quoted by 
\cite{doeringIsham2008thingTheoryFoundationsPhysics}.} 

\stopblockquote\blank[big]

A Zen Master would respond that there is \emph{no-thing}, there is only 
\emph{is-isness}, \emph{existence in its entirety}\footnote{Indeed a Zen 
Master would refuse to use mere words. To slightly mix philosophies, 
\quote{The Tao which can be named is not the Tao}, or again in Jewish 
tradition, God is not to be directly \emph{named}. Words differentiate 
\quote{things}, and Zen's \quote{existence-in-entirety}, the Tao and God 
are beyond all human limits to differentiate, identify or understand. We, 
as limited beings, can only \emph{experience}. This is similar to Cantor's 
expressed understanding of his Absolute Infinite Magnitudes, again, see 
Cantor's letter to Dedekind dated 1899, 
\cite{vanHeijenoort1967fregeToGodel}.}. That quarrelsome \quote{thing}, 
\emph{\quote{I}}, is only an illusion. The hardest thing any \quote{one} 
can do is to ignore the \emph{\quote{I}} in order to \quote{see} the 
\emph{\quote{is}}. The dissolution of this \emph{\quote{I}} is 
un-important in the context of the \emph{\quote{is}}. In our work, this 
point of view will be indispensable. 

However, for most of \quote{us}, such a view point is very hard to hold. 
We all play a \quote{me}-\quote{environment} game with existence. This 
view point is equally important for our work.

A \quote{quark} plays the absolute simplest of games, a 
\quote{quark}-\quote{everything-else} game. A \quote{quark}, re-acts to 
its environment. Any model of a \quote{quark} is a (fairly) simple 
S-Matrix. 

A frog's game is only slightly less simple, there is the frog, there are 
\quote{things} that are small enough to be potential food, there are 
\quote{things} that are so large they might be predators, and finally 
there are \quote{things} which might be potential mates. A frog's 
\quote{environment} has some substructure, \quote{prey}, 
\quote{predators}, and \quote{mates}. We assume that a frog's brain 
models, to a sufficiently complex level of detail, these three 
\quote{things}, however, by and large, frogs do not need to expend much 
more energy on playing any more complex games so they don't. By modelling 
only the most important categories, frogs can save energy by not building 
and maintaining complex and energetically expensive nervous 
systems\footnote{See, for example, Ewert's \emph{Motion Perception Shapes 
the Visual World of Amphibians}, 
\cite{ewert2004motionPerceptionAmphibians}. While this reference focuses 
primarily on the visual system of amphibians, it indicates an overall lack 
of need for complex models in an amphibian's nervous system. It is 
estimated, \cite{raichleGusnard2002brainEnergyBudget}, that the adult 
human brain consumes around 20\% of all calories consumed each day, yet 
the human brain only represents around 2\% of our body weight. Nervous 
systems \emph{are} relatively expensive to keep running. For most of a 
frog's needs, this additional complexity is not needed, this is a frog's 
evolutionary niche.} 

A human's game is \emph{much} more complex. We regularly, split 
\quote{our} environment into many many \quote{things}. \quote{Objects} for 
which we build wide classes of models of their behaviour and even their 
potential internal, \quote{intentional}, state of \quote{mind}. Chairs and 
mugs have different uses. Metals and glasses, have different abilities to 
be re-fashioned into useful tools. Animals have widely different 
behaviours providing useful companions or dangerous enemies. Even more 
complex, though, are our \quote{models} of other humans. Each person in 
our environment, has widely differing objectives of their \quote{own}. All 
of which we must, and, by and large, do, keep track of. For each of these 
objects we take an \emph{intentional stance}\footnote{See Daniel Dennett's 
\quote{The Intentional Stance}, \cite{dennett1987a}.}, they each have 
various, though widely, differing abilities to re-act, or intend with 
\quote{me}. These different intentional abilities are reflected in the 
overall complexity in the various models we build to represent any 
particular \quote{thing}. 

So how do we, most efficiently, build these models? Naively, we all 
\quote{know} what an object \quote{is} when we \quote{see} it. Physics 
suggests that all material things are made up of sub-atomic particles 
which are in turn made up of \quote{quarks}. It is \quote{obvious} at one 
level that \quote{I} and \quote{you} are \quote{different} things. 
However, when I shake your hand, where do \quote{my} \quote{quarks} end 
and \quote{your} \quote{quarks} begin? At the \quote{most basic} level, we 
can not separate one \quote{thing} from another \quote{thing}. A Zen 
master's view is actually deeply entwined with any complete mathematical 
model of \quote{things}. How do we reconcile these multiple levels of 
\quote{being} into one comprehensive and complete model of 
\quote{Reality}? 

Andreas D\"oring and Chris Isham in their paper, \emph{What is a thing?}, 
\cite{doeringIsham2008thingTheoryFoundationsPhysics}, suggest that Physics 
can best be captured using the variable sets point of view provided by 
Categorical Topos\footnote{See Lawvere's concept of variable sets, 
\cite{lawvere1975continuouslyVariableSets} or 
\cite{lawvereRosebrugh2003setsForMathematics}.}. For us, a Topos over a 
collection of descriptive \quote{levels}, provides the natural tool with 
which to capture the coherent variation of \quote{thing-ness} as our level 
of description varies. This suggests that the use of the structuralist 
Categorical point of view, in general, and the associated variable 
descriptive Topos point of view, in particular, will be very important to 
our work. 

\subsection[title=A Neuron's eye view]

So lets reflect for a moment on a neuron's point of view. When a neuron 
fires, it \quote{means} something, but what does it mean? Deeply embedded 
inside a complex collection of other neurons, each collecting the spike 
trains from countless other neurons. In some sense each neuron integrates 
the \quote{information} conveyed by each of these spike trains from 
up-stream neurons. What sort of information should these spike trains be 
communicating? At the very least they should be communicating some 
important value. This is what artificial neural networks model. 

\TODO{Bayesian brain, \cite{doyaIshiiPougetRao2007bayesianBrain}, Spikes, 
\cite{riekeWarlandDeRuyterVanSteveninck1999spikesNeuralCode} Pouget, 
\cite{beckPouget2007inferencesImplementationMarkov} and 
\cite{knillPouget2004bayesianUncertaintyComputation}, markov models, 
Shalizi spatial models, \cite{shalizi2001thesis}, section 10.2.1 \emph{Why 
Global States Are not Enough}, required. Markov has restrictive scope of 
description... but by recoding and using levels of description, we can 
recover the effect of history on the present and future.} 

\TODO{talk about Wally's oversight... \cite{walley1991impreciseProb}. 
There is a deep distinction between the ideal asymptotic reals and the 
finite subsequences of processes} 

\TODO{rework the following paragraphs}

So this paper generalizes the collected work of Spitters, Coquand, (see, 
for example, \cite{coquandSpitters2009integralsAndValuations})\footnote{It 
is also important to see the related work of Heunen, Landsman and 
Spitters, \cite{heunenLandsmanEtAl2009toposForAlgebraicQuantumTheory}}, 
together with Walley's work on imprecise probabilities, to produce a 
computable measure theory which a beastie could use. \TODO{Add the work of 
\cite{jackson2006phdThMeasureThSheaves} and its generalization in Isham 
\cite{doeringIsham2008thingTheoryFoundationsPhysics}, Section 8.2} 

As has become traditional in Imprecise Probability theory, in his book, 
\emph{Statistical Reasoning with Imprecise Probabilities}, 
\cite{walley1991impreciseProb}, Walley makes the upper and lower 
previsions (expectations) the primary objects of study with upper and 
lower probabilities as derived concepts. Since we will be concerned with 
probability based Markov structures we will reverse this orientation. One 
of the reasons Walley choose to work with previsions (expectations) 
instead of probabilities is because of his belief that Lower Probablities 
did not determine Lower Previsions (see section 2.7.3 page 82, 
\cite{walley1991impreciseProb}). In fact we will show below that with the 
correct definition of upper and lower measures and upper and lower 
integrals, lower probabilities do determine lower previsions. This will be 
the substance of the (Imprecise) Dedekind-Riesz Representation Theorms 
proven below. 

\TODO{paragraphs above}

\subsection[title=Mappae Mundi]

From our \quote{modern} point of view, Mappae Mundi are, at best, highly 
distorted (navigational) \quote{maps}. From the original 
\quote{cartographer's} point of view, each Mappa Mundi provides a useful 
representation of an important understanding about the 
\emph{cartographer's} \quote{world}. However, a modern notion of 
\quote{navigation} was highly \emph{un}-likely to be the primary purpose 
of any given historical Mappa Mundi. 

Research Mathematicians who habitually cross (standard) mathematical 
disciplines, of necessity, become collectors of mathematical mappa mundi. 
Each (matheamtical) mappa mundi represents an idea in a given discipline, 
which is slightly \quote{wrong} or \quote{mis-shappen} for the research 
mathematician's problem(s) at hand. The \quote{problem(s) at hand} are 
very unlikely to be well represented (if at all) on any existing 
mathematical mappa mundi. This is after all the \emph{point} of 
mathematical research.

\TODO{list my mappae mundi}

\subsection[title=Hilbert's program]

\TODO{Talk about meta-mathematics} 

Hilbert's primary objective was to provide a rigorous 
foundation for Analysis whose metamathematics is finitist. 

\TODO{discuss the concept of data versus processes. classical computation 
theory has been mostly focused upon data not proceses.} 

The classical Reals, which are required for classical Analysis, are 
uncountable. Once we have defined the Ordinals, we will find that there is 
a reasonable definition of $\lambda$-computation for each ordinal, 
$\lambda$. \emph{If} we assume a computational equivalent to the 
\quote{standard} Axiom of Choice, then we can define the transfinite 
ordinals and hence computational structures which can interpret the 
uncountable collection of the Reals (as \emph{data}). Using this 
structure, we will then be able to develop the classical theory of 
Analysis, which was Hilbert's ultimate goal. 

Alternatively, we can define the Reals as (measurement) \emph{processes}, 
with out requiring any \emph{transfinite} ordinals. The resulting theory 
of Analysis will not be quite classical, since the \emph{internal} logic 
of the collection of processes, is not classical. However, I conjecture 
that this process logic provides an explanation of the \quote{strangeness} 
of, and hence the correct foundations for, Quantum Mechanics. 

\TODO{Need to introduce collection of processes as a (co)algebraic 
collection/structure.... we distinguish different processes by observing 
them...} 
\TODO{For this work the focus upon the well-founded/data/algebraic versus 
the non-well-founded/process/co-algebraic is all pervasive. } 

\TODO{Categorical thought == structuralist point of view. Quote 
\cite{awodey2009a}.} 
\TODO{discuss reals as data versus reals as processes == imprecise Reals.} 

\section[title=Some Mathematics]

\subsection[title=A tale of two foundations]

In this document, we are \emph{explicitly} re-founding mathematics using a 
\emph{computational} as opposed to a \emph{logical} tool-set. To a 
classically trained mathematician, these computational foundations will be 
strange at first. The complexity of the foundations of any building 
prefigure the building itself. However any foundations only make sense if 
one reflects on what the building \emph{will be} rather than what the 
foundations are. It is no different in mathematics. 

To help overcome the initial strangeness of these computational 
foundations, we will provide a running commentary using (as yet) classical 
mathematical terminology. Once we have the new foundations secure we can 
translate all of classical mathematics into the new tools. However, until 
the foundations are secure, we need to carefully distinguish between 
\emph{extra-foundational commentary} using classical mathematics, 
typically, classical Category theory, and the actual re-founded 
foundations. 

\startMMundi As this paragraph shows, we will distinguish any 
\emph{extra-foundational comments} by placing them between 
\color[darkgray]{grey} angled over and under bars. The angled over bar 
will also contain the words \emph{\color[darkgray]{Classical commentary}}. 
From the beginning of the next subsection, all \emph{extra-foundational 
comments} will be carefully delineated from the re-foundations themselves. 
\stopMMundi 

\subsection[title=What \emph{does} a Mathematician do?]

\startMMundi

With a \emph{computational} foundation for Mathematics, from the point of 
view of Computer Science, the task of Mathematics, is to provide various 
specialized \emph{rigorous programming languages}. Each of these 
programming languages provides users, engineers, scientists and other 
mathematicians, languages in which complicated computations are easier to 
understand and perform. The languages of Group theory, Lie Algebras, 
Differential Topology, Number theory, and Algebraic Geometry, are just one 
scattered collection of examples. 

Any given programming language consists of a pair of a \emph{syntax} and a 
corresponding \emph{semantics}. The syntax defines which finite texts 
represent valid static descriptions of the dynamic unfolding of various 
computations. The corresponding semantics provides a compositional 
interpretation of the meaning of any given syntactic text. In the theory 
of Computer Science, the connection between a given syntax and a given 
semantic model, is a collection of \emph{GSOS} laws. From a categorical 
point of view, any collection of GSOS laws is represented by a 
distributivity law, a natural transformation, between a pair of 
endo-functors. The initial algebra of one of these endo-functors 
represents the syntax of the programming language. The final coalgebra of 
the other endo-functor represents the semantics. The natural 
transformation itself, is effectively an \emph{interpreter} for the 
programming language. 

The importance of this description is that there can be many syntaxes 
representing the various mathematical languages, areas or disciplines. 
Equally, there could be many different semantics into which a given syntax 
is interpreted. At the moment, within the logical foundation of 
mathematics, the semantics of mathematics is generally agreed to be set 
theory augmented with first-order logic. That is, it is generally assumed 
that any mathematical discipline can be transcribed or interpreted in the 
language of first-order set theory, which in turn provides a 
\quote{rigorous} meaning to statements in the original discipline. 

For a computational foundation of Mathematics, we seek a semantics in 
which various syntaxes can be easily interpreted via GSOS laws. While 
there may be many categorically equivalent semantics, including, for 
example, some form of first-order set theory, we will, in this document, 
base our semantics on Lists of Lists. We will show that these Lists of 
Lists are effectively a fixed point of the \quote{semantic interpretation 
functor}.

A critical criteria which the Lists of Lists semantics satisfies which 
almost any form of first-order set theory will not satisfy, is a 
combination of textual and conceptual simplicity. Like any axiomatic 
theory, the basic axioms must be assumed \quote{true}, or in our 
compuational case \quote{computationally correct}. Our Lists of Lists 
semantics will rely on a very small collection of computations which are, 
for Lists of Lists, both textually simple and \quote{obviously 
computationally correct}. 

In this computational interpretation, what is a proof? Classically we have 
a distinction between \emph{constructive} and \emph{(non-constructive) 
existence} proofs. Constructive proofs are, by and large, essentially 
computations. Indeed in one of the most common formalisms of constructive 
logic, Per Martin-L\"of's type theory, there is a theory of how to extract 
computational programs from the constructive type theoretic proof. 

We will argue that all non-constructive existence proofs correspond to 
searches. The proof by contradiction is essentially a proof that a given 
search algorithm will complete, we just do not know how or when. Nor can 
we provide a closed form solution, all we can provide is a specification 
of what a given solution, once found, will satisfy. 

Given that vanishingly few existing computer programs are proven 
completely correct, how do we know that a given program text computes what 
it purports to compute? At a high level, we use Hoare's system of pre and 
post conditions and show that the given program text, if started in an 
environment satisfying its preconditions will, if it halts, leave its 
environment in a condition which satisfies its postconditions. Since any 
semantic interpretation of a programming language is \emph{compositional}, 
we can recursively apply Hoare's pre and post conditions to each sub-text 
of a given program until we ultimately reach \emph{atomic} statements 
which are declared to satisfy particular pre and post conditions. This is 
not dissimilar to how we currently structure a fully formal proof in set 
theory. 

In mathematics based upon either (classical) logic or computation, we need 
a logic. Unfortunately our existing first-order logic does not \quote{deal 
with} the underlying dynamics of computation. Equally importantly, 
existing (classical) logic is deemed to \emph{be} the \quote{structure} of 
\quote{human} thought (and argumentation). That is first-order logic is 
essentially \emph{extra-mathematical} as it pre-figures mathematical 
discourse.

The logic we will use to establish the computational correctness of a 
given program text, will be the $\mu$-modal logic of an underlying 
Interpreted Transition System associated with the chosen semantic model. 
This logic is inherently designed to deal with the dynamics of 
computation. More importantly, the $\mu$-modal logic we will define, will 
be intimately related to the structure of our semantic interpretation of 
computation. Once we define our semantic interpretation, the $\mu$-modal 
logic is given. Even more importantly there are well defined algorithms 
based upon the theory of two person parity games which can \emph{compute} 
the satisfiability of the collection of pre and post conditions asserted 
about any particular program text purporting to itself compute a 
mathematical result. 

So in this computational interpretation, what do typical mathematicians 
do? Some search for new algorithms to solve new problems. Some worry about 
finding the most conceptually elegant (efficient) algorithm to program the 
proof of a given theorem. Others worry about the expressivity of the 
language they use in a given discipline. Yet others worry about the 
semantic interpretation of the particular language they use. In all of 
these cases the annotation of any given algorithm with a satisfiable 
collection of $\mu$-modal pre and post conditions is required for any 
completely rigorous mathematical result. 

\stopMMundi

\subsection[title=What \emph{can} a \quote{wee beastie} do?]

Intuitionistic Mathematics, as initiated by Brouwer, has identified the 
concept of the \quote{Idealized Mathematician}. Since this document is 
focused upon the \emph{Mathematics} of the \quote{Reality} which a wee 
beastie can know, for this document, we will identify any wee beastie with 
this Idealized Mathematician, and conversely, any Idealized Mathematician, 
with this wee beastie. 

Unlike Kant, this idealization makes \emph{no} assumptions about the 
structure of time or space. One consequence of our analysis of what a wee 
beastie can know, is space-time itself. 

Following Hilbert, we will assume a number of undefined terms which will 
be defined by their use in our theory. In the following definition, using 
well known practice from Computer Science, we \emph{could} use the word 
\quote{widget} to emphasize, with Hilbert, that our undefined terms can 
represent anything which behaves in the prescribed way. Having made this 
point, we will actually use the undefinded but slightly more suggestive 
terminology of \quote{Lists of Lists} or \lols. 

\startDefinition

We assume any wee beastie exists in a \quote{collection} of \quote{List of 
Lists} (\lols). With these \lols, a wee beastie can: 

\startitemize[n]

\item create a new \lol\ by \quote{\type{cons}}ing any two existing 
\lols\ together. 

\item create a new \lol\ by \quote{\type{car}}ing an existing \lol. 

\item create a new \lol\ by \quote{\type{cdr}}ing an existing \lol. 

\item create a new \quote{\type{nil}} \lol.

\stopitemize

\noindent This is \emph{all} that any wee beastie, or (Idealized) 
Mathematician can do to \lols\ in its environment\footnote{In Volume II, 
we will add one more thing that a \emph{transfinite} wee beastie can do.}. 

\stopDefinition

\startMMundi From a classical point of view, the four things that a 
wee beastie can do, defines the following \emph{endo-functor} from the 
Category of Sets to itself\footnote{See, for example, 
\cite{jacobs2017coalgebras}}: 

\placeformula[+]\startformula
  F(X) = 1 + X \times X
\stopformula

\noindent The initial algebra and final coalgebra are defined by the 
respective isomorphisms: 

\placesubformula\startformula\startalign
  \NC F(\wflol) \NC \longRightIsoArrow \wflol  \NR[eq:a][a]
  \NC \lol      \NC \longRightIsoArrow F(\lol) \NR[eq:b][b]
\stopalign\stopformula

\noindent The initial algebra, \wflol, above, is the collection of 
\emph{well-founded} Lists of Lists. The final co-algebra, \lol, above, is 
the collection of (potentially) \emph{non-well-founded} Lists of Lists. 

For a given ordinal, $\lambda$, the concept of 
\quote{$\lambda$-computational power}, is critical to our theory. In the 
next volume, once we have progressed far enough to be able to define the 
ordinals, we will define $\lambda$-computation as the computing 
\quote{power} associated with a wee beastie whose computational 
\quote{traces} are at most $\lambda$ in length. 

Assuming a wee beastie has $\omega$-computational power, then clearly any 
\lol\ a wee beastie might \emph{create}, from scratch, must be 
well-founded. However, given any already \emph{existing} \lol, a wee 
beastie can not know if it is well-founded or not. Hence, for our work, 
the collection of \emph{non-well-founded} \lols\ is the \emph{primary} 
collection. The sub-collection of \emph{well-founded} \lols, is important 
but secondary. 

Notice our \emph{explicit} use of John McCarthy's notation for the 
programming language LISP, 
\cite{mcCarthyAbrahamsEdwardsHartLevin1965lispManual}. \stopMMundi 

\startMMundi

To help us navigate through our relatively complex \quote{story}, it will 
be useful to introduce our cast of thousands: 

\startitemize[n]

\item \bold{Transition Systems} the basis of $\mu$-modal logic for 
processes. A transition system whose transition relation is transitive, is 
a Category (and is the basis of Dynamic Logic). 

\item \bold{Categories} 

\item \bold{The category of \wflol s}: most important for our work will be 
the \emph{category} of Lists of Lists, \catWFLoL. The \emph{objects} of 
\catWFLoL\ will be the collection of \wflols. The \emph{morphisms} of 
\catWFLoL\ will be any \emph{finite sequence} of the list operators, 
\type{cons}, \type{car}, \type{cdr} and \type{nil}. Composition of 
morphisms in \catWFLoL, is simple concatenation of finite sequences of list 
operators. 

\item \bold{The category of \lol s}: most important for our work will be 
the \emph{category} of Lists of Lists, \catLoL. The \emph{objects} of 
\catLoL\ will be the collection of \lols. The \emph{morphisms} of 
\catLoL\ will be any \emph{finite sequence} of the list operators, 
\type{cons}, \type{car}, \type{cdr} and \type{nil}. Composition of 
morphisms in \catLoL, is simple concatenation of finite sequences of list 
operators. 

\item \bold{The \wflol\ functor}: $\funcWFLoL : \catWFLoL \rightarrow \catWFLoL$ 
defined by 

\placeformula[+]\startformula
  \funcWFLoL(X) = 1 + X \times X
\stopformula

\noindent For $X \in \catWFLoL$. Note that \funcWFLoL\ is an endo-functor of 
the category \catWFLoL. 

\item \bold{The \lol\ functor}: $\funcLoL : \catLoL \rightarrow \catLoL$ 
defined by 

\placeformula[+]\startformula
  \funcLoL(X) = 1 + X \times X
\stopformula

\noindent For $X \in \catLoL$. Note that \funcLoL\ is an endo-functor of 
the category \catLoL. 

\item \bold{Algebras of \funcLoL}: Given any 

\item \bold{CoAlgebras of \funcLoL}:

\item \bold{\lol functor as a monad}:

\item \bold{\lol functor as a comonad}:

\item \bold{Eilenberg-Moore category of \funcLoL\ as a monad}:

\item \bold{Eilenberg-Moore category of \funcLoL\ as a comonad}:

\item \bold{Kleisli category of \funcLoL\ as a monad}: provides the natural 
category in which to discuss the process traces, and (eventually) space-time.

\item \bold{Kleisli category of \funcLoL\ as a comonad}: ?

\item \bold{Multi-sets}: We implement \quote{sets} using \lols\ using a 
\quote{mulit-set}. Basically a multi-set is a list of elements which might 
have multiple \quote{copies} of any given element. For 
\quote{sets}/\quote{multi-sets} in \wflol\ we \emph{could} sort the list 
and remove any duplicates. However, while it is possible to sort (in the 
limit) non-well-founded objects in \lol and/or non-well-founded lists of 
objects, any finite computational approximation will by necessity be a 
multi-set. Hence we generally deal with mulit-sets instead of sets. 

\item \bold{Multi-powerset}: Generalizing powersets we get 
multi-powersets. The (co)(contra)variant (multi-)powerset, \powerSet, is a 
(co)monad. 

\item \bold{GSOS laws}: see \cite{jacobs2017coalgebras} definition 5.5.6 on 
page 323. 

\stopitemize

\stopMMundi

\subsection[title=What \emph{can} a \quote{wee beastie} know?]

\startDefinition

Again, we assume that any wee beastie exists in a 
\quote{collection} of \lols. With these \lols, a wee beastie 
can preform (\emph{compute}) the following tests:

%\setupitemize[2]

\startitemize[n]

\item Atomic Tests

\startitemize[n]

\item the test which always succeeds,

\item the test which always fails,

\item the test which succeeds if an existing \lol\ is 
\quote{\type{nil}},

\stopitemize

\item Static Test Combinators

\startitemize[n]

\item the test which succeeds if given pair of other tests both succeed.

\item the test which succeeds if one or more of a given pair of other 
tests succeeds. 

\item the test which succeeds if a given other test fails.

\stopitemize

\item Dynamic Test Combinators

\startitemize[n]

\item the test which succeeds if a given other test succeeds after 
\quote{\type{cons}}ing a pair of existing \lols.

\item the test which succeeds if a given other test succeeds after 
\quote{\type{car}}ing an existing \lol.


\item the test which succeeds if a given other test succeeds after 
\quote{\type{cdr}}ing an existing \lol.

\item the test which succeeds if a given other tests succeeds after 
creating a new \quote{\type{nil}} \lol.

\stopitemize

\stopitemize

If any of the above tests does \emph{not} succeed, then that test fails. 
This is \emph{all} that any wee beastie (or Idealized Mathematician) can 
know by testing \lols\ in its environment. 

\stopDefinition

\TODO{We have defined the \quote{necessary} modal operators, do we need to 
define the corresponding \quote{possible} modal operators?} 

\startMMundi

The atomic tests provide the \emph{only} tests that a wee beastie can 
perform \emph{\quote{directly}} on its environment. All other tests are 
formed via various test combinators from these three atomic tests. Of 
these three atomic tests, only the third atomic test increases the wee 
beastie's knowledge of its environment. Neither of the first two atomic 
tests reference the \quote{state} of the wee beastie's environment. 

The three static test combinators correspond to the core of classical 
(static) propositional logic. Note that we do \emph{not} assume the 
classical \quote{principle of the excluded middle}, hence we must define 
both the \quote{logical} \quote{conjunction} (\quote{and}) as well as the 
\quote{logical} \quote{disjunction} (\quote{or}) operators. It will turn 
out that while the principle of the excluded middle \emph{is} valid for 
any finitely defined collection of (non-)well-founded \lols, it need 
\emph{not} valid for \quote{asymptotically} defined collection 
(non-)well-founded \lols. 

Classical logic, including propositional, first or higher order, concerns 
itself with \quote{properties} of a single \emph{fixed} \quote{unchanging} 
\quote{world}. Since there is no change, there is no corresponding sense 
of \quote{time}. Wee beasties, such as ourselves, experience a 
\quote{world} of constant change. While we will not (yet) explicitly 
define time, as wee beasties, we are naturally interested in what will 
happen to our world if we change it. The dynamic test combinators capture 
how given tests will change if a wee beastie changes its environment by 
first performing one of its possible actions on its environment. 

The complete collection of tests forms a \quote{temporal} or 
\quote{dynamic} modal logic similar to those discussed in 
\cite{demriGorankoLange2016temporalLogics} and 
\cite{harelKozenTiuryn2000dynamicLogic} respectively. 

\TODO{discuss Kirpke semantics/frames/worlds}

\stopMMundi 

\subsection[title=Identity and Bisimulation]

When can a wee beastie know that two \lols\ the \emph{same} \lol? Given 
the capabilities listed above, a wee beastie can never know if two \lols\ 
are \emph{identical}, the \emph{same} or \emph{equal}. The best a wee 
beastie can do is to compare a pair of \lol's using the same collection of 
\emph{tests}. 

\startDefinition

Two \lols\ are \emph{Bisimilar} if they pass the same collection of tests.

\stopDefinition

\startMMundi This concept of Bisimulation has been identified by a number 
of Mathematicians and Computer Scientists. From the theory of 
non-well-founded sets, see \cite{aczel1988nonWellFoundedSets}. From the 
theory of co-algebras, see Chapter 3 of \cite{jacobs2017coalgebras}. 
\stopMMundi 

Finally, linking the above three definitions together we make the 
following assertion about any wee beastie and its environment of \lols: 

\begingroup\startAssertion

\startitemize[n]

\item \quote{\type{car}} of the \quote{\type{nil}} \lol\ is bisimular to 
\quote{\type{nil}}. 

\item \quote{\type{cdr}} of the \quote{\type{nil}} \lol\ is bisimular to 
\quote{\type{nil}}. 

\item \quote{\type{car}} of the \quote{\type{cons}} of two \lols\ is 
bisimular to the first \lol. 

\item \quote{\type{cdr}} of the \quote{\type{cons}} of two \lols\ is 
bisimular to the second \lol. 

\item \quote{\type{cons}} of the pair of \lols\ obtained by 
\quote{\type{car}} and \quote{\type{cdr}} of the same \lol, is bisimular 
to the original \lol. 

\stopAssertion\endgroup

As a result of these assertions, the only \quote{meaningful} tests are 
those which consist of collections of \quote{\type{car}}s and 
\quote{\type{cdr}}s. Assertions 3 and 4 imply that any 
\quote{\type{cons}}s can be undone by appropriate use of 
\quote{\type{car}}s and \quote{\type{cdr}}s. 

\subsection[title=Barr's theorem]

\startMMundi

\placeformula[+]\startformula \startMPcode{commDiag}
  setupCommDiags ; 
  
  addObject(1,1, "X_0");
  addObject(1,2, "X_1");
  addObject(1,3, "\cdots");
  addObject(1,4, "X_n");
  addObject(1,5, "X_{n+1}");
  addObject(1,6, "\cdots");
  
  addObject(2,1, "Y_0");
  addObject(2,2, "Y_1");
  addObject(2,3, "\cdots");
  addObject(2,4, "Y_n");
  addObject(2,5, "Y_{n+1}");
  addObject(2,6, "\cdots");

  drawObjects(1.75cm, 2cm);

  addArrow(1,1, 1,2, ">", 0)()()("j_0",     0.5, top);
  addArrow(1,2, 1,3, ">", 0)()()("",        0.5, );
  addArrow(1,3, 1,4, ">", 0)()()("",        0.5, );
  addArrow(1,4, 1,5, ">", 0)()()("j_n",     0.5, top);
  addArrow(1,5, 1,6, ">", 0)()()("",        0.5, );
  addArrow(1,1, 2,1, ">", 0)()()("k_0",     0.5, lft);
  addArrow(1,2, 2,2, ">", 0)()()("k_1",     0.5, rt);
  addArrow(1,4, 2,4, ">", 0)()()("k_n",     0.5, lft);
  addArrow(1,5, 2,5, ">", 0)()()("k_{n+1}", 0.5, rt);
  addArrow(2,2, 2,1, ">", 0)()()("t_1",     0.5, bot);
  addArrow(2,3, 2,2, ">", 0)()()("",        0.5, );
  addArrow(2,4, 2,3, ">", 0)()()("",        0.5, );
  addArrow(2,5, 2,4, ">", 0)()()("t_{n+1}", 0.5, bot);
  addArrow(2,6, 2,5, ">", 0)()()("",        0.5, );

\stopMPcode \stopformula

\stopMMundi

\subsection[title=Lawvere's Theorem]

\section[title=Strategy]

This document will provide a rigorous \emph{computational} foundation of 
Mathematics, by... 

\TODO{Need to talk about lists of lists}

We will do this in a number of distinct steps. Firstly, by defining a 
computational langauge, JoyLoL (\quote{The Joy of Lists of 
Lists}\footnote{Or is it \quote{The Joy of Laughing out Loud}?}). JoyLoL 
is a functional \emph{concatenative} language based upon Manfred von 
Thun's language Joy, \cite{vonThun1994overview}. The critically important 
aspect of JoyLoL is that it is constructed to be a fixed point of the 
semantics functor. This means that JoyLoL provides its own denotation, 
operational and axiomatic semantics. JoyLoL does not rely upon any other 
\quote{pre-existing} structures or set theory to define its meaning. An 
other important aspect of JoyLoL is that it is a \emph{concatenative} 
function language. Almost all other functional programming languages are 
based upon Church's $\lambda$-calculus, importantly, this means that most 
such langauges are focused upon function evaluation and substitution. From 
a categorical point of view, this means that the collection of 
computational traces forms a Topos. Being \emph{concatenative}, the 
collection of JoyLoL computational traces forms a Category, which also 
happens to be a Topos. The distinction here is important. The requirements 
of being a Category are much simpler and valid of many more distinct 
sub-collections of computational traces. 

, we can construct the structure of all JoyLoL computational traces. We 
can define the collection of \emph{finite} substructures as those 
substructures for which a simple \emph{short} JoyLoL program \emph{halts}. 
These finite substructures 

Since there \emph{are} JoyLoL computations which do not halt, this 
structure 

