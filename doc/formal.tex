% A ConTeXt document [master document: hilbertsProgram.tex]

\chapter[title=Formal System]

By its very nature, the process of founding Mathematics is circular. All 
previous attempts at founding Mathematics, have quietly assumed 
\emph{Mathematical} Logic, in one form or another, as a given. Less 
obviously, all previous foundations of Mathematics, have also implicitly 
assumed that \emph{something} can \emph{compute} the logical validity of a 
proof, and hence have implicitly assumed the \emph{Mathematical} theory of 
computation. 

Since we can, \quotation{from moment to moment, see that we have made 
marks in the sand}, we will simply assume that we can \emph{compute}. But 
\emph{if} we are going to \emph{found} Mathematics by \emph{Computing} 
things, how do we know that what we have computed is really what we set 
out to compute? How do we compute the validity of what we have computed? 
What do we mean by the validity of what we have computed? 

Previous attempts to found Mathematics answered their equivilant questions 
using Logic. 

Talk about Mathematicians as (Rigorous) (Computer) Language designers... 
mathematicians design languages with which to computer interesting 
\quote{results} in a rigorous way. 


Talk about intuition, classical proofs, computational proofs.

Talk about proof relevant mathematics and proof existent mathematics.

Talk about how classical/intuitionistic constructive/non-constructive 
debate misses the point. All of mathematics is one.. the real question is 
which "collections" of mathematical objects admit proofs of the various 
types. Recursive sets are classical, Recursively enumerable sets are 
intuitionistic. non-constructive proofs require unbounded search using 
axiom of choice. 

Talk about proofs as computation traces. Proof sketches provide way-points 
in any given computation traces. Existence of a proof-computation-trace 
"proves" a theorem, but "having" computational traces, or various 
way-points, provide far more information for the purposes of both 
"understanding" and "generalization". 

The "base space" of computational traces form a category, while the fibers 
of logic or type theory, form a topos. Essentially this is because JoyLoL 
computational traces can be concatenated but the logic "about" the 
computational traces, must identify "things" "inside" each computation. 
Hence we do not use variables in the base space, but we do in the fibres. 

non-total computation is formally based upon the ideas from 
lindstrom1989nonWellFoundedSetsMartinLofTypeTheory NOTE that the 
uniformity of the computation from step to step is critical to providing a 
well defined computation at infinity. 

Object Language

Meta-Language

We need the ability to specify (sub)collections of \quote{computational 
results}. 

\subject[title=A Tale of many languages]

talk about joylol and joylol0

talk about conservative extensions

talk about mathematicians/programmers versus sceptical 
philosophers/business analysts

talk about intuition being operationalized... how do we tell if we have 
operationalized correctly? 

talk about intuitive "ordinals", ""

Need to "prove" something simple


Define DictNode:

\starttyping
typedef struct joylol_object_struct {
  JClass    *type;
  TagType    tag;
  FlagsType  flags; // an arbitrary collection of bits
} JObj;

typedef struct dictNode_object_struct {
  JObj         super;
  Symbol      *symbol;
  JObj        *preObs;
  JObj        *value;
  JObj        *postObs;
  DictNodeObj *left;
  DictNodeObj *right;
  DictNodeObj *previous;
  DictNodeObj *next;
  size_t       height;
  long         balance;
} DictNodeObj;
\stoptyping

\subsection[title=Mappae Mundi]

Our foundation of mathematics is best understood as an, alas, fairly 
complex multi-induction of a Categorical natural transformation between a 
pair of functors. While we do not require Category theory for this 
induction, using ideas from Category theory helps us navigate through this 
complexity. In effect Category theory provides one (of many) mappa mundi. 

The ideas required to navigate through this multi-induction, comes from 
Bart Jacob's pair of books \cite{jacobs1999categoricalLogicTypeTheory} and 
\cite{jacobs2017coalgebras} combined with Harel, Kozen and Tiuryn's 
\cite{harelKozenTiuryn2000dynamicLogic} as well as Demri, Goranko and 
Lange's \cite{demriGorankoLange2016temporalLogics}. 

Coalgebras, bisimulations, modal logic, invariants and liftings of both 
relations and predicates, permeate everything we do, 
\cite{jacobs2017coalgebras}. In particular Modal logics via the predicate 
lifting approach using the natural transformation between a pair of 
functors, see Definition 6.5.1 \cite{jacobs2017coalgebras}\footnote{See 
also \cite{kupkePattinson2011coalgModalLogics} discussion of the same 
ideas.}, is particularly important. However \emph{the} modal logic that we 
are after is Dynamic Logic, see sections 5.2 and 11.3 
\cite{harelKozenTiuryn2000dynamicLogic}. This \quote{modal logic} actually 
requires the lifting of \emph{both} predicates and relations. However, the 
critically important thing is that the \emph{syntax} of the Dynamic 
(modal) logic is interpreted in the \emph{semantics} of the coalgebra of 
lists of lists. 

The critical complication comes from our need to \quote{prove} that the 
natural transformation between the pair of functors, which is a 
\emph{computation}, actually computes what we say it computes. To do this 
we will make use of the tools found in 
\cite{demriGorankoLange2016temporalLogics} culminating in the 
\quote{Satisfiability-Checking Game for ${L}_\mu$} found in section 
15.4.1. Central to this is the use of the least and greatest fixed point 
operators, $\mu$ and $\nu$, in a $\mu$-modal logic variant of Dynamic 
Logic. We will use \quote{Lawvere's mating rule} definition of $\forall$ 
and $\exists$ as described in Jacob's Lemma 4.1.8 
\cite{jacobs1999categoricalLogicTypeTheory}. However, since we are 
defining a concatenative computational language, instead of fibering over 
\emph{sets} of variables we fiber over lists. The fibers are then all the 
possible \quote{valuations} of a given list. 

