;; A JoyLoL implementation of the Bottom-Up MergeSort algorithm 

;; we begin with some helpful joylol words

;;clear
;;showStack

;;showStackOn
;;tracingOn
;; debugOn

;;showStackOff
;;tracingOff
;;debugOff

;;definitions

;;tests
;;definitionsIn

;; Now we look at the mergeSort algorithm

(
  mergeSort
  { true } ;; precondition
  (
           ;; expects an unsorted list on top
    ()     ;; empty sorted stack
    1      ;; current index
    mergeSortRecurse
  )        ;; process stack
  { true } ;; postcondition
)
globals
define

(
  mergeSortRollUp
  { true }
  (
    dup1D
    ( isZero ) 
    (
      pop1D
    )
    (
      (
        2 %rev
        isZero
      )
      (
        "test" tracingPoint
        swap12D
        popList
        popList
        mergeSort2Lists
        prepend
        swap12D
        2 /rev
        mergeSortRollUp
      )
      (
        ;; nothing more to do
      )
      ifte
    )
    ifte
  )
  { true }
)
globals
define

(
  mergeSortRecurse
  { true }
  (
    swap13D ;; swap the unsorted list to the top
    dup1D
    (
      isNil
    )
    (
      pop
      mergeSortRollUpAll
    )
    (
      popList    ;; pop the first item off the unsorted list
      swap23D    ;; swap the unsorted list back into place
      prepend    ;; place the ?? on to the sorted stack
      rollDown3D ;; swap the sorted stack into the second place
      dup1D      ;; duplicate the index
      swap23D    ;; swap a copy of the index out of the way
      mergeSortRollUp
      swap12D    ;; swap the index back into place
      1 + 
      mergeSortRecurse
    )
    ifte
  )
  { true }
)
globals
define

showStackOn
tracingOn

((1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16) mergeSort ) i


